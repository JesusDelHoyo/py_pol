<!DOCTYPE html>
<html class="writer-html5" lang="English" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>py_pol.mueller &mdash; Python polarization 1.1.2 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> Python polarization
          </a>
              <div class="version">
                1.1.2
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../readme.html">1. Python polarization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">2. Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples.html">3. Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">4. py_pol</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contributing.html">5. Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../history.html">6. History</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../authors.html">7. Credits</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Python polarization</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../index.html">Module code</a> &raquo;</li>
      <li>py_pol.mueller</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for py_pol.mueller</h1><div class="highlight"><pre>
<span></span><span class="c1"># !/usr/bin/env python3</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1"># ------------------------------------</span>
<span class="c1"># Authors:    Luis Miguel Sanchez Brea and Jesus del Hoyo</span>
<span class="c1"># Date:       2019/01/09 (version 1.0)</span>
<span class="c1"># License:    GPL</span>
<span class="c1"># -------------------------------------</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Mueller objects describe optical polarization elements in the Mueller-Stokes formalism.</span>

<span class="sd">**Class fields:**</span>
<span class="sd">    * **M**: 4x4xN array containing all the Mueller matrices.</span>
<span class="sd">    * **name**: Name of the object for print purposes.</span>
<span class="sd">    * **shape**: Shape desired for the outputs.</span>
<span class="sd">    * **size**: Number of stored Mueller matrices.</span>
<span class="sd">    * **ndim**: Number of dimensions for representation purposes.</span>
<span class="sd">    * **no_rotation**: If True, rotation method do not act upon the object. Useful for objects that shouldn&#39;t be rotated as mirrors.</span>
<span class="sd">    * **type**: Type of the object (&#39;Mueller&#39;). This is used for determining the object class as using isinstance may throw unexpected results in .ipynb files.</span>
<span class="sd">    * **parameters**: parameters of the Mueller matrices.</span>
<span class="sd">    * **checks**: checks of the Mueller matrices.</span>
<span class="sd">    * **analysis**: analysis of the Mueller matrices.</span>


<span class="sd">**Parent methods**</span>
<span class="sd">    * **clear**:  Removes data and name form Jones vector.</span>
<span class="sd">    * **copy**:  Creates a copy of the Jones_vector object.</span>
<span class="sd">    * **stretch**:  Stretches a Jones vector of size 1.</span>
<span class="sd">    * **shape_like**:  Takes the shape of another object to use as its own.</span>
<span class="sd">    * **reshape**: Changes the shape of the object.</span>
<span class="sd">    * **flatten**:  Transforms N-D objects into 1-D objects (0-D if only 1 element).</span>
<span class="sd">    * **flip**: Flips the object along some dimensions.</span>
<span class="sd">    * **get_list**: Creates a list with single elements.</span>
<span class="sd">    * **from_list**: Creates the object from a list of single elements.</span>
<span class="sd">    * **concatenate**: Canocatenates several objects into a single one.</span>
<span class="sd">    * **draw**: Draws the components of the object.</span>
<span class="sd">    * **clear**: Clears the information of the object.</span>


<span class="sd">**Generation methods**</span>
<span class="sd">    * **from_components**: Creates a Mueller matrix directly from the 16 $M_{ij}$ elements.</span>
<span class="sd">    * **from_matrix**: Creates a Mueller object directly from a 4x4xN matrix.</span>
<span class="sd">    * **from_normalized**: Creates a Mueller matrix directly from a normalized 4x4 matrix ($M_{norm} = M/M_{00}$).</span>
<span class="sd">    * **from_Jones**: Creates a Mueller Matrix equivalent to a Jones matrix.</span>
<span class="sd">    * **from_blocks**: Creates a Mueller matrix from the blocks of its decomposition.</span>
<span class="sd">    * **from_covariance**: Creates a Mueller matrix from the equivalent covariant matrix.</span>
<span class="sd">    * **from_inverse**: Creates a Mueller matrix from the inverse matrix.</span>
<span class="sd">    * **from_list**: Creates a Jones_matrix object directly from a list of 4x4 numpy arrays.</span>
<span class="sd">    * **vacuum**: Creates the matrix for vacuum.</span>
<span class="sd">    * **mirror**: Creates the matrix for a mirror. NOTE: This matrix mus not be rotated.</span>
<span class="sd">    * **filter_amplifier**: Creates the matrix for a neutral filter or amplifier element.</span>
<span class="sd">    * **depolarizer_perfect**: Creates a perfect depolarizer.</span>
<span class="sd">    * **depolarizer_diagonal**: Creates a depolarizer with elements just in the diagonal.</span>
<span class="sd">    * **depolarizer_states**: Creates a general depolarizer from the diattenuation, polarizance and eigenstate vectors.</span>
<span class="sd">    * **diattenuator_perfect**: Creates a perfect linear polarizer.</span>
<span class="sd">    * **diattenuator_linear**: Creates a real diattenuator with perpendicular axes.</span>
<span class="sd">    * **diattenuator_charac_angles**: Creates the most general homogeneous diattenuator with orthogonal eigenstates from the characteristic angles of the main eigenstate.</span>
<span class="sd">    * **diattenuator_azimuth_ellipticity**: Creates the most general homogenous diattenuator from the characteristic angles of the main eigenstate.</span>
<span class="sd">    * **diattenuator_vector**: Creates the most general homogenous diattenuator from the diattenuation vector.</span>
<span class="sd">    * **quarter_waveplate**: Creates a perfect retarder with 90ยบ retardance.</span>
<span class="sd">    * **half_waveplate**: Creates a perfect retarder with 180ยบ retardance.</span>
<span class="sd">    * **retarder_linear**: Creates a linear retarder.</span>
<span class="sd">    * **retarder_charac_angles**: Creates the most general homogeneous retarder from the characteristic angles of the fast eigenstate.</span>
<span class="sd">    * **retarder_azimuth_ellipticity**: Creates the most general homogeneous retarder from the characteristic angles of the fast eigenstate.</span>
<span class="sd">    * **retarder_from_vector**: Creates the most general homogeneous retarder from the retardance vector.</span>
<span class="sd">    * **diattenuator_retarder_linear**: Creates an homogeneous linear diattenuator retarder with the same axes for diattenuation and retardance.</span>
<span class="sd">    * **diattenuator_retarder_azimuth_ellipticity**: Creates the most general homogeneous diattenuator retarder with the same axes for diattenuation and retardance from the azimuth and ellipticity angle.</span>
<span class="sd">    * **diattenuator_retarder_charac_angles**: Creates the most general homogeneous diattenuator retarder with the same axes for diattenuation and retardance from the characteristic angles.</span>
<span class="sd">    * **general_eigenstates**: Generates the most general pure optical element from its eigenstates.</span>


<span class="sd">**Manipulation methods**</span>
<span class="sd">    * **rotate**: Rotates the Mueller matrix.</span>
<span class="sd">    * **sum**: Calculates the summatory of the Jones matrices in the object.</span>
<span class="sd">    * **prod**: Calculates the product of the Jones matrices in the object.</span>
<span class="sd">    * **remove_global_phase**: Removes the phase introduced by the optical element.</span>
<span class="sd">    * **add_global_phase**: Increases the phase introduced by the optical element.</span>
<span class="sd">    * **set_global_phase**: Sets the phase introduced by the optical element.</span>
<span class="sd">    * **reciprocal**: Flips the optical element so the light transverses it in the opposite direction.</span>
<span class="sd">    * **transpose**: Transposes the Mueller matrix of the element.</span>
<span class="sd">    * **inverse**: Calculates the inverse matrix of the Mueller matrix.</span>
<span class="sd">    * **covariant_matrix**: This method calculates the covariant matrix of the Mueller matrix of the object.</span>


<span class="sd">**Parameters subclass methods**</span>
<span class="sd">    * **matrix**:  Gets a numpy array with all the matrices.</span>
<span class="sd">    * **components**: Extracts the four components of the Mueller matrix.</span>
<span class="sd">    * **global_phase**: Extracts the global phase introduced by the object.</span>
<span class="sd">    * **blocks**: Method that divides a mueller matrix in their blocks: mean transmission ($M_{00}$), diattenuation and polarizance vectors and small matrix m.</span>
<span class="sd">    * **diattenuation_vector**: Extracts the 3xN array of diattenuation vectors.</span>
<span class="sd">    * **polarizance_vector**: Extracts the 3xN array of polarizance vectors.</span>
<span class="sd">    * **small_matrix**: Extracts the 3x3xN array of small matrix m.</span>
<span class="sd">    * **retardance_vector**: Extracts the 3xN array of retardance vectors (if exists).</span>
<span class="sd">    * **mean_transmission**: Calculates the mean transmission coefficient.</span>
<span class="sd">    * **transmissions**: Calculates the maximum and minimum transmissions.</span>
<span class="sd">    * **inhomogeneity**: Calculates the inhomogeneity parameter.</span>
<span class="sd">    * **diattenuation**: Calculates the diattenuation of a Mueller matrix.</span>
<span class="sd">    * **diattenuation_linear**: Calculates the linear diattenuation of a Mueller matrix.</span>
<span class="sd">    * **diattenuation_circular**: Calculates the circular diattenuation of a Mueller matrix.</span>
<span class="sd">    * **polarizance**: Calculates the polarizance of a Mueller matrix.</span>
<span class="sd">    * **polarizance_linear**: Calculates the linear polarizance of a Mueller matrix.</span>
<span class="sd">    * **polarizance_circular**: Calculates the delay of the matrix.</span>
<span class="sd">    * **degree_polarizance**: Calculates the degree of polarizance.</span>
<span class="sd">    * **spheric_purity**: Calculates the spheric purity grade.</span>
<span class="sd">    * **retardance**: Calculates the retardance (also refered as delay) of the Mueller matrix of a pure retarder.</span>
<span class="sd">    * **polarimetric_purity**: Calculates the degree of polarimetric purity of a Mueller matrix.</span>
<span class="sd">    * **depolarization_index**: Calculates the depolarization_index of a Mueller matrix.</span>
<span class="sd">    * **polarimetric_purity_indices**: Calculates the polarimetric purity indices of a Mueller matrix.</span>
<span class="sd">    * **eig**: Calculates the eigenvalues and eigenstates (eigenvectors) of the Mueller matrices.</span>
<span class="sd">    * **eigenvalues**: Calculates the eigenvalues and of the Mueller matrices.</span>
<span class="sd">    * **eigenvectors**: Calculates the eigenvectors of the Mueller matrices.</span>
<span class="sd">    * **eigenstates**: Calculates the eigenstates (Stokes vectors of the eigenvectors) of the Mueller matrices.</span>
<span class="sd">    * **det**: Calculates the determinant and of the Mueller matrices.</span>
<span class="sd">    * **trace**: Calculates the trace of the Mueller matrices.</span>
<span class="sd">    * **norm**: Calculates the norm of the Mueller matrices.</span>
<span class="sd">    * **get_all**: Returns a dictionary with all the parameters of the object.</span>


<span class="sd">**Checks subclass methods**</span>
<span class="sd">    * **is_physical**:  Conditions of physical realizability.</span>
<span class="sd">    * **is_non_depolarizing / is_pure**: Checks if matrix is non-depolarizing.</span>
<span class="sd">    * **is_homogeneous**: Checks if the matrix is homogeneous (eigenstates are orthogonal). It is implemented in two different ways.</span>
<span class="sd">    * **is_retarder**: Checks if the matrix M corresponds to a pure retarder.</span>
<span class="sd">    * **is_diattenuator / is_polarizer**: Checks if the matrix M corresponds to a pure homogeneous diattenuator.</span>
<span class="sd">    * **is_depolarizer**: Checks if the object corresponds to a depolarizer.</span>
<span class="sd">    * **is_singular**: Checks if the matrix is singular (at least one of its eigenvalues is 0).</span>
<span class="sd">    * **is_symmetric**: Checks if the Mueller matrices are symmetric.</span>
<span class="sd">    * **is_eigenstate**: Checks if a given light state is an eigenstate of the objct.</span>
<span class="sd">    * **get_all**: Returns a dictionary with all the checks of the object.</span>


<span class="sd">**Analysis subclass methods**</span>
<span class="sd">    * **diattenuator**: Calculates all the parameters from the Mueller Matrix of a diattenuator.</span>
<span class="sd">    * **polarizer**: Calculates all the parameters from the Mueller Matrix of a diattenuator using the polarizance vector. If the polarizer is homogeneous, this is equivalent to the previous method.</span>
<span class="sd">    * **retarder**: Calculates all the parameters from the Mueller Matrix of a retarder.</span>
<span class="sd">    * **depolarizer**: Calculates some of the parameters from the Mueller matrix of a diattenuator.</span>
<span class="sd">    * **filter_physical_conditions**: Method that filters experimental errors by forcing the Mueller matrix M to fulfill the conditions necessary for a matrix to be physicall.</span>
<span class="sd">    * **filter_purify_number**: Purifies a Mueller matrix by choosing the number of eigenvalues of the covariant matrix that will be made 0.</span>
<span class="sd">    * **filter_purify_threshold**: Purifies a Mueller matrix by making 0 the eigenvalues of the covariant matrix lower than a certain threshold.</span>
<span class="sd">    * **decompose_pure**: Polar decomposition of a pure Mueller matrix in a retarder and a diattenuator.</span>
<span class="sd">    * **decompose_polar**: Polar decomposition of a general Mueller matrix in a depolarizer, retarder and a diattenuator.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">.py_pol</span> <span class="kn">import</span> <span class="n">Py_pol</span>
<span class="kn">from</span> <span class="nn">.stokes</span> <span class="kn">import</span> <span class="n">Stokes</span><span class="p">,</span> <span class="n">create_Stokes</span>
<span class="kn">from</span> <span class="nn">.jones_matrix</span> <span class="kn">import</span> <span class="n">Jones_matrix</span>
<span class="kn">from</span> <span class="nn">.jones_vector</span> <span class="kn">import</span> <span class="n">Jones_vector</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">degrees</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="n">num_decimals</span><span class="p">,</span> <span class="n">number_types</span>
<span class="kn">from</span> <span class="nn">sympy.functions.special.tensor_functions</span> <span class="kn">import</span> <span class="n">Eijk</span>
<span class="kn">from</span> <span class="nn">numpy.linalg</span> <span class="kn">import</span> <span class="n">inv</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">arctan2</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">sqrt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>

<span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span>

<span class="n">tol_default</span> <span class="o">=</span> <span class="n">eps</span>
<span class="n">counter_max</span> <span class="o">=</span> <span class="mi">20</span>
<span class="n">N_print_list</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">print_list_spaces</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">empty_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
<span class="n">change_names</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">tol_default</span> <span class="o">=</span> <span class="n">eps</span>
<span class="n">unknown_phase</span> <span class="o">=</span> <span class="kc">False</span>
<span class="n">default_phase</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">zero_D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">zero_m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

<span class="c1"># Create a list with the base of matrices and its kronecker product</span>
<span class="n">S</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>
    <span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]]),</span>
    <span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]),</span>
    <span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="p">]</span>
<span class="n">S_kron</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
        <span class="n">S_kron</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">j</span><span class="p">])))</span>

<span class="c1">#############################################################################</span>
<span class="c1"># Methods</span>
<span class="c1">#############################################################################</span>


<div class="viewcode-block" id="create_Mueller"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.create_Mueller">[docs]</a><span class="k">def</span> <span class="nf">create_Mueller</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;M&#39;</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">out_object</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Method that creates several Mueller_matrix objects at the same time from a list of names or a number.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        name (string or list): Name of the object for print purposes. Default: &#39;M&#39;.</span>
<span class="sd">        N (int): Number of created elements. Default: 1.</span>
<span class="sd">        out_object (bool): If N=1 and out_object is True the output is a Jones_matrix instead of a list. Default: True.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        self.parameters (class): Class containing the measurable parameters of the Mueller matrices.</span>
<span class="sd">        self.checks (class): Class containing the methods that check something about the Mueller matrices.</span>

<span class="sd">    Returns:</span>
<span class="sd">        J (list or Mueller_matrix): Result.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">J</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">name</span><span class="p">:</span>
            <span class="n">J</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Mueller</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="n">J</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Mueller</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">J</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">out_object</span><span class="p">:</span>
        <span class="n">J</span> <span class="o">=</span> <span class="n">J</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">J</span></div>


<div class="viewcode-block" id="set_printoptions"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.set_printoptions">[docs]</a><span class="k">def</span> <span class="nf">set_printoptions</span><span class="p">(</span><span class="n">N_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">list_spaces</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Method that modifies the global print options parameters.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        N_print_list (int): Number of matrices that will be printed as a list if the shape of the object is 1D. Default: None</span>
<span class="sd">        print_list_spaces (int): Number of spaces between matrices if they are printed as a list. Default: None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">N_print_list</span><span class="p">,</span> <span class="n">print_list_spaces</span>
    <span class="k">if</span> <span class="n">list_spaces</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">print_list_spaces</span> <span class="o">=</span> <span class="n">list_spaces</span>
    <span class="k">if</span> <span class="n">N_list</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">N_print_list</span> <span class="o">=</span> <span class="n">N_list</span></div>


<span class="c1">################################################################################</span>
<span class="c1"># Main class</span>
<span class="c1">################################################################################</span>


<div class="viewcode-block" id="Mueller"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Mueller">[docs]</a><span class="k">class</span> <span class="nc">Mueller</span><span class="p">(</span><span class="n">Py_pol</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class for Mueller matrices</span>

<span class="sd">    Parameters:</span>
<span class="sd">        name (str): name of Mueller matrix, for string representation</span>

<span class="sd">    Attributes:</span>
<span class="sd">        M (np.ndarray): 4x4xN array of floats containing all the Mueller matrices.</span>
<span class="sd">        m00 (np.ndarray): 1xN array containing the $M_{00}$ element of all Mueller matrices.</span>
<span class="sd">        D (np.ndarray): 3xN array containing the diattenuation vectors of the Mueller matrices.</span>
<span class="sd">        P (np.ndarray): 3xN array containing the polarizance vectors of the Mueller matrices.</span>
<span class="sd">        m (np.ndarray): 3xN array containing the rest of the Mueller matrices.</span>
<span class="sd">        global_phase (np.ndarray): 1xN array storing the global phase introduced by the optical objects.</span>
<span class="sd">        name (string): Name of the object for print purposes.</span>
<span class="sd">        shape (tuple or list): Shape desired for the outputs.</span>
<span class="sd">        size (int): Number of stored Mueller matrices.</span>
<span class="sd">        ndim (int): Number of dimensions for representation purposes.</span>
<span class="sd">        no_rotation (bool): If True, rotation method do not act upon the object. Useful for objects that shouldn&#39;t be rotated as mirrors.</span>
<span class="sd">        type (string): Type of the object (&#39;Jones_matrix&#39;). This is used for determining the object class as using isinstance may throw unexpected results in .ipynb files.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        self.parameters (class): parameters of the Mueller matrices.</span>
<span class="sd">        self.checks (class): checks of the Mueller matrices.</span>
<span class="sd">        self.analysis (class): analysis of the Mueller matrices.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">__array_priority__</span> <span class="o">=</span> <span class="mi">30000</span>

    <span class="c1">############################################################################</span>
    <span class="c1"># Operations</span>
    <span class="c1">############################################################################</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;M&#39;</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">_class</span><span class="o">=</span><span class="s2">&quot;Mueller&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">no_rotation</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_global_phase</span> <span class="o">=</span> <span class="n">default_phase</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span> <span class="o">=</span> <span class="n">Parameters_Mueller</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis</span> <span class="o">=</span> <span class="n">Analysis_Mueller</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">checks</span> <span class="o">=</span> <span class="n">Check_Mueller</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds two Mueller matrices.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            other (Mueller or Jones_vector): 2nd matrix to add.</span>

<span class="sd">        Returns:</span>
<span class="sd">            M2 (Mueller): Result.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">type</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;Jones_matrix&#39;</span><span class="p">,</span> <span class="s1">&#39;Mueller&#39;</span><span class="p">):</span>
                <span class="c1"># Transform other to Mueller if necessary</span>
                <span class="n">M2</span> <span class="o">=</span> <span class="n">Mueller</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;Jones_matrix&#39;</span><span class="p">:</span>
                    <span class="n">M1</span> <span class="o">=</span> <span class="n">Mueller</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                    <span class="n">M1</span><span class="o">.</span><span class="n">from_Jones</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">M1</span> <span class="o">=</span> <span class="n">other</span>
                <span class="c1"># Calculate the new global phase</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">global_phase</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">M1</span><span class="o">.</span><span class="n">global_phase</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">phase</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">global_phase</span> <span class="o">==</span> <span class="n">M1</span><span class="o">.</span><span class="n">global_phase</span><span class="p">):</span>
                    <span class="n">phase</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">global_phase</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">phase</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="c1"># Calculate the new matrix</span>
                <span class="n">M2</span><span class="o">.</span><span class="n">from_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span> <span class="o">+</span> <span class="n">M1</span><span class="o">.</span><span class="n">M</span><span class="p">,</span> <span class="n">global_phase</span><span class="o">=</span><span class="n">phase</span><span class="p">)</span>
                <span class="n">M2</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">take_shape</span><span class="p">((</span><span class="bp">self</span><span class="p">,</span> <span class="n">M1</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">change_names</span><span class="p">:</span>
                    <span class="n">M2</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot; + &quot;</span> <span class="o">+</span> <span class="n">M1</span><span class="o">.</span><span class="n">name</span>
                <span class="k">return</span> <span class="n">M2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;other is </span><span class="si">{}</span><span class="s1"> instead of Jones_matrix.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">other</span><span class="o">.</span><span class="n">type</span><span class="p">))</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;other is not a py_pol object but </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)))</span>

    <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Substracts two Mueller matrices.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            other (Mueller or Jones_vector): 2nd matrix to substract.</span>

<span class="sd">        Returns:</span>
<span class="sd">            M3 (Mueller): Result.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">M3</span> <span class="o">=</span> <span class="bp">self</span> <span class="o">+</span> <span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">change_names</span><span class="p">:</span>
            <span class="n">M3</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot; - &quot;</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span>
        <span class="k">return</span> <span class="n">M3</span>

    <span class="k">def</span> <span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Multiplies a Mueller matrix by a number. If the number is complex or real negative, the absolute value is used and the global phase is updated acordingly.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            other (float, complex or numpy.ndarray): number to multiply.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (Mueller): Result.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">M3</span> <span class="o">=</span> <span class="n">Mueller</span><span class="p">()</span>
        <span class="c1"># Save the Number of elements, and then flatten</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">number_types</span><span class="p">):</span>
            <span class="n">N</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">other2</span> <span class="o">=</span> <span class="n">other</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">N</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">size</span>
            <span class="n">other2</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Other is not a number or a numpy array&#39;</span><span class="p">)</span>
        <span class="c1"># Calculate components</span>
        <span class="n">components</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">components</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># Check that the multiplication can be performed</span>
        <span class="k">if</span> <span class="n">N</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">N</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Calculate the absolute value and complex phase of the number</span>
            <span class="n">mod</span><span class="p">,</span> <span class="n">phase</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">other2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">other2</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">):</span>
                <span class="n">components</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">components</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">*</span> <span class="n">mod</span>
            <span class="c1"># Create the object</span>
            <span class="n">M3</span><span class="o">.</span><span class="n">from_components</span><span class="p">(</span><span class="n">components</span><span class="p">,</span> <span class="n">global_phase</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">global_phase</span><span class="p">)</span>
            <span class="n">M3</span><span class="o">.</span><span class="n">add_global_phase</span><span class="p">(</span><span class="n">phase</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="n">M3</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">take_shape</span><span class="p">((</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">number_types</span><span class="p">):</span>
                <span class="n">M3</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;The number of elements in other (</span><span class="si">{}</span><span class="s1">) and </span><span class="si">{}</span><span class="s1"> (</span><span class="si">{}</span><span class="s1">) is not the same&#39;</span>
                <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">number_types</span><span class="p">)</span> <span class="ow">and</span> <span class="n">change_names</span><span class="p">:</span>
            <span class="n">M3</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; * &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">M3</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">M3</span>

    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Multiplies the Mueller matrix by a number, an array of numbers, a Stokes or Jones vector, or another Mueller or Jones matrix.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            other (float, numpy.ndarray, Stokes, Jones_vector, Mueller or Jones_matrix): 2nd object to multiply.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (Mueller): Result.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Multiplication by numbers or arrays is already implemented in __mul__</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">number_types</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">other</span> <span class="o">*</span> <span class="bp">self</span>
        <span class="c1"># Multiply by py_pol objects</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># try:</span>
            <span class="c1"># Transform Jones vectors if required</span>
            <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;Jones_vector&#39;</span><span class="p">:</span>
                <span class="n">new_other</span> <span class="o">=</span> <span class="n">Stokes</span><span class="p">()</span>
                <span class="n">new_other</span><span class="o">.</span><span class="n">from_Jones</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">other</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;Jones_matrix&#39;</span><span class="p">:</span>
                <span class="n">new_other</span> <span class="o">=</span> <span class="n">Mueller</span><span class="p">()</span>
                <span class="n">new_other</span><span class="o">.</span><span class="n">from_Jones</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_other</span> <span class="o">=</span> <span class="n">other</span>
            <span class="c1"># Prepare variables</span>
            <span class="n">new_self</span><span class="p">,</span> <span class="n">new_other</span> <span class="o">=</span> <span class="n">expand_objects</span><span class="p">([</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_other</span><span class="p">],</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">new_other</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;Stokes&#39;</span><span class="p">:</span>
                <span class="n">M3</span> <span class="o">=</span> <span class="n">Stokes</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">new_other</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;Mueller&#39;</span><span class="p">:</span>
                <span class="n">M3</span> <span class="o">=</span> <span class="n">Mueller</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;other is not a correct py_pol object, but </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">other</span><span class="o">.</span><span class="n">type</span><span class="p">))</span>
            <span class="c1"># Multiply</span>
            <span class="n">Mf</span> <span class="o">=</span> <span class="n">matmul_pypol</span><span class="p">(</span><span class="n">new_self</span><span class="o">.</span><span class="n">M</span><span class="p">,</span> <span class="n">new_other</span><span class="o">.</span><span class="n">M</span><span class="p">)</span>
            <span class="c1"># if new_self.size == 1:</span>
            <span class="c1">#     Mf = new_self.get_list() @ new_other.get_list()</span>
            <span class="c1"># else:</span>
            <span class="c1">#     # Move axes of the variables to allow multiplication</span>
            <span class="c1">#</span>
            <span class="c1">#     M1 = np.moveaxis(new_self.M, 2, 0)</span>
            <span class="c1">#     if new_other.type is &#39;Stokes&#39;:</span>
            <span class="c1">#         M2 = np.moveaxis(new_other.M, 1, 0)</span>
            <span class="c1">#         M2 = np.expand_dims(M2, 2)</span>
            <span class="c1">#         Mf = M1 @ M2</span>
            <span class="c1">#         Mf = np.moveaxis(np.squeeze(Mf), 0, 1)</span>
            <span class="c1">#     else:</span>
            <span class="c1">#         M2 = np.moveaxis(new_other.M, 2, 0)</span>
            <span class="c1">#         Mf = M1 @ M2</span>
            <span class="c1">#         Mf = np.moveaxis(Mf, 0, 2)</span>
            <span class="n">M3</span><span class="o">.</span><span class="n">from_matrix</span><span class="p">(</span><span class="n">Mf</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">change_names</span><span class="p">:</span>
                <span class="n">M3</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot; * &quot;</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span>
            <span class="c1"># except:</span>
            <span class="c1">#     raise ValueError(</span>
            <span class="c1">#         &#39;other is not number, numpy.ndarray or py_pol object, but {}.&#39;.format(type(other)))</span>
        <span class="n">M3</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">take_shape</span><span class="p">((</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">number_types</span><span class="p">)</span> <span class="ow">and</span> <span class="n">change_names</span><span class="p">:</span>
            <span class="n">M3</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; * &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">return</span> <span class="n">M3</span>

    <span class="k">def</span> <span class="fm">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Divides a Mueller matrix by a number. If the number is complex or real negative, the absolute value is used and the global phase is updated acordingly.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            other (float or numpy.ndarray): Divisor.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (Mueller): Result.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">M3</span> <span class="o">=</span> <span class="bp">self</span> <span class="o">*</span> <span class="p">(</span><span class="n">other</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">number_types</span><span class="p">)</span> <span class="ow">and</span> <span class="n">change_names</span><span class="p">:</span>
            <span class="n">M3</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot; / &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">M3</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;prints information about class&quot;&quot;&quot;</span>
        <span class="c1"># Extract the components</span>
        <span class="n">components</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">components</span><span class="p">()</span>
        <span class="c1"># If the object is empty, say it</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> is empty</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="c1"># If the object is 0D or 1D, print it like a list or inline</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># Short enough objects can be printed as a list of matrices</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="n">N_print_list</span><span class="p">:</span>
                <span class="nb">list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_list</span><span class="p">(</span><span class="n">out_number</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> = </span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="nb">str</span> <span class="o">=</span> <span class="nb">str</span> <span class="o">+</span> <span class="n">PrintMatrices</span><span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">print_list_spaces</span><span class="p">)</span>
            <span class="c1"># Print the rest using a single line for each component</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> M00 = </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">components</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">ind1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">ind2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">ind1</span> <span class="o">+</span> <span class="n">ind2</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="nb">str</span> <span class="o">=</span> <span class="nb">str</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span> <span class="o">*</span> \
                                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; M</span><span class="si">{}{}</span><span class="s2"> = </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ind1</span><span class="p">,</span>
                                                                        <span class="n">ind2</span><span class="p">,</span> <span class="n">components</span><span class="p">[</span><span class="n">ind1</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="n">ind2</span><span class="p">])</span>
        <span class="c1"># Print higher dimensionality as pure arrays</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="k">for</span> <span class="n">ind1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">ind2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
                    <span class="nb">str</span> <span class="o">=</span> <span class="nb">str</span> <span class="o">+</span> \
                        <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> M</span><span class="si">{}{}</span><span class="s2"> =</span><span class="se">\n</span><span class="s2"> </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">ind1</span><span class="p">,</span> <span class="n">ind2</span><span class="p">,</span> <span class="n">components</span><span class="p">[</span><span class="n">ind1</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="n">ind2</span><span class="p">])</span>
        <span class="k">return</span> <span class="nb">str</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Implements object extraction from indices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">change_names</span><span class="p">:</span>
            <span class="n">E</span> <span class="o">=</span> <span class="n">Mueller</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;_picked&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">E</span> <span class="o">=</span> <span class="n">Mueller</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="c1"># If the indices are 1D, act upon the matrix directly</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">slice</span><span class="p">))</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">E</span><span class="o">.</span><span class="n">from_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">index</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">index</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">E</span><span class="o">.</span><span class="n">from_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">index</span><span class="p">])</span>
        <span class="c1"># If not, act upon the components</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">components</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">components</span><span class="p">(</span><span class="n">out_number</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">):</span>
                <span class="n">components</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">components</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="n">index</span><span class="p">]</span>
            <span class="n">E</span><span class="o">.</span><span class="n">from_components</span><span class="p">(</span><span class="n">components</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">E</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Implements object inclusion from indices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check that data is a correct pypol object</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;Jones_matrix&#39;</span><span class="p">:</span>
            <span class="n">data2</span> <span class="o">=</span> <span class="n">Mueller</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">data2</span><span class="o">.</span><span class="n">from_Jones</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">data</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;Mueller&#39;</span><span class="p">:</span>
            <span class="n">data2</span> <span class="o">=</span> <span class="n">data</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;data is type </span><span class="si">{}</span><span class="s1"> instead of Jones_vector or Stokes.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">data</span><span class="o">.</span><span class="n">type</span><span class="p">))</span>
        <span class="c1"># Expand phase if required</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">global_phase</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">global_phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">if</span> <span class="n">data2</span><span class="o">.</span><span class="n">global_phase</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data2</span><span class="o">.</span><span class="n">global_phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="c1"># If the indices are 1D, act upon the matrix directly</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">data2</span><span class="o">.</span><span class="n">M</span><span class="p">)</span>
            <span class="c1"># Add global phase</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">global_phase</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">data2</span><span class="o">.</span><span class="n">global_phase</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">slice</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">data2</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">index</span><span class="o">.</span><span class="n">step</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">step</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">step</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">step</span>
                <span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">index</span><span class="o">.</span><span class="n">stop</span> <span class="o">-</span> <span class="n">index</span><span class="o">.</span><span class="n">start</span><span class="p">)</span> <span class="o">/</span> <span class="n">step</span><span class="p">)</span>
                <span class="n">data3</span> <span class="o">=</span> <span class="n">data2</span><span class="o">.</span><span class="n">stretch</span><span class="p">(</span><span class="n">length</span><span class="o">=</span><span class="n">N</span><span class="p">,</span> <span class="n">keep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">data3</span> <span class="o">=</span> <span class="n">data2</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">data3</span><span class="o">.</span><span class="n">M</span><span class="p">)</span>
            <span class="c1"># Add global phase</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">global_phase</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">data3</span><span class="o">.</span><span class="n">global_phase</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">index</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">data2</span><span class="o">.</span><span class="n">M</span>
        <span class="c1"># If not, act upon the components</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Extract phase and components</span>
            <span class="n">components</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">components</span><span class="p">(</span><span class="n">out_number</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">phase</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">global_phase</span><span class="p">(</span><span class="n">out_number</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">components_new</span> <span class="o">=</span> <span class="n">data2</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">components</span><span class="p">(</span><span class="n">out_number</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">):</span>
                <span class="n">components</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">components_new</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
            <span class="n">phase_new</span> <span class="o">=</span> <span class="n">data2</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">global_phase</span><span class="p">(</span><span class="n">out_number</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">phase</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">phase_new</span>
            <span class="c1"># Set the new values</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">from_components</span><span class="p">(</span><span class="n">components</span><span class="p">,</span> <span class="n">global_phase</span><span class="o">=</span><span class="n">phase</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Implements equality operation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Calculate the difference object</span>
            <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;Jones_matrix&#39;</span><span class="p">:</span>
                <span class="n">M2</span> <span class="o">=</span> <span class="n">Mueller</span><span class="p">()</span>
                <span class="n">M2</span><span class="o">.</span><span class="n">from_Jones</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">other</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;Mueller&#39;</span><span class="p">:</span>
                <span class="n">M2</span> <span class="o">=</span> <span class="n">other</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;other is </span><span class="si">{}</span><span class="s1"> instead of Jones_matrix or Mueller.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">other</span><span class="o">.</span><span class="n">type</span><span class="p">))</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;other is not a py_pol object&#39;</span><span class="p">)</span>
        <span class="c1"># Stretch if required</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">M2</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">M1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stretch</span><span class="p">(</span><span class="n">length</span><span class="o">=</span><span class="n">M2</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">keep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">M1</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="n">M1</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">M2</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">M2</span> <span class="o">=</span> <span class="n">M2</span><span class="o">.</span><span class="n">stretch</span><span class="p">(</span><span class="n">length</span><span class="o">=</span><span class="n">M1</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">keep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">take_shape</span><span class="p">((</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">))</span>
        <span class="c1"># Compare matrices</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">M1</span><span class="o">.</span><span class="n">M</span> <span class="o">-</span> <span class="n">M2</span><span class="o">.</span><span class="n">M</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">cond1</span> <span class="o">=</span> <span class="n">norm</span> <span class="o">&lt;</span> <span class="n">tol_default</span>
        <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cond1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">cond1</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>
        <span class="c1"># Compare phases</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">M1</span><span class="o">.</span><span class="n">global_phase</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">M1</span><span class="o">.</span><span class="n">global_phase</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">cond2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">phase1</span> <span class="o">=</span> <span class="n">M1</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">global_phase</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">phase2</span> <span class="o">=</span> <span class="n">M2</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">global_phase</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">cond2</span> <span class="o">=</span> <span class="n">phase1</span> <span class="o">==</span> <span class="n">phase2</span>
        <span class="c1"># Merge conditions</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">cond1</span> <span class="o">*</span> <span class="n">cond2</span>
        <span class="k">return</span> <span class="n">cond</span>

    <span class="c1">################</span>
    <span class="c1">## PROPERTIES</span>
    <span class="c1">################</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">global_phase</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_global_phase</span>

    <span class="nd">@global_phase</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">global_phase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">number_types</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_global_phase</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">elif</span> <span class="n">value</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_global_phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="o">*</span> <span class="n">value</span>
        <span class="k">elif</span> <span class="n">value</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Global phase has diffrent size (</span><span class="si">{}</span><span class="s2">) than object (</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_global_phase</span> <span class="o">=</span> <span class="n">value</span>

    <span class="c1">#####################</span>
    <span class="c1">## MANIPULATION</span>
    <span class="c1">#####################</span>


<div class="viewcode-block" id="Mueller.add_global_phase"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Mueller.add_global_phase">[docs]</a>    <span class="k">def</span> <span class="nf">add_global_phase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                         <span class="n">phase</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                         <span class="n">unknown_as_zero</span><span class="o">=</span><span class="n">unknown_phase</span><span class="p">,</span>
                         <span class="n">keep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Method that adds a phase to the Mueller object.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            phase (float or np.ndarray): Phase to be added to the Mueller object. Default: 0.</span>
<span class="sd">            unknown_as_zero (bool): If True, takes unknown phase as zero. Default: False.</span>
<span class="sd">            keep (bool): If True, self is not updated. Default: False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (Mueller): Recalculated Mueller object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Act differently if we want to keep self intact</span>
        <span class="k">if</span> <span class="n">keep</span><span class="p">:</span>
            <span class="n">new_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_obj</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="c1"># Prepare variables</span>
        <span class="n">phase</span><span class="p">,</span> <span class="n">new_obj</span><span class="p">,</span> <span class="n">new_shape</span> <span class="o">=</span> <span class="n">prepare_variables</span><span class="p">([</span><span class="n">phase</span><span class="p">],</span>
                                                      <span class="n">expand</span><span class="o">=</span><span class="p">[</span><span class="kc">True</span><span class="p">],</span>
                                                      <span class="n">obj</span><span class="o">=</span><span class="n">new_obj</span><span class="p">,</span>
                                                      <span class="n">give_shape</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">phase</span> <span class="o">=</span> <span class="n">phase</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="c1"># Add the phase</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">global_phase</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">unknown_as_zero</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">global_phase</span> <span class="o">=</span> <span class="n">phase</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">global_phase</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">global_phase</span> <span class="o">+</span> <span class="n">phase</span>
        <span class="c1"># End</span>
        <span class="n">new_obj</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">select_shape</span><span class="p">(</span><span class="n">new_obj</span><span class="p">,</span> <span class="n">new_shape</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_obj</span></div>

<div class="viewcode-block" id="Mueller.set_global_phase"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Mueller.set_global_phase">[docs]</a>    <span class="k">def</span> <span class="nf">set_global_phase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                         <span class="n">phase</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                         <span class="n">keep</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                         <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Method that sets the phase to the Mueller object.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            phase (float or np.ndarray): Phase to be added to the Mueller object. Default: 0.</span>
<span class="sd">            keep (bool): If True, self is not updated. Default: False.</span>
<span class="sd">            shape_like (float or numpy.ndarray): Use the shape of this array. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (Mueller): Recalculated Mueller object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Act differently if we want to keep self intact</span>
        <span class="k">if</span> <span class="n">keep</span><span class="p">:</span>
            <span class="n">new_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_obj</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="c1"># If None or Nan, skip some steps</span>
        <span class="k">if</span> <span class="n">phase</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">phase</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">phase</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Prepare variables</span>
            <span class="n">phase</span><span class="p">,</span> <span class="n">new_obj</span><span class="p">,</span> <span class="n">new_shape</span> <span class="o">=</span> <span class="n">prepare_variables</span><span class="p">([</span><span class="n">phase</span><span class="p">],</span>
                                                          <span class="n">expand</span><span class="o">=</span><span class="p">[</span><span class="kc">True</span><span class="p">],</span>
                                                          <span class="n">obj</span><span class="o">=</span><span class="n">new_obj</span><span class="p">,</span>
                                                          <span class="n">give_shape</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">phase</span> <span class="o">=</span> <span class="n">phase</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="n">new_obj</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">select_shape</span><span class="p">(</span><span class="n">new_obj</span><span class="p">,</span>
                                                       <span class="n">shape_var</span><span class="o">=</span><span class="n">new_shape</span><span class="p">,</span>
                                                       <span class="n">shape_fun</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                                       <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">global_phase</span> <span class="o">=</span> <span class="n">phase</span>
        <span class="c1"># End</span>
        <span class="k">return</span> <span class="n">new_obj</span></div>

<div class="viewcode-block" id="Mueller.remove_global_phase"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Mueller.remove_global_phase">[docs]</a>    <span class="k">def</span> <span class="nf">remove_global_phase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Method that removes the phase to the Mueller object.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            keep (bool): If True, self is not updated. Default: False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (Mueller): Recalculated Mueller object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Act differently if we want to keep self intact</span>
        <span class="k">if</span> <span class="n">keep</span><span class="p">:</span>
            <span class="n">new_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_obj</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="c1"># Set the phase</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">global_phase</span> <span class="o">=</span> <span class="n">default_phase</span>
        <span class="c1"># End</span>
        <span class="k">return</span> <span class="n">new_obj</span></div>

    <span class="c1"># @_actualize_</span>
<div class="viewcode-block" id="Mueller.rotate"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Mueller.rotate">[docs]</a>    <span class="k">def</span> <span class="nf">rotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">angle</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keep</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">change_name</span><span class="o">=</span><span class="n">change_names</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Rotates a Mueller matrix a certain angle</span>

<span class="sd">        M_rotated = R(-angle) * self.M * R(angle)</span>

<span class="sd">        Parameters:</span>
<span class="sd">            angle (float): angle of rotation in radians. Default: 0</span>
<span class="sd">            keep (bool): If True, the original element is not updated. Default: False.</span>
<span class="sd">            change_name (bool): If True and angle is of size 1, changes the object name adding @ XX deg, being XX the total rotation angle. Default: True.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (Mueller): Mueller object rotated</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">no_rotation</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Warning: Tried to rotate </span><span class="si">{}</span><span class="s1">, which must not be rotated.&#39;</span><span class="o">.</span>
                  <span class="nb">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Act differently if we want to keep self intact</span>
            <span class="k">if</span> <span class="n">keep</span><span class="p">:</span>
                <span class="n">new_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_obj</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="c1"># Prepare variables</span>
            <span class="n">angle</span><span class="p">,</span> <span class="n">new_obj</span><span class="p">,</span> <span class="n">new_shape</span> <span class="o">=</span> <span class="n">prepare_variables</span><span class="p">([</span><span class="n">angle</span><span class="p">],</span>
                                                          <span class="n">expand</span><span class="o">=</span><span class="p">[</span><span class="kc">True</span><span class="p">],</span>
                                                          <span class="n">obj</span><span class="o">=</span><span class="n">new_obj</span><span class="p">,</span>
                                                          <span class="n">give_shape</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># Calculate the rotation objects</span>
            <span class="n">Jneg</span><span class="p">,</span> <span class="n">Jpos</span> <span class="o">=</span> <span class="n">create_Mueller</span><span class="p">((</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="s1">&#39;+&#39;</span><span class="p">))</span>
            <span class="n">Jneg</span><span class="o">.</span><span class="n">from_matrix</span><span class="p">(</span><span class="n">rotation_matrix_Mueller</span><span class="p">(</span><span class="o">-</span><span class="n">angle</span><span class="p">))</span>
            <span class="n">Jpos</span><span class="o">.</span><span class="n">from_matrix</span><span class="p">(</span><span class="n">rotation_matrix_Mueller</span><span class="p">(</span><span class="n">angle</span><span class="p">))</span>
            <span class="c1"># Rotate</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">Jneg</span> <span class="o">*</span> <span class="p">(</span><span class="n">new_obj</span> <span class="o">*</span> <span class="n">Jpos</span><span class="p">)</span>
            <span class="n">new_obj</span><span class="o">.</span><span class="n">from_matrix</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">M</span><span class="p">)</span>
            <span class="c1"># Update name</span>
            <span class="k">if</span> <span class="n">change_name</span> <span class="ow">and</span> <span class="n">angle</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">tol_default</span><span class="p">:</span>
                    <span class="n">new_obj</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">new_obj</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> \
                        <span class="s2">&quot; @ </span><span class="si">{:1.2f}</span><span class="s2"> deg&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">angle</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">degrees</span><span class="p">)</span>
            <span class="c1"># Return</span>
            <span class="n">new_obj</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">select_shape</span><span class="p">(</span><span class="n">obj</span><span class="o">=</span><span class="n">new_obj</span><span class="p">,</span>
                                                       <span class="n">shape_var</span><span class="o">=</span><span class="n">new_shape</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">new_obj</span></div>

<div class="viewcode-block" id="Mueller.covariance_matrix"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Mueller.covariance_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">covariance_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                          <span class="n">keep</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                          <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">change_name</span><span class="o">=</span><span class="n">change_names</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the covariance matrix of a Mueller matrix.</span>

<span class="sd">        References:</span>
<span class="sd">            J.J. Gil, R. Ossikovsky &quot;Polarized light and the Mueller Matrix approach&quot;, CRC Press (2016) pp 171.</span>

<span class="sd">        Notes:</span>
<span class="sd">            The base of matrices S is used in an uncommon order.</span>
<span class="sd">            In order to obtain the same result as in the book, the formula must be:</span>

<span class="sd">            .. math:: H=0.25\sum(m[i,j]\,kron([S(i),S^{*}(j))].</span>

<span class="sd">        Parameters:</span>
<span class="sd">            keep (bool): If True, the original element is not updated. Default: False.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>
<span class="sd">            change_name (bool): If True, changes the object name adding Recip. of at the beggining of the name. Default: True.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (Mueller): Modified object.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Act differently if we want to keep self intact</span>
        <span class="k">if</span> <span class="n">keep</span><span class="p">:</span>
            <span class="n">new_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_obj</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="c1"># Calculate components</span>
        <span class="n">components</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">components</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">out_number</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># Calculate the covariance matrices</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">new_obj</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">):</span>
            <span class="n">H</span> <span class="o">=</span> <span class="n">H</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">S_kron</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span> <span class="n">components</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span>
        <span class="n">new_obj</span><span class="o">.</span><span class="n">from_matrix</span><span class="p">(</span><span class="n">H</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span>
        <span class="n">new_obj</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">select_shape</span><span class="p">(</span><span class="n">shape_var</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                                                   <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span>
                                                   <span class="n">shape_fun</span><span class="o">=</span><span class="n">shape</span><span class="p">)</span>
        <span class="c1"># Fix the name if required</span>
        <span class="k">if</span> <span class="n">change_name</span><span class="p">:</span>
            <span class="n">new_obj</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Covariant of &#39;</span> <span class="o">+</span> <span class="n">new_obj</span><span class="o">.</span><span class="n">name</span>
        <span class="k">return</span> <span class="n">new_obj</span></div>

<div class="viewcode-block" id="Mueller.inverse"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Mueller.inverse">[docs]</a>    <span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                <span class="n">keep</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">change_name</span><span class="o">=</span><span class="n">change_names</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the inverse matrix of the Mueller matrix.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            keep (bool): If True, the original element is not updated. Default: False.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>
<span class="sd">            change_name (bool): If True, changes the object name adding Recip. of at the beggining of the name. Default: True.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (Mueller): Modified object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Act differently if we want to keep self intact</span>
        <span class="k">if</span> <span class="n">keep</span><span class="p">:</span>
            <span class="n">new_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_obj</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="c1"># Caluclate inverse</span>
        <span class="n">new_obj</span><span class="o">.</span><span class="n">from_matrix</span><span class="p">(</span><span class="n">inv_pypol</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">),</span>
                            <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span>
                            <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">new_obj</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">select_shape</span><span class="p">(</span><span class="n">shape_var</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                                                   <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span>
                                                   <span class="n">shape_fun</span><span class="o">=</span><span class="n">shape</span><span class="p">)</span>
        <span class="c1"># Fix the name if required</span>
        <span class="k">if</span> <span class="n">change_name</span><span class="p">:</span>
            <span class="n">new_obj</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Inverse of &#39;</span> <span class="o">+</span> <span class="n">new_obj</span><span class="o">.</span><span class="n">name</span>
        <span class="k">return</span> <span class="n">new_obj</span></div>

    <span class="c1"># @_actualize_</span>
<div class="viewcode-block" id="Mueller.reciprocal"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Mueller.reciprocal">[docs]</a>    <span class="k">def</span> <span class="nf">reciprocal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                   <span class="n">keep</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                   <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">change_name</span><span class="o">=</span><span class="n">change_names</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the reciprocal of the optical element, so the light tranverses it in the opposite direction. In Mueller formalism, it is calculated as:</span>

<span class="sd">        .. math:: M^{r}=\left[\begin{array}{cccc}</span>
<span class="sd">                    1 &amp; 0 &amp; 0 &amp; 0\\</span>
<span class="sd">                    0 &amp; 1 &amp; 0 &amp; 0\\</span>
<span class="sd">                    0 &amp; 0 &amp; -1 &amp; 0\\</span>
<span class="sd">                    0 &amp; 0 &amp; 0 &amp; 1</span>
<span class="sd">                    \end{array}\right]M^{T}\left[\begin{array}{cccc}</span>
<span class="sd">                    1 &amp; 0 &amp; 0 &amp; 0\\</span>
<span class="sd">                    0 &amp; 1 &amp; 0 &amp; 0\\</span>
<span class="sd">                    0 &amp; 0 &amp; -1 &amp; 0\\</span>
<span class="sd">                    0 &amp; 0 &amp; 0 &amp; 1</span>
<span class="sd">                    \end{array}\right]</span>

<span class="sd">        References:</span>
<span class="sd">            J.J. Gil, R. Ossikovsky &quot;Polarized light and the Mueller Matrix approach&quot;, CRC Press (2016), pp 111.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            keep (bool): If True, the original element is not updated. Default: False.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>
<span class="sd">            change_name (bool): If True, changes the object name adding Recip. of at the beggining of the name. Default: True.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (Mueller): Result.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Act differently if we want to keep self intact</span>
        <span class="k">if</span> <span class="n">keep</span><span class="p">:</span>
            <span class="n">new_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_obj</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="c1"># Calculate components</span>
        <span class="n">components</span> <span class="o">=</span> <span class="n">new_obj</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">components</span><span class="p">(</span>
            <span class="n">shape</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">components</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">components</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">components</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">components</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>
        <span class="n">components</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">components</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span>
        <span class="n">components</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">components</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span>
        <span class="n">components</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">components</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span>
        <span class="n">components</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">components</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span>
        <span class="c1"># Create the object</span>
        <span class="n">new_obj</span><span class="o">.</span><span class="n">from_components</span><span class="p">(</span><span class="n">components</span><span class="p">)</span>
        <span class="n">new_obj</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">select_shape</span><span class="p">(</span><span class="n">shape_var</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                                                   <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span>
                                                   <span class="n">shape_fun</span><span class="o">=</span><span class="n">shape</span><span class="p">)</span>
        <span class="c1"># Fix the name if required</span>
        <span class="k">if</span> <span class="n">change_name</span><span class="p">:</span>
            <span class="n">new_obj</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Reciprocal of &#39;</span> <span class="o">+</span> <span class="n">new_obj</span><span class="o">.</span><span class="n">name</span>
        <span class="k">return</span> <span class="n">new_obj</span></div>

<div class="viewcode-block" id="Mueller.transpose"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Mueller.transpose">[docs]</a>    <span class="k">def</span> <span class="nf">transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                  <span class="n">keep</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                  <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">change_name</span><span class="o">=</span><span class="n">change_names</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the transposed matrices of the Mueller matrices.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            keep (bool): If True, the original element is not updated. Default: False.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>
<span class="sd">            change_name (bool): If True, changes the object name adding Recip. of at the beggining of the name. Default: True.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (Jones_matrix): Modified object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Act differently if we want to keep self intact</span>
        <span class="k">if</span> <span class="n">keep</span><span class="p">:</span>
            <span class="n">new_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_obj</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="c1"># Caluclate inverse</span>
        <span class="n">new_obj</span><span class="o">.</span><span class="n">from_matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">new_obj</span><span class="o">.</span><span class="n">M</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span>
        <span class="n">new_obj</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">select_shape</span><span class="p">(</span><span class="n">shape_var</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                                                   <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span>
                                                   <span class="n">shape_fun</span><span class="o">=</span><span class="n">shape</span><span class="p">)</span>
        <span class="c1"># Fix the name if required</span>
        <span class="k">if</span> <span class="n">change_name</span><span class="p">:</span>
            <span class="n">new_obj</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Transpose of &#39;</span> <span class="o">+</span> <span class="n">new_obj</span><span class="o">.</span><span class="n">name</span>
        <span class="k">return</span> <span class="n">new_obj</span></div>

<div class="viewcode-block" id="Mueller.sum"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Mueller.sum">[docs]</a>    <span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keep</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">change_name</span><span class="o">=</span><span class="n">change_names</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the sum of Mueller matrices stored in the object.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            axis (int, list or tuple): Axes along which the summatory is performed. If None, all matrices are summed. Default: None</span>
<span class="sd">            keep (bool): If True, the original element is not updated. Default: False.</span>
<span class="sd">            change_name (bool): If True, changes the object name adding Recip. of at the beggining of the name. Default: True.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (Mueller): Modified object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Act differently if we want to keep self intact</span>
        <span class="k">if</span> <span class="n">keep</span><span class="p">:</span>
            <span class="n">new_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_obj</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="c1"># Simple case</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">new_obj</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">new_obj</span><span class="o">.</span><span class="n">M</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="c1"># Complicated case</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Calculate maximum axis</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span> <span class="o">+</span> <span class="mi">2</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">axis</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
            <span class="c1"># Check that the axes are correct</span>
            <span class="k">if</span> <span class="n">m</span> <span class="o">&gt;=</span> <span class="n">new_obj</span><span class="o">.</span><span class="n">ndim</span> <span class="o">+</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;Axis </span><span class="si">{}</span><span class="s1"> greater than the number of dimensions of </span><span class="si">{}</span><span class="s1">, which is </span><span class="si">{}</span><span class="s1">&#39;</span>
                    <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">new_obj</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">new_obj</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
            <span class="c1"># Reshape M to fit the current shape</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="n">new_obj</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">new_obj</span><span class="o">.</span><span class="n">M</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>
            <span class="c1"># check if the axis is int or not</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">axis</span><span class="p">))</span>
        <span class="c1"># Create the object and return it</span>
        <span class="n">new_obj</span><span class="o">.</span><span class="n">from_matrix</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">change_names</span><span class="p">:</span>
            <span class="n">new_obj</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Sum of &#39;</span> <span class="o">+</span> <span class="n">new_obj</span><span class="o">.</span><span class="n">name</span>
        <span class="k">return</span> <span class="n">new_obj</span></div>

<div class="viewcode-block" id="Mueller.prod"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Mueller.prod">[docs]</a>    <span class="k">def</span> <span class="nf">prod</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keep</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">change_name</span><span class="o">=</span><span class="n">change_names</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the product of Mueller matrices stored in the object.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            axis (int, list or tuple): Axes along which the product is performed. If None, all matrices are multiplied. Default: None</span>
<span class="sd">            keep (bool): If True, the original element is not updated. Default: False.</span>
<span class="sd">            change_name (bool): If True, changes the object name adding Recip. of at the beggining of the name. Default: True.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (Mueller): Modified object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Act differently if we want to keep self intact</span>
        <span class="k">if</span> <span class="n">keep</span><span class="p">:</span>
            <span class="n">new_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_obj</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="c1"># Simple case</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">N_axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span><span class="o">.</span><span class="n">size</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">new_obj</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">new_obj</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="n">N_axis</span><span class="p">:</span>
            <span class="n">M</span> <span class="o">=</span> <span class="n">new_obj</span><span class="o">.</span><span class="n">M</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">new_obj</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                <span class="n">M</span> <span class="o">=</span> <span class="n">M</span> <span class="o">@</span> <span class="n">new_obj</span><span class="o">.</span><span class="n">M</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">ind</span><span class="p">]</span>
        <span class="c1"># Complicated case</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Calculate maximum axis</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">axis</span> <span class="o">+</span> <span class="mi">2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span>
            <span class="c1"># Check that the axes are correct</span>
            <span class="k">if</span> <span class="n">m</span> <span class="o">&gt;=</span> <span class="n">new_obj</span><span class="o">.</span><span class="n">ndim</span> <span class="o">+</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;Axis </span><span class="si">{}</span><span class="s1"> greater than the number of dimensions of </span><span class="si">{}</span><span class="s1">, which is </span><span class="si">{}</span><span class="s1">&#39;</span>
                    <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">new_obj</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">new_obj</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
            <span class="c1"># Calculate shapes, sizes and indices</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">shape_removed</span> <span class="o">=</span> <span class="n">new_obj</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">shape_removed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_obj</span><span class="o">.</span><span class="n">shape</span><span class="p">)[</span><span class="n">axis</span><span class="p">]</span>
            <span class="n">N_removed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">shape_removed</span><span class="p">)</span>
            <span class="n">ind_removed</span> <span class="o">=</span> <span class="n">combine_indices</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">N_removed</span><span class="p">)),</span> <span class="n">shape_removed</span><span class="p">))</span>
            <span class="n">shape_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">new_obj</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
            <span class="n">N_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">shape_matrix</span><span class="p">)</span>
            <span class="n">ind_matrix</span> <span class="o">=</span> <span class="n">combine_indices</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">N_matrix</span><span class="p">)),</span> <span class="n">shape_matrix</span><span class="p">))</span>
            <span class="n">shape_final</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">shape_matrix</span><span class="p">)</span>
            <span class="n">axes_aux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">new_obj</span><span class="o">.</span><span class="n">ndim</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span>
            <span class="n">shape_orig</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">new_obj</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="c1"># Make the for loop of the matrix to be calculated</span>
            <span class="n">M_orig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">new_obj</span><span class="o">.</span><span class="n">M</span><span class="p">,</span> <span class="n">shape_orig</span><span class="p">)</span>
            <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape_final</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">indM</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_matrix</span><span class="p">):</span>
                <span class="c1"># Make the multiplication loop</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">merge_indices</span><span class="p">(</span><span class="n">ind_matrix</span><span class="p">[</span><span class="n">indM</span><span class="p">],</span> <span class="n">ind_removed</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="p">)</span>
                <span class="n">aux</span> <span class="o">=</span> <span class="n">multitake</span><span class="p">(</span><span class="n">M_orig</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">axes_aux</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">indR</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N_removed</span><span class="p">):</span>
                    <span class="n">indices</span> <span class="o">=</span> <span class="n">merge_indices</span><span class="p">(</span><span class="n">ind_matrix</span><span class="p">[</span><span class="n">indM</span><span class="p">],</span>
                                            <span class="n">ind_removed</span><span class="p">[</span><span class="n">indR</span><span class="p">],</span> <span class="n">axis</span><span class="p">)</span>
                    <span class="n">aux</span> <span class="o">=</span> <span class="n">aux</span> <span class="o">@</span> <span class="n">multitake</span><span class="p">(</span><span class="n">M_orig</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">axes_aux</span><span class="p">)</span>
                <span class="c1"># Store the result</span>
                <span class="k">for</span> <span class="n">i1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">i2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
                        <span class="n">ind_aux</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">ind_matrix</span><span class="p">[</span><span class="n">indM</span><span class="p">]))</span>
                        <span class="n">M</span><span class="p">[</span><span class="n">ind_aux</span><span class="p">]</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">]</span>
        <span class="c1"># Create the object and return it</span>
        <span class="n">new_obj</span><span class="o">.</span><span class="n">from_matrix</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">change_names</span><span class="p">:</span>
            <span class="n">new_obj</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Prod of &#39;</span> <span class="o">+</span> <span class="n">new_obj</span><span class="o">.</span><span class="n">name</span>
        <span class="k">return</span> <span class="n">new_obj</span></div>



    <span class="c1">####################################################################</span>
    <span class="c1"># Creation</span>
    <span class="c1">####################################################################</span>

<div class="viewcode-block" id="Mueller.from_components"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Mueller.from_components">[docs]</a>    <span class="k">def</span> <span class="nf">from_components</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                        <span class="n">components</span><span class="p">,</span>
                        <span class="n">global_phase</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                        <span class="n">length</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                        <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates the Mueller matrix object form the arrays of its 16 components components.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            components (tuple or list): A 4 element tuple containing the 6 components of the Mueller matrices (M00, M01, ..., M32, M33).</span>
<span class="sd">            global_phase (float or numpy.ndarray): Adds a global phase to the object. Default: 0.</span>
<span class="sd">            length (int): If final object is of size 1, it is stretched to match this size. Default: 1.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (Mueller_matrix): Created object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Prepare variables</span>
        <span class="n">components</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">components</span><span class="p">)</span>
        <span class="n">components</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">global_phase</span><span class="p">)</span>
        <span class="n">expand</span> <span class="o">=</span> <span class="mi">16</span> <span class="o">*</span> <span class="p">[</span><span class="kc">True</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span>
        <span class="p">(</span><span class="n">components</span><span class="p">),</span> <span class="n">new_shape</span> <span class="o">=</span> <span class="n">prepare_variables</span><span class="p">(</span><span class="nb">vars</span><span class="o">=</span><span class="n">components</span><span class="p">,</span>
                                                    <span class="n">expand</span><span class="o">=</span><span class="n">expand</span><span class="p">,</span>
                                                    <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">,</span>
                                                    <span class="n">give_shape</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># Create the matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[[</span><span class="n">components</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">components</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">components</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">components</span><span class="p">[</span><span class="mi">3</span><span class="p">]],</span>
             <span class="p">[</span><span class="n">components</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">components</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">components</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="n">components</span><span class="p">[</span><span class="mi">7</span><span class="p">]],</span>
             <span class="p">[</span><span class="n">components</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span> <span class="n">components</span><span class="p">[</span><span class="mi">9</span><span class="p">],</span> <span class="n">components</span><span class="p">[</span><span class="mi">10</span><span class="p">],</span> <span class="n">components</span><span class="p">[</span><span class="mi">11</span><span class="p">]],</span>
             <span class="p">[</span><span class="n">components</span><span class="p">[</span><span class="mi">12</span><span class="p">],</span> <span class="n">components</span><span class="p">[</span><span class="mi">13</span><span class="p">],</span> <span class="n">components</span><span class="p">[</span><span class="mi">14</span><span class="p">],</span> <span class="n">components</span><span class="p">[</span><span class="mi">15</span><span class="p">]]])</span>
        <span class="c1"># Rest of operations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">no_rotation</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># self.size = components[0].size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">select_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                             <span class="n">shape_var</span><span class="o">=</span><span class="n">new_shape</span><span class="p">,</span>
                                             <span class="n">shape_fun</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                             <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_global_phase</span><span class="p">(</span><span class="n">phase</span><span class="o">=</span><span class="n">global_phase</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">no_rotation</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Mueller.from_matrix"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Mueller.from_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">from_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                    <span class="n">M</span><span class="p">,</span>
                    <span class="n">global_phase</span><span class="o">=</span><span class="n">default_phase</span><span class="p">,</span>
                    <span class="n">length</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                    <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a Mueller object from an external array.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            M (numpy.ndarray): New matrix. At least two dimensions must be of size 4.</span>
<span class="sd">            global_phase (numpy.ndarray): Adds a global phase to the Stokes object. Default: 0.</span>
<span class="sd">            length (int): If final object is of size 1, it is stretched to match this size. Default: 1.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (Mueller): Created object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check if the matrix is of the correct Size</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">size</span>
        <span class="c1"># 1D and 2D</span>
        <span class="k">if</span> <span class="n">M</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">M</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">M</span><span class="o">.</span><span class="n">size</span> <span class="o">%</span> <span class="mi">16</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">size</span> <span class="o">/</span> <span class="mi">16</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;M must have a number of elements multiple of 16.&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">M</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">16</span><span class="p">:</span>
                <span class="n">sh</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sh</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">size</span> <span class="o">/</span> <span class="mi">16</span><span class="p">)]</span>
        <span class="c1"># 3D or more</span>
        <span class="k">elif</span> <span class="n">M</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">sh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sh</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">N</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Find the matrix indices and the final shape</span>
                <span class="n">ind1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="n">sh</span> <span class="o">==</span> <span class="mi">4</span><span class="p">))</span>
                <span class="n">sh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">sh</span><span class="p">,</span> <span class="n">ind1</span><span class="p">)</span>
                <span class="n">ind2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="n">sh</span> <span class="o">==</span> <span class="mi">4</span><span class="p">))</span>
                <span class="n">sh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">sh</span><span class="p">,</span> <span class="n">ind2</span><span class="p">)</span>
                <span class="n">ind2</span> <span class="o">=</span> <span class="n">ind2</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="c1"># Calculate the components and construct the matrix from them</span>
                <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span>
                    <span class="n">multitake</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="n">ind1</span><span class="p">,</span> <span class="n">ind2</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span>
                    <span class="n">multitake</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="n">ind1</span><span class="p">,</span> <span class="n">ind2</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span>
                    <span class="n">multitake</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="n">ind1</span><span class="p">,</span> <span class="n">ind2</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span>
                    <span class="n">multitake</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="n">ind1</span><span class="p">,</span> <span class="n">ind2</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                <span class="p">],</span>
                              <span class="p">[</span>
                                  <span class="n">multitake</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="n">ind1</span><span class="p">,</span> <span class="n">ind2</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span>
                                  <span class="n">multitake</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="n">ind1</span><span class="p">,</span> <span class="n">ind2</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span>
                                  <span class="n">multitake</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="n">ind1</span><span class="p">,</span> <span class="n">ind2</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span>
                                  <span class="n">multitake</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="n">ind1</span><span class="p">,</span> <span class="n">ind2</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                              <span class="p">],</span>
                              <span class="p">[</span>
                                  <span class="n">multitake</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="n">ind1</span><span class="p">,</span> <span class="n">ind2</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span>
                                  <span class="n">multitake</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="n">ind1</span><span class="p">,</span> <span class="n">ind2</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span>
                                  <span class="n">multitake</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="n">ind1</span><span class="p">,</span> <span class="n">ind2</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span>
                                  <span class="n">multitake</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="n">ind1</span><span class="p">,</span> <span class="n">ind2</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                              <span class="p">],</span>
                              <span class="p">[</span>
                                  <span class="n">multitake</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="n">ind1</span><span class="p">,</span> <span class="n">ind2</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span>
                                  <span class="n">multitake</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="n">ind1</span><span class="p">,</span> <span class="n">ind2</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span>
                                  <span class="n">multitake</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="n">ind1</span><span class="p">,</span> <span class="n">ind2</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span>
                                  <span class="n">multitake</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="n">ind1</span><span class="p">,</span> <span class="n">ind2</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                              <span class="p">]])</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;M must have four elements in at least two dimensions. Instead, it has shape = </span><span class="si">{}</span><span class="s1">&#39;</span>
                    <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;M can not be empty&#39;</span><span class="p">)</span>

        <span class="c1"># Increase length if required</span>
        <span class="k">if</span> <span class="n">M</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">16</span> <span class="ow">and</span> <span class="n">length</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">M</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">length</span><span class="p">))</span>
        <span class="c1"># End operations</span>
        <span class="c1"># self.size = int(M.size / 16)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">M</span> <span class="o">=</span> <span class="n">M</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">no_rotation</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">select_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                             <span class="n">shape_var</span><span class="o">=</span><span class="n">sh</span><span class="p">,</span>
                                             <span class="n">shape_fun</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                             <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_global_phase</span><span class="p">(</span><span class="n">phase</span><span class="o">=</span><span class="n">global_phase</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Mueller.from_normalized"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Mueller.from_normalized">[docs]</a>    <span class="k">def</span> <span class="nf">from_normalized</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                        <span class="n">m</span><span class="p">,</span>
                        <span class="n">M00</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">global_phase</span><span class="o">=</span><span class="n">default_phase</span><span class="p">,</span>
                        <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates a Mueller object directly from the normalized matrix $m = M/M_{00}$, and $M_{00}$.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            m (4x4 numpy.matrix): Mueller matrix</span>
<span class="sd">            M00 (float): [0, 1] Mean transmission coefficient. Default: maximum possible (None).</span>
<span class="sd">            global_phase (numpy.ndarray): Adds a global phase to the Stokes object. Default: 0.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (Mueller): Created object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Easy case, M00 is a number</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">M00</span><span class="p">)</span> <span class="ow">in</span> <span class="n">number_types</span><span class="p">:</span>
            <span class="n">M</span> <span class="o">=</span> <span class="n">m</span> <span class="o">*</span> <span class="n">M00</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">from_matrix</span><span class="p">(</span><span class="n">M</span><span class="p">,</span>
                             <span class="n">global_phase</span><span class="o">=</span><span class="n">global_phase</span><span class="p">,</span>
                             <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                             <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>
        <span class="c1"># Complicated case, M00 is an array</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Check that the variables can be used</span>
            <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">16</span> <span class="ow">and</span> <span class="n">m</span><span class="o">.</span><span class="n">size</span> <span class="o">/</span> <span class="mi">16</span> <span class="o">!=</span> <span class="n">M00</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;M00 of </span><span class="si">{}</span><span class="s1"> elements is incompatible with m of </span><span class="si">{}</span><span class="s1"> elements&#39;</span><span class="o">.</span>
                    <span class="nb">format</span><span class="p">(</span><span class="n">M00</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">size</span> <span class="o">/</span> <span class="mi">16</span><span class="p">))</span>
            <span class="c1"># Create the object as if the matrix were not normalized</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">from_matrix</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">components</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">components</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="c1"># Denormalize</span>
            <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">):</span>
                <span class="n">components</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">components</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">*</span> <span class="n">M00</span>
            <span class="c1"># Create the correct object</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">from_components</span><span class="p">(</span><span class="n">components</span><span class="p">,</span>
                                 <span class="n">global_phase</span><span class="o">=</span><span class="n">global_phase</span><span class="p">,</span>
                                 <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                 <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Mueller.from_blocks"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Mueller.from_blocks">[docs]</a>    <span class="k">def</span> <span class="nf">from_blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                    <span class="n">Dv</span><span class="o">=</span><span class="n">zero_D</span><span class="p">,</span>
                    <span class="n">Pv</span><span class="o">=</span><span class="n">zero_D</span><span class="p">,</span>
                    <span class="n">m</span><span class="o">=</span><span class="n">zero_m</span><span class="p">,</span>
                    <span class="n">M00</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                    <span class="n">global_phase</span><span class="o">=</span><span class="n">default_phase</span><span class="p">,</span>
                    <span class="n">length</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                    <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Method that creates a Mueller object from the block components of its matrix.</span>

<span class="sd">        References:</span>
<span class="sd">            J.J. Gil, R. Ossikovsky &quot;Polarized light and the Mueller Matrix approach&quot;, CRC Press (2016)</span>

<span class="sd">        Parameters:</span>
<span class="sd">            Dv (numpy.ndarray): Diattenuation vector 3xN array.</span>
<span class="sd">            Pv (numpy.ndarray): Polarizance vector 3xN array.</span>
<span class="sd">            m (numpy.ndarray): Small matrix m 3x3xN array.</span>
<span class="sd">            M00 (numpy.ndarray): Parameter of average intensity array of size N. Default: 1</span>
<span class="sd">            global_phase (numpy.ndarray): Adds a global phase to the Stokes object. Default: 0.</span>
<span class="sd">            length (int): If final object is of size 1, it is stretched to match this size. Default: 1.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (Mueller): Created object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Prepare the variables</span>
        <span class="n">M00</span><span class="p">,</span> <span class="n">Dv</span><span class="p">,</span> <span class="n">Pv</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">new_shape</span> <span class="o">=</span> <span class="n">prepare_variables_blocks</span><span class="p">(</span>
            <span class="n">M00</span><span class="p">,</span>
            <span class="n">Dv</span><span class="p">,</span>
            <span class="n">Pv</span><span class="p">,</span>
            <span class="n">m</span><span class="p">,</span>
            <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">,</span>
            <span class="n">give_shape</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">multiply_by_M00</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># Build the object</span>
        <span class="n">components</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">M00</span><span class="p">,</span> <span class="n">Dv</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">],</span> <span class="n">Dv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">Dv</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">Pv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
            <span class="n">Pv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">Pv</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
        <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">from_components</span><span class="p">(</span><span class="n">components</span><span class="p">,</span> <span class="n">global_phase</span><span class="o">=</span><span class="n">global_phase</span><span class="p">)</span>
        <span class="c1"># Update object parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">select_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                             <span class="n">shape_var</span><span class="o">=</span><span class="n">new_shape</span><span class="p">,</span>
                                             <span class="n">shape_fun</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                             <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>
        <span class="c1"># self.M00, self.D, self.P, self.m = (M00, D, P, m)</span>
        <span class="k">return</span> <span class="bp">self</span></div>


    <span class="c1"># @_actualize_</span>
<div class="viewcode-block" id="Mueller.from_Jones"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Mueller.from_Jones">[docs]</a>    <span class="k">def</span> <span class="nf">from_Jones</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Takes a Jones Matrix and converts into Mueller Matrix</span>

<span class="sd">        .. math:: M(J)=\left[\begin{array}{cccc}</span>
<span class="sd">                    1 &amp; 0 &amp; 0 &amp; 1\\</span>
<span class="sd">                    1 &amp; 0 &amp; 0 &amp; -1\\</span>
<span class="sd">                    0 &amp; 1 &amp; 1 &amp; 0\\</span>
<span class="sd">                    0 &amp; i &amp; -i &amp; 0</span>
<span class="sd">                    \end{array}\right]\left(J\otimes J^{*}\right)\left[\begin{array}{cccc}</span>
<span class="sd">                    1 &amp; 0 &amp; 0 &amp; 1\\</span>
<span class="sd">                    1 &amp; 0 &amp; 0 &amp; -1\\</span>
<span class="sd">                    0 &amp; 1 &amp; 1 &amp; 0\\</span>
<span class="sd">                    0 &amp; i &amp; -i &amp; 0</span>
<span class="sd">                    \end{array}\right]^{-1}</span>

<span class="sd">        References:</span>
<span class="sd">            &quot;Polarized light and the Mueller Matrix approach&quot;, 2nd Ed., J. J. Gil and E. Ossikowski, pp 107.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            J (Jones_matrix): Jones matrix object.</span>
<span class="sd">            length (int): If final object is of size 1, it is stretched to match this size. Default: 1.</span>
<span class="sd">            shape_like (float or numpy.ndarray): Use the shape of this array. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (Mueller): Created object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Extract components from the Jones object and derivatives</span>
        <span class="n">J00</span><span class="p">,</span> <span class="n">J01</span><span class="p">,</span> <span class="n">J10</span><span class="p">,</span> <span class="n">J11</span> <span class="o">=</span> <span class="n">J</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">components</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">J00m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">J00</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">J01m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">J01</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">J10m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">J10</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">J11m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">J11</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">J00c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">J00</span><span class="p">)</span>
        <span class="n">J01c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">J01</span><span class="p">)</span>
        <span class="n">J10c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">J10</span><span class="p">)</span>
        <span class="n">J11c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">J11</span><span class="p">)</span>
        <span class="c1"># Create the components of the Mueller object</span>
        <span class="n">components</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">16</span>
        <span class="n">components</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">J00m</span> <span class="o">+</span> <span class="n">J01m</span> <span class="o">+</span> <span class="n">J10m</span> <span class="o">+</span> <span class="n">J11m</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">components</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">J00m</span> <span class="o">-</span> <span class="n">J01m</span> <span class="o">+</span> <span class="n">J10m</span> <span class="o">-</span> <span class="n">J11m</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">components</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">J00</span> <span class="o">*</span> <span class="n">J01c</span> <span class="o">+</span> <span class="n">J10</span> <span class="o">*</span> <span class="n">J11c</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>
        <span class="n">components</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">J00</span> <span class="o">*</span> <span class="n">J01c</span> <span class="o">+</span> <span class="n">J10</span> <span class="o">*</span> <span class="n">J11c</span><span class="p">)</span><span class="o">.</span><span class="n">imag</span>
        <span class="n">components</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">J00m</span> <span class="o">+</span> <span class="n">J01m</span> <span class="o">-</span> <span class="n">J10m</span> <span class="o">-</span> <span class="n">J11m</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">components</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">J00m</span> <span class="o">-</span> <span class="n">J01m</span> <span class="o">-</span> <span class="n">J10m</span> <span class="o">+</span> <span class="n">J11m</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">components</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">J00</span> <span class="o">*</span> <span class="n">J01c</span> <span class="o">-</span> <span class="n">J10</span> <span class="o">*</span> <span class="n">J11c</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>
        <span class="n">components</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">J00</span> <span class="o">*</span> <span class="n">J01c</span> <span class="o">+</span> <span class="n">J10c</span> <span class="o">*</span> <span class="n">J11</span><span class="p">)</span><span class="o">.</span><span class="n">imag</span>
        <span class="n">components</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">J00</span> <span class="o">*</span> <span class="n">J10c</span> <span class="o">+</span> <span class="n">J01</span> <span class="o">*</span> <span class="n">J11c</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>
        <span class="n">components</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">J00</span> <span class="o">*</span> <span class="n">J10c</span> <span class="o">-</span> <span class="n">J01</span> <span class="o">*</span> <span class="n">J11c</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>
        <span class="n">components</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">J00</span> <span class="o">*</span> <span class="n">J11c</span> <span class="o">+</span> <span class="n">J01</span> <span class="o">*</span> <span class="n">J10c</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>
        <span class="n">components</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">J10</span> <span class="o">*</span> <span class="n">J01c</span> <span class="o">+</span> <span class="n">J11c</span> <span class="o">*</span> <span class="n">J00</span><span class="p">)</span><span class="o">.</span><span class="n">imag</span>
        <span class="n">components</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">J10</span> <span class="o">*</span> <span class="n">J00c</span> <span class="o">+</span> <span class="n">J01c</span> <span class="o">*</span> <span class="n">J11</span><span class="p">)</span><span class="o">.</span><span class="n">imag</span>
        <span class="n">components</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">J10</span> <span class="o">*</span> <span class="n">J00c</span> <span class="o">+</span> <span class="n">J11c</span> <span class="o">*</span> <span class="n">J01</span><span class="p">)</span><span class="o">.</span><span class="n">imag</span>
        <span class="n">components</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">J11</span> <span class="o">*</span> <span class="n">J00c</span> <span class="o">+</span> <span class="n">J01c</span> <span class="o">*</span> <span class="n">J10</span><span class="p">)</span><span class="o">.</span><span class="n">imag</span>
        <span class="n">components</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">J00</span> <span class="o">*</span> <span class="n">J11c</span> <span class="o">-</span> <span class="n">J01</span> <span class="o">*</span> <span class="n">J10c</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>
        <span class="n">phase</span> <span class="o">=</span> <span class="n">J</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">global_phase</span><span class="p">()</span>
        <span class="c1"># Create the object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">from_components</span><span class="p">(</span><span class="n">components</span><span class="p">,</span>
                             <span class="n">global_phase</span><span class="o">=</span><span class="n">phase</span><span class="p">,</span>
                             <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">,</span>
                             <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                             <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="c1"># @_actualize_</span>
<div class="viewcode-block" id="Mueller.from_covariance"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Mueller.from_covariance">[docs]</a>    <span class="k">def</span> <span class="nf">from_covariance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                        <span class="n">H</span><span class="p">,</span>
                        <span class="n">global_phase</span><span class="o">=</span><span class="n">default_phase</span><span class="p">,</span>
                        <span class="n">length</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                        <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the Mueller matrix from the covariance matrix:</span>

<span class="sd">        $M_{ij}=Trace\left[\left(\sigma_{i}\otimes\sigma_{j}^{*}\right)H\right]$</span>

<span class="sd">        References:</span>
<span class="sd">            J.J. Gil, R. Ossikovsky &quot;Polarized light and the Mueller Matrix approach&quot;, CRC Press (2016)</span>

<span class="sd">        Parameters:</span>
<span class="sd">            H (Mueller or numpy.ndarray): Covariance matrix.</span>
<span class="sd">            global_phase (numpy.ndarray): Adds a global phase to the Stokes object. Default: 0.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (Mueller): Created object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check if H is a py_pol object or an array</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">Mueller</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">from_matrix</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">H</span>
        <span class="n">old_shape</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Initialize the matrix</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="c1"># Loop in elements</span>
        <span class="n">components</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">elem</span> <span class="o">=</span> <span class="n">Mueller</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">indI</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">indJ</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
                <span class="c1"># Calculate the Sij matrix</span>
                <span class="n">Sij</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">indI</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">indJ</span><span class="p">])),</span>
                                        <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
                <span class="n">elem</span><span class="o">.</span><span class="n">from_matrix</span><span class="p">(</span><span class="n">Sij</span><span class="p">)</span>
                <span class="c1"># Multiply it by H</span>
                <span class="n">elem</span> <span class="o">=</span> <span class="n">elem</span> <span class="o">*</span> <span class="n">obj</span>
                <span class="c1"># Save the trace as the new component</span>
                <span class="n">components</span> <span class="o">+=</span> <span class="p">[</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">elem</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
                <span class="p">]</span>
        <span class="c1"># Create the new object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">from_components</span><span class="p">(</span><span class="n">components</span><span class="p">,</span> <span class="n">global_phase</span><span class="o">=</span><span class="n">global_phase</span><span class="p">)</span>
        <span class="c1"># Reshape if necessary</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">select_shape</span><span class="p">(</span><span class="n">obj</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                                             <span class="n">shape_var</span><span class="o">=</span><span class="n">old_shape</span><span class="p">,</span>
                                             <span class="n">shape_fun</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                             <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="c1"># @_actualize_</span>
    <span class="c1"># def from_inverse(self, M):</span>
    <span class="c1">#     &quot;&quot;&quot;Calculates the Mueller matrix from the inverse matrix.</span>
    <span class="c1">#</span>
    <span class="c1">#     Parameters:</span>
    <span class="c1">#         M (numpy.matrix 4x4 or Mueller object): Inverse matrix.</span>
    <span class="c1">#</span>
    <span class="c1">#     Returns:</span>
    <span class="c1">#         (numpy.matrix): 4x4 matrix.</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     try:</span>
    <span class="c1">#         if M.type == &#39;Mueller&#39;:</span>
    <span class="c1">#             self.from_matrix(M.M.I)</span>
    <span class="c1">#         else:</span>
    <span class="c1">#             self.from_matrix(M.I)</span>
    <span class="c1">#     except:</span>
    <span class="c1">#         self.from_matrix(M.I)</span>
    <span class="c1">#     return self.M</span>

<div class="viewcode-block" id="Mueller.vacuum"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Mueller.vacuum">[docs]</a>    <span class="k">def</span> <span class="nf">vacuum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">global_phase</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates the matrix for vacuum i.e., an optically neutral element.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            global_phase (float or numpy.ndarray): Adds a global phase to the Jones matrix. Default: 0.</span>
<span class="sd">            length (int): If final object is of size 1, it is stretched to match this size. Default: 1.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (Mueller): Created object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter_amplifier</span><span class="p">(</span><span class="n">D</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                              <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">,</span>
                              <span class="n">global_phase</span><span class="o">=</span><span class="n">global_phase</span><span class="p">,</span>
                              <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                              <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Mueller.filter_amplifier"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Mueller.filter_amplifier">[docs]</a>    <span class="k">def</span> <span class="nf">filter_amplifier</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                         <span class="n">D</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                         <span class="n">global_phase</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                         <span class="n">length</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                         <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates the Mueller object of neutral filters or amplifiers.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            D (float or numpy.ndarray): Attenuation (gain if &gt; 1). Default: 1.</span>
<span class="sd">            global_phase (float or numpy.ndarray): Global phase introduced by the optical element. Default: 0.</span>
<span class="sd">            length (int): If final object is of size 1, it is stretched to match this size. Default: 1.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (Mueller): Created object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Calculate</span>
        <span class="n">components</span> <span class="o">=</span> <span class="p">[</span><span class="n">D</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="p">[</span><span class="n">D</span><span class="p">]</span> <span class="o">+</span> \
            <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="p">[</span><span class="n">D</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="p">[</span><span class="n">D</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">from_components</span><span class="p">(</span><span class="n">components</span><span class="o">=</span><span class="n">components</span><span class="p">,</span>
                             <span class="n">global_phase</span><span class="o">=</span><span class="n">global_phase</span><span class="p">,</span>
                             <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">,</span>
                             <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                             <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="c1"># @_actualize_</span>
<div class="viewcode-block" id="Mueller.mirror"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Mueller.mirror">[docs]</a>    <span class="k">def</span> <span class="nf">mirror</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
               <span class="n">ref</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
               <span class="n">ref_field</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">global_phase</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
               <span class="n">length</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
               <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Mueller matrix of a mirror.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            ref (float or numpy.ndarray): Intensity reflectivity of the mirror. Default: 1.</span>
<span class="sd">            ref_field (float or numpy.ndarray): Electric field reflectivity coefficient. If not None, it overrides REF. Default: None.</span>
<span class="sd">            global_phase (float or numpy.ndarray): Global phase introduced by the optical element. Default: 0.</span>
<span class="sd">            length (int): If final object is of size 1, it is stretched to match this size. Default: 1.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (Mueller): Created object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Use the intensity reflectivity</span>
        <span class="k">if</span> <span class="n">ref_field</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ref_field</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        <span class="c1"># Prepare variables</span>
        <span class="p">(</span><span class="n">ref</span><span class="p">,</span>
         <span class="n">global_phase</span><span class="p">),</span> <span class="n">new_shape</span> <span class="o">=</span> <span class="n">prepare_variables</span><span class="p">(</span><span class="nb">vars</span><span class="o">=</span><span class="p">[</span><span class="n">ref</span><span class="p">,</span> <span class="n">global_phase</span><span class="p">],</span>
                                                      <span class="n">expand</span><span class="o">=</span><span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">],</span>
                                                      <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">,</span>
                                                      <span class="n">give_shape</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># Calculate</span>
        <span class="n">components</span> <span class="o">=</span> <span class="p">[</span><span class="n">ref</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="p">[</span><span class="n">ref</span><span class="p">]</span> <span class="o">+</span> \
            <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="p">[</span><span class="o">-</span><span class="n">ref</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="p">[</span><span class="o">-</span><span class="n">ref</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">from_components</span><span class="p">(</span><span class="n">components</span><span class="o">=</span><span class="n">components</span><span class="p">,</span>
                             <span class="n">global_phase</span><span class="o">=</span><span class="n">global_phase</span><span class="p">,</span>
                             <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                             <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">no_rotation</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="c1"># @_actualize_</span>
<div class="viewcode-block" id="Mueller.depolarizer_perfect"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Mueller.depolarizer_perfect">[docs]</a>    <span class="k">def</span> <span class="nf">depolarizer_perfect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                            <span class="n">M00</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                            <span class="n">global_phase</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                            <span class="n">length</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                            <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates a perfect depolarizer:</span>

<span class="sd">        .. math:: M_{p}=\left[\begin{array}{cccc}</span>
<span class="sd">            M_{00} &amp; 0 &amp; 0 &amp; 0\\</span>
<span class="sd">            0 &amp; d_{1} &amp; 0 &amp; 0\\</span>
<span class="sd">            0 &amp; 0 &amp; d_{2} &amp; 0\\</span>
<span class="sd">            0 &amp; 0 &amp; 0 &amp; d_{3}</span>
<span class="sd">            \end{array}\right]</span>

<span class="sd">        Parameters:</span>
<span class="sd">            M00 (float, default 1): Parameter of average intensity. Default: 1.</span>
<span class="sd">            global_phase (float or numpy.ndarray): Global phase introduced by the optical element. Default: 0.</span>
<span class="sd">            length (int): If final object is of size 1, it is stretched to match this size. Default: 1.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (Mueller): Created object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Calculate</span>
        <span class="n">components</span> <span class="o">=</span> <span class="p">[</span><span class="n">M00</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">15</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">from_components</span><span class="p">(</span><span class="n">components</span><span class="o">=</span><span class="n">components</span><span class="p">,</span>
                             <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">,</span>
                             <span class="n">global_phase</span><span class="o">=</span><span class="n">global_phase</span><span class="p">,</span>
                             <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                             <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="c1"># @_actualize_</span>
<div class="viewcode-block" id="Mueller.depolarizer_diagonal"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Mueller.depolarizer_diagonal">[docs]</a>    <span class="k">def</span> <span class="nf">depolarizer_diagonal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                             <span class="n">d</span><span class="p">,</span>
                             <span class="n">M00</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                             <span class="n">global_phase</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                             <span class="n">length</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                             <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                             <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates a diagonal depolarizer:</span>

<span class="sd">        .. math:: M_{p}=\left[\begin{array}{cccc}</span>
<span class="sd">            M_{00} &amp; 0 &amp; 0 &amp; 0\\</span>
<span class="sd">            0 &amp; d_{1} &amp; 0 &amp; 0\\</span>
<span class="sd">            0 &amp; 0 &amp; d_{2} &amp; 0\\</span>
<span class="sd">            0 &amp; 0 &amp; 0 &amp; d_{3}</span>
<span class="sd">            \end{array}\right]</span>

<span class="sd">        Parameters:</span>
<span class="sd">            d (list, float or numpy.ndarray): Absorption coefficients. If list, it must contain three float or numpy arrays, one for each diagonal value. If float or numpy.ndarray, $d_1 = d_2 = d_3$.</span>
<span class="sd">            M00 (float, default 1): Parameter of average intensity. Default: 1.</span>
<span class="sd">            global_phase (float or numpy.ndarray): Global phase introduced by the optical element. Default: 0.</span>
<span class="sd">            length (int): If final object is of size 1, it is stretched to match this size. Default: 1.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (Mueller): Created object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Calculate</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">components</span> <span class="o">=</span> <span class="p">[</span><span class="n">M00</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="p">[</span>
                <span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">components</span> <span class="o">=</span> <span class="p">[</span><span class="n">M00</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="p">[</span><span class="n">d</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">from_components</span><span class="p">(</span><span class="n">components</span><span class="o">=</span><span class="n">components</span><span class="p">,</span>
                             <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">,</span>
                             <span class="n">global_phase</span><span class="o">=</span><span class="n">global_phase</span><span class="p">,</span>
                             <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                             <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="c1"># @_actualize_</span>
<div class="viewcode-block" id="Mueller.depolarizer_states"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Mueller.depolarizer_states">[docs]</a>    <span class="k">def</span> <span class="nf">depolarizer_states</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                           <span class="n">d</span><span class="p">,</span>
                           <span class="n">S</span><span class="p">,</span>
                           <span class="n">Dv</span><span class="o">=</span><span class="n">zero_D</span><span class="p">,</span>
                           <span class="n">Pv</span><span class="o">=</span><span class="n">zero_D</span><span class="p">,</span>
                           <span class="n">M00</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                           <span class="n">global_phase</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                           <span class="n">length</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                           <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates a general depolarizer form its three eigenstates and their depolarization factors (eigenvalues), plus its polarization or polarizance vector.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            d (list, float or numpy.ndarray): Depolarization factors (eigenvalues of m). If list, it must contain three float or numpy arrays, one for each diagonal value. If float or numpy.ndarray, $d_1 = d_2 = d_3$.</span>
<span class="sd">            S (list or Stokes): Principal states. If list, it must contain three Stokes objects. If Stokes, at least one dimension must have dimension 3.</span>
<span class="sd">            Dv (numpy.ndarray): Diattenuation vector. If None, the polarizance vector is used instead. Default: None.</span>
<span class="sd">            Pv (numpy.ndarray): Polarizance vector. Used only if Dv is None. If None, the depolarizer will have zero diattenuation and polarizance. Default: None.</span>
<span class="sd">            M00 (float, default 1): Parameter of average intensity. Default: 1.</span>
<span class="sd">            global_phase (float or numpy.ndarray): Global phase introduced by the optical element. Default: 0.</span>
<span class="sd">            length (int): If final object is of size 1, it is stretched to match this size. Default: 1.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (Mueller): Created object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Prepare variables. First the extinction</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">d_list</span> <span class="o">=</span> <span class="n">d</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="n">sh</span> <span class="o">==</span> <span class="mi">3</span><span class="p">))</span>
            <span class="n">d_list</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">ind</span><span class="p">),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">ind</span><span class="p">),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">ind</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="p">(</span><span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">,</span> <span class="n">d3</span><span class="p">),</span> <span class="n">new_shape1</span> <span class="o">=</span> <span class="n">prepare_variables</span><span class="p">(</span><span class="nb">vars</span><span class="o">=</span><span class="n">d</span><span class="p">,</span>
                                                     <span class="n">expand</span><span class="o">=</span><span class="p">[</span><span class="kc">True</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">,</span>
                                                     <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">,</span>
                                                     <span class="n">give_shape</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">d1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">d1</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
        <span class="n">d2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">d2</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
        <span class="n">d3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">d3</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
        <span class="c1"># Now, the states</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">S1</span><span class="p">,</span> <span class="n">S2</span><span class="p">,</span> <span class="n">S3</span> <span class="o">=</span> <span class="n">S</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">S1</span><span class="p">,</span> <span class="n">S2</span><span class="p">,</span> <span class="n">S3</span> <span class="o">=</span> <span class="n">create_Stokes</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
            <span class="n">sh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="n">sh</span> <span class="o">==</span> <span class="mi">3</span><span class="p">))</span>
            <span class="n">M</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">matrix</span><span class="p">()</span>
            <span class="n">S1</span><span class="o">.</span><span class="n">from_matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">S2</span><span class="o">.</span><span class="n">from_matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">S3</span><span class="o">.</span><span class="n">from_matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">S1</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span>
        <span class="n">S2</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span>
        <span class="n">S3</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span>
        <span class="n">comp</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">S1</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">S1</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:],</span> <span class="n">S1</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">:],</span> <span class="n">S2</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">S2</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:],</span>
            <span class="n">S2</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">:],</span> <span class="n">S3</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">S3</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:],</span> <span class="n">S3</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">:]</span>
        <span class="p">]</span>
        <span class="n">comp</span><span class="p">,</span> <span class="n">new_shape2</span> <span class="o">=</span> <span class="n">prepare_variables</span><span class="p">(</span><span class="nb">vars</span><span class="o">=</span><span class="n">comp</span><span class="p">,</span>
                                             <span class="n">expand</span><span class="o">=</span><span class="p">[</span><span class="kc">True</span><span class="p">]</span> <span class="o">*</span> <span class="mi">9</span><span class="p">,</span>
                                             <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">,</span>
                                             <span class="n">give_shape</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">9</span><span class="p">):</span>
            <span class="n">comp</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">comp</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">new_shape</span> <span class="o">=</span> <span class="n">take_shape</span><span class="p">([</span><span class="n">new_shape1</span><span class="p">,</span> <span class="n">new_shape2</span><span class="p">])</span>

        <span class="c1"># Create the small matrix of the depolarizer</span>
        <span class="n">v1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">d1</span> <span class="o">*</span> <span class="n">comp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">d1</span> <span class="o">*</span> <span class="n">comp</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">d1</span> <span class="o">*</span> <span class="n">comp</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span>
        <span class="n">v2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">d2</span> <span class="o">*</span> <span class="n">comp</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">d2</span> <span class="o">*</span> <span class="n">comp</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">d2</span> <span class="o">*</span> <span class="n">comp</span><span class="p">[</span><span class="mi">5</span><span class="p">]])</span>
        <span class="n">v3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">d3</span> <span class="o">*</span> <span class="n">comp</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="n">d3</span> <span class="o">*</span> <span class="n">comp</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="n">d3</span> <span class="o">*</span> <span class="n">comp</span><span class="p">[</span><span class="mi">8</span><span class="p">]])</span>
        <span class="n">m1</span> <span class="o">=</span> <span class="n">kron_axis</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">m2</span> <span class="o">=</span> <span class="n">kron_axis</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">m3</span> <span class="o">=</span> <span class="n">kron_axis</span><span class="p">(</span><span class="n">v3</span><span class="p">,</span> <span class="n">v3</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">m1</span> <span class="o">+</span> <span class="n">m2</span> <span class="o">+</span> <span class="n">m3</span>

        <span class="c1"># Create the object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">from_blocks</span><span class="p">(</span><span class="n">M00</span><span class="o">=</span><span class="n">M00</span><span class="p">,</span> <span class="n">Dv</span><span class="o">=</span><span class="n">Dv</span><span class="p">,</span> <span class="n">Pv</span><span class="o">=</span><span class="n">Pv</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">select_shape</span><span class="p">(</span><span class="n">obj</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                                             <span class="n">shape_var</span><span class="o">=</span><span class="n">new_shape</span><span class="p">,</span>
                                             <span class="n">shape_fun</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                             <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="c1"># @_actualize_</span>
<div class="viewcode-block" id="Mueller.diattenuator_perfect"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Mueller.diattenuator_perfect">[docs]</a>    <span class="k">def</span> <span class="nf">diattenuator_perfect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                             <span class="n">azimuth</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                             <span class="n">global_phase</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                             <span class="n">length</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                             <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                             <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Mueller 4x4 matrix for a perfect diattenuator (polarizer).</span>

<span class="sd">        Parameters:</span>
<span class="sd">            azimuth (float or numpy.ndarray): Rotation angle of the high transmission polarizer axis. Default: 0.</span>
<span class="sd">            global_phase (float or numpy.ndarray): Global phase introduced by the optical element. Default: 0.</span>
<span class="sd">            length (int): If final object is of size 1, it is stretched to match this size. Default: 1.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (Mueller): Created object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">diattenuator_linear</span><span class="p">(</span><span class="n">p1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                 <span class="n">p2</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                 <span class="n">azimuth</span><span class="o">=</span><span class="n">azimuth</span><span class="p">,</span>
                                 <span class="n">global_phase</span><span class="o">=</span><span class="n">global_phase</span><span class="p">,</span>
                                 <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                 <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="c1"># @_actualize_</span>
<div class="viewcode-block" id="Mueller.diattenuator_linear"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Mueller.diattenuator_linear">[docs]</a>    <span class="k">def</span> <span class="nf">diattenuator_linear</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                            <span class="n">p1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                            <span class="n">p2</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                            <span class="n">Tmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">Tmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">azimuth</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                            <span class="n">global_phase</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                            <span class="n">length</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                            <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Mueller matrices of pure linear homogeneous diattenuators.</span>

<span class="sd">        .. math:: M\left(\theta=0\right)=\frac{1}{2}\left[\begin{array}{cccc}</span>
<span class="sd">                            p_{1}^{2}+p_{2}^{2} &amp; p_{1}^{2}-p_{2}^{2} &amp; 0 &amp; 0\\</span>
<span class="sd">                            p_{1}^{2}-p_{2}^{2} &amp; p_{1}^{2}+p_{2}^{2} &amp; 0 &amp; 0\\</span>
<span class="sd">                            0 &amp; 0 &amp; 2p_{1}p_{2} &amp; 0\\</span>
<span class="sd">                            0 &amp; 0 &amp; 0 &amp; 2p_{1}p_{2}</span>
<span class="sd">                            \end{array}\right]</span>

<span class="sd">        References:</span>
<span class="sd">            J.J. Gil, R. Ossikovsky &quot;Polarized light and the Mueller Matrix approach&quot;, CRC Press (2016), (4.79) - p. 143.</span>
<span class="sd">            Handbook of Optics vol 2. 22.16 (Table 1).</span>

<span class="sd">        Parameters:</span>
<span class="sd">            p1 (float or numpy.ndarray): Field transmission of the transmission axis. Default: 1.</span>
<span class="sd">            p2 (float or numpy.ndarray): Field transmission of the attenuation axis. Default: 0.</span>
<span class="sd">            Tmax (float or numpy.ndarray): Maximum transmission. If not None, overrides p1. Default: None.</span>
<span class="sd">            Tmin (float or numpy.ndarray): Minimum transmission. If not None, overrides p2. Default: None.</span>
<span class="sd">            azimuth (float or numpy.ndarray): Rotation angle of the high transmission polarizer axis. Default: 0.</span>
<span class="sd">            global_phase (float or numpy.ndarray): Global phase introduced by the optical element. Default: 0.</span>
<span class="sd">            length (int): If final object is of size 1, it is stretched to match this size. Default: 1.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (Mueller): Created object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Use field transmission coefficients</span>
        <span class="k">if</span> <span class="n">Tmax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Tmax</span> <span class="o">=</span> <span class="n">p1</span><span class="o">**</span><span class="mi">2</span>
        <span class="k">if</span> <span class="n">Tmin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Tmin</span> <span class="o">=</span> <span class="n">p2</span><span class="o">**</span><span class="mi">2</span>
        <span class="c1"># Prepare variables</span>
        <span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span>
         <span class="n">azimuth</span><span class="p">),</span> <span class="n">new_shape</span> <span class="o">=</span> <span class="n">prepare_variables</span><span class="p">(</span><span class="nb">vars</span><span class="o">=</span><span class="p">[</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">azimuth</span><span class="p">],</span>
                                                 <span class="n">expand</span><span class="o">=</span><span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">],</span>
                                                 <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">,</span>
                                                 <span class="n">give_shape</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># Calculate intensity transmission coefficients</span>
        <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">Tmax</span> <span class="o">+</span> <span class="n">Tmin</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">Tmax</span> <span class="o">-</span> <span class="n">Tmin</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Tmax</span> <span class="o">*</span> <span class="n">Tmin</span><span class="p">)</span>
        <span class="c1"># Calculate the matrix</span>
        <span class="n">components</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">+</span> \
            <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="p">[</span><span class="n">c</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">from_components</span><span class="p">(</span><span class="n">components</span><span class="o">=</span><span class="n">components</span><span class="p">,</span>
                             <span class="n">global_phase</span><span class="o">=</span><span class="n">global_phase</span><span class="p">,</span>
                             <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">azimuth</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">select_shape</span><span class="p">(</span><span class="n">obj</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                                             <span class="n">shape_var</span><span class="o">=</span><span class="n">new_shape</span><span class="p">,</span>
                                             <span class="n">shape_fun</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                             <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="c1"># @_actualize_</span>
<div class="viewcode-block" id="Mueller.diattenuator_charac_angles"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Mueller.diattenuator_charac_angles">[docs]</a>    <span class="k">def</span> <span class="nf">diattenuator_charac_angles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                   <span class="n">p1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                   <span class="n">p2</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                   <span class="n">Tmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                   <span class="n">Tmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                   <span class="n">alpha</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                   <span class="n">delay</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                   <span class="n">global_phase</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                   <span class="n">length</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                   <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                   <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Method that calculates the most general homogenous diattenuator from diattenuator parameters with the intermediate step of calculating the diattenuation vector.</span>

<span class="sd">        References:</span>
<span class="sd">            J.J. Gil, R. Ossikovsky &quot;Polarized light and the Mueller Matrix approach&quot;, CRC Press (2016), pp 142.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            p1 (float or numpy.ndarray): Electric field transmission coefficient of the transmission eigenstate Default: 1</span>
<span class="sd">            p2 (float or numpy.ndarray): Electric field transmission coefficient of the extinction eigenstate. Default: 0.</span>
<span class="sd">            Tmax (float or numpy.ndarray): Maximum transmission. If not None, overrides p1. Default: None.</span>
<span class="sd">            Tmin (float or numpy.ndarray): Minimum transmission. If not None, overrides p2. Default: None.</span>
<span class="sd">            alpha (float or numpy.ndarray): [0, pi/2]: tan(alpha) is the ratio between field amplitudes of X and Y components. Default: 0.</span>
<span class="sd">            delay (float or numpy.ndarray): [0, 2*pi]: phase difference between X and Y field components. Default: 0.</span>
<span class="sd">            global_phase (float or numpy.ndarray): Global phase introduced by the optical element. Default: 0.</span>
<span class="sd">            length (int): If final object is of size 1, it is stretched to match this size. Default: 1.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (Mueller): Created object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Use field transmission coefficients</span>
        <span class="k">if</span> <span class="n">Tmax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Tmax</span> <span class="o">=</span> <span class="n">p1</span><span class="o">**</span><span class="mi">2</span>
        <span class="k">if</span> <span class="n">Tmin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Tmin</span> <span class="o">=</span> <span class="n">p2</span><span class="o">**</span><span class="mi">2</span>
        <span class="c1"># Prepare variables</span>
        <span class="p">(</span><span class="n">Tmax</span><span class="p">,</span> <span class="n">Tmin</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">delay</span><span class="p">),</span> <span class="n">new_shape</span> <span class="o">=</span> <span class="n">prepare_variables</span><span class="p">(</span>
            <span class="nb">vars</span><span class="o">=</span><span class="p">[</span><span class="n">Tmax</span><span class="p">,</span> <span class="n">Tmin</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">delay</span><span class="p">],</span>
            <span class="n">expand</span><span class="o">=</span><span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">],</span>
            <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">,</span>
            <span class="n">give_shape</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># Restrict parameter values to the correct interval</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">put_in_limits</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="s2">&quot;alpha&quot;</span><span class="p">)</span>
        <span class="n">delay</span> <span class="o">=</span> <span class="n">put_in_limits</span><span class="p">(</span><span class="n">delay</span><span class="p">,</span> <span class="s2">&quot;delay&quot;</span><span class="p">)</span>
        <span class="c1"># Calculate diattenuation vector and M00</span>
        <span class="n">cte</span> <span class="o">=</span> <span class="p">(</span><span class="n">Tmax</span> <span class="o">-</span> <span class="n">Tmin</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">Tmax</span> <span class="o">+</span> <span class="n">Tmin</span><span class="p">)</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">cte</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">cond</span><span class="p">):</span>
            <span class="n">cte</span><span class="p">[</span><span class="n">cond</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">M00</span> <span class="o">=</span> <span class="p">(</span><span class="n">Tmax</span> <span class="o">+</span> <span class="n">Tmin</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">Dv</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">cte</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">alpha</span><span class="p">),</span> <span class="n">cte</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">delay</span><span class="p">),</span>
            <span class="n">cte</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">delay</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="c1"># Create the element</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">diattenuator_vector</span><span class="p">(</span><span class="n">Dv</span><span class="o">=</span><span class="n">Dv</span><span class="p">,</span>
                                 <span class="n">M00</span><span class="o">=</span><span class="n">M00</span><span class="p">,</span>
                                 <span class="n">global_phase</span><span class="o">=</span><span class="n">global_phase</span><span class="p">,</span>
                                 <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                 <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">select_shape</span><span class="p">(</span><span class="n">obj</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape_var</span><span class="o">=</span><span class="n">new_shape</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="c1"># @_actualize_</span>
<div class="viewcode-block" id="Mueller.diattenuator_azimuth_ellipticity"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Mueller.diattenuator_azimuth_ellipticity">[docs]</a>    <span class="k">def</span> <span class="nf">diattenuator_azimuth_ellipticity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                         <span class="n">p1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                         <span class="n">p2</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                         <span class="n">Tmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                         <span class="n">Tmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                         <span class="n">azimuth</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                         <span class="n">ellipticity</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                         <span class="n">global_phase</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                         <span class="n">length</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                         <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                         <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Method that calculates the most general homogenous diattenuator from</span>
<span class="sd">        diattenuator parameters with the intermediate step of calculating the</span>
<span class="sd">        diattenuation vector.</span>

<span class="sd">        References:</span>
<span class="sd">            J.J. Gil, R. Ossikovsky &quot;Polarized light and the Mueller Matrix approach&quot;, CRC Press (2016), pp 142.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            p1 (float or numpy.ndarray): Electric field transmission coefficient of the transmission eigenstate. Default: 1.</span>
<span class="sd">            p2 (float or numpy.ndarray): Electric field transmission coefficient of the extinction eigenstate. Default: 0.</span>
<span class="sd">            Tmax (float or numpy.ndarray): Maximum transmission. If not None, overrides p1. Default: None.</span>
<span class="sd">            Tmin (float or numpy.ndarray): Minimum transmission. If not None, overrides p2. Default: None.</span>
<span class="sd">            azimuth (float): [0, pi]: Azimuth. Defaut: 0</span>
<span class="sd">            ellipticity (float): [-pi/4, pi/4]: Ellipticity angle. Default: 0</span>
<span class="sd">            global_phase (float or numpy.ndarray): Global phase introduced by the optical element. Default: 0.</span>
<span class="sd">            length (int): If final object is of size 1, it is stretched to match this size. Default: 1.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (Mueller): Created object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Use field transmission coefficients</span>
        <span class="k">if</span> <span class="n">Tmax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Tmax</span> <span class="o">=</span> <span class="n">p1</span><span class="o">**</span><span class="mi">2</span>
        <span class="k">if</span> <span class="n">Tmin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Tmin</span> <span class="o">=</span> <span class="n">p2</span><span class="o">**</span><span class="mi">2</span>
        <span class="c1"># Prepare variables</span>
        <span class="p">(</span><span class="n">Tmax</span><span class="p">,</span> <span class="n">Tmin</span><span class="p">,</span> <span class="n">azimuth</span><span class="p">,</span> <span class="n">ellipticity</span><span class="p">),</span> <span class="n">new_shape</span> <span class="o">=</span> <span class="n">prepare_variables</span><span class="p">(</span>
            <span class="nb">vars</span><span class="o">=</span><span class="p">[</span><span class="n">Tmax</span><span class="p">,</span> <span class="n">Tmin</span><span class="p">,</span> <span class="n">azimuth</span><span class="p">,</span> <span class="n">ellipticity</span><span class="p">],</span>
            <span class="n">expand</span><span class="o">=</span><span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">],</span>
            <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">,</span>
            <span class="n">give_shape</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># Restrict parameter values to the correct interval</span>
        <span class="n">azimuth</span> <span class="o">=</span> <span class="n">put_in_limits</span><span class="p">(</span><span class="n">azimuth</span><span class="p">,</span> <span class="s2">&quot;azimuth&quot;</span><span class="p">)</span>
        <span class="n">ellipticity</span> <span class="o">=</span> <span class="n">put_in_limits</span><span class="p">(</span><span class="n">ellipticity</span><span class="p">,</span> <span class="s2">&quot;ellipticity&quot;</span><span class="p">)</span>
        <span class="c1"># Calculate the diattenuation vector and M00</span>
        <span class="n">cte</span> <span class="o">=</span> <span class="p">(</span><span class="n">Tmax</span> <span class="o">-</span> <span class="n">Tmin</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">Tmax</span> <span class="o">+</span> <span class="n">Tmin</span><span class="p">)</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">cte</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">cond</span><span class="p">):</span>
            <span class="n">cte</span><span class="p">[</span><span class="n">cond</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">M00</span> <span class="o">=</span> <span class="p">(</span><span class="n">Tmax</span> <span class="o">+</span> <span class="n">Tmin</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">Dv</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">cte</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">azimuth</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">ellipticity</span><span class="p">),</span>
            <span class="n">cte</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">azimuth</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">ellipticity</span><span class="p">),</span>
            <span class="n">cte</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">ellipticity</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="c1"># Create the element</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">diattenuator_vector</span><span class="p">(</span><span class="n">Dv</span><span class="o">=</span><span class="n">Dv</span><span class="p">,</span>
                                 <span class="n">M00</span><span class="o">=</span><span class="n">M00</span><span class="p">,</span>
                                 <span class="n">global_phase</span><span class="o">=</span><span class="n">global_phase</span><span class="p">,</span>
                                 <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                 <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">select_shape</span><span class="p">(</span><span class="n">obj</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape_var</span><span class="o">=</span><span class="n">new_shape</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="c1"># @_actualize_</span>
<div class="viewcode-block" id="Mueller.diattenuator_vector"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Mueller.diattenuator_vector">[docs]</a>    <span class="k">def</span> <span class="nf">diattenuator_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                            <span class="n">Dv</span><span class="p">,</span>
                            <span class="n">M00</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">global_phase</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                            <span class="n">length</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                            <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Method that calculates the most general homogenous diattenuator from the</span>
<span class="sd">        Diattenuation or Polarizance vector.</span>

<span class="sd">        References:</span>
<span class="sd">            J.J. Gil, R. Ossikovsky &quot;Polarized light and the Mueller Matrix approach&quot;, CRC Press (2016), pp 142.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            Dv (3xN numpy.ndarray): Diattenuation or Polarizance vectors.</span>
<span class="sd">            M00 (float or numpy.ndarray): Parameter of average intensity. If None, the maximum possible value is used. Default: None.</span>
<span class="sd">            global_phase (float or numpy.ndarray): Global phase introduced by the optical element. Default: 0.</span>
<span class="sd">            length (int): If final object is of size 1, it is stretched to match this size. Default: 1.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (Mueller): Created object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Prepare the variables</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">Dv</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">new_shape</span> <span class="o">=</span> <span class="n">prepare_variables_blocks</span><span class="p">(</span><span class="n">Dv</span><span class="o">=</span><span class="n">Dv</span><span class="p">,</span>
                                                          <span class="n">give_shape</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># Calculate the diattenuation and make it physically realizable</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Dv</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">d</span> <span class="o">&gt;</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">cond</span><span class="p">):</span>
            <span class="n">Dv</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">cond</span><span class="p">]</span> <span class="o">=</span> <span class="n">Dv</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">cond</span><span class="p">]</span> <span class="o">/</span> <span class="n">d</span><span class="p">[</span><span class="n">cond</span><span class="p">]</span>
            <span class="n">Dv</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">cond</span><span class="p">]</span> <span class="o">=</span> <span class="n">Dv</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">cond</span><span class="p">]</span> <span class="o">/</span> <span class="n">d</span><span class="p">[</span><span class="n">cond</span><span class="p">]</span>
            <span class="n">Dv</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">cond</span><span class="p">]</span> <span class="o">=</span> <span class="n">Dv</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">cond</span><span class="p">]</span> <span class="o">/</span> <span class="n">d</span><span class="p">[</span><span class="n">cond</span><span class="p">]</span>
            <span class="n">d</span><span class="p">[</span><span class="n">cond</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="c1"># Calculate maximum achievable m00</span>
        <span class="k">if</span> <span class="n">M00</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">M00</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">d</span><span class="p">)</span>
        <span class="c1"># Calculate the m small matrix</span>
        <span class="n">skd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">d</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">m1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">skd</span><span class="p">)</span>
        <span class="n">cte</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">skd</span><span class="p">)</span> <span class="o">/</span> <span class="n">d</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">cte</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">cond</span><span class="p">):</span>
            <span class="n">cte</span><span class="p">[</span><span class="n">cond</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">m2</span> <span class="o">=</span> <span class="n">kron_axis</span><span class="p">(</span><span class="n">Dv</span><span class="p">,</span> <span class="n">Dv</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)),</span> <span class="n">cte</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">m1</span> <span class="o">+</span> <span class="n">m2</span>
        <span class="c1"># This equation fails if d=0</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="n">tol_default</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">cond</span><span class="p">):</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)])</span>
        <span class="c1"># Now we have all the necessary blocks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">from_blocks</span><span class="p">(</span><span class="n">Dv</span><span class="p">,</span>
                         <span class="n">Dv</span><span class="p">,</span>
                         <span class="n">m</span><span class="p">,</span>
                         <span class="n">M00</span><span class="p">,</span>
                         <span class="n">global_phase</span><span class="o">=</span><span class="n">global_phase</span><span class="p">,</span>
                         <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                         <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">select_shape</span><span class="p">(</span><span class="n">obj</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape_var</span><span class="o">=</span><span class="n">new_shape</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="c1"># @_actualize_</span>
<div class="viewcode-block" id="Mueller.retarder_linear"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Mueller.retarder_linear">[docs]</a>    <span class="k">def</span> <span class="nf">retarder_linear</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                        <span class="n">R</span><span class="p">,</span>
                        <span class="n">azimuth</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                        <span class="n">global_phase</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                        <span class="n">length</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                        <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Mueller matrix of homogeneous linear retarders.</span>

<span class="sd">        .. math:: M\left(\theta=0\right)=\left[\begin{array}{cccc}</span>
<span class="sd">                            1 &amp; 0 &amp; 0 &amp; 0\\</span>
<span class="sd">                            0 &amp; 1 &amp; 0 &amp; 0\\</span>
<span class="sd">                            0 &amp; 0 &amp; \cos(\Delta) &amp; \sin(\Delta)\\</span>
<span class="sd">                            0 &amp; 0 &amp; -\sin(\Delta) &amp; \cos(\Delta)</span>
<span class="sd">                            \end{array}\right]</span>

<span class="sd">        References:</span>
<span class="sd">            J.J. Gil, R. Ossikovsky &quot;Polarized light and the Mueller Matrix approach&quot;, CRC Press (2016), (4.31) - p. 132</span>
<span class="sd">            Handbook of Optics vol 2. 22.16 (Table 1).</span>

<span class="sd">        Parameters:</span>
<span class="sd">            R (float or numpy.ndarray): [0, pi] Retardance introduced to the slow eigenstate respect to the fast eigenstate.</span>
<span class="sd">            azimuth (float or numpy.ndarray): rotation angle of the high transmission polarizer axis. Default: 0.</span>
<span class="sd">            global_phase (float or numpy.ndarray): Global phase introduced by the optical element. Default: 0.</span>
<span class="sd">            length (int): If final object is of size 1, it is stretched to match this size. Default: 1.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (Mueller): Created object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Make sure that retardance is correct</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">put_in_limits</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="s1">&#39;Retardance&#39;</span><span class="p">)</span>
        <span class="c1"># Calculate the matrix components</span>
        <span class="n">components</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> \
            <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">R</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">R</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">[</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">R</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">R</span><span class="p">)]</span>
        <span class="c1"># Create the object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">from_components</span><span class="p">(</span><span class="n">components</span><span class="p">,</span>
                             <span class="n">global_phase</span><span class="o">=</span><span class="n">global_phase</span><span class="p">,</span>
                             <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">,</span>
                             <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                             <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">azimuth</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="c1"># @_actualize_</span>
<div class="viewcode-block" id="Mueller.quarter_waveplate"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Mueller.quarter_waveplate">[docs]</a>    <span class="k">def</span> <span class="nf">quarter_waveplate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                          <span class="n">azimuth</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                          <span class="n">global_phase</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                          <span class="n">length</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                          <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Mueller matrices of ideal quarter-wave retarder.</span>

<span class="sd">        .. math:: M\left(\theta=0\right)=\left[\begin{array}{cccc}</span>
<span class="sd">                        1 &amp; 0 &amp; 0 &amp; 0\\</span>
<span class="sd">                        0 &amp; 1 &amp; 0 &amp; 0\\</span>
<span class="sd">                        0 &amp; 0 &amp; 0 &amp; 1\\</span>
<span class="sd">                        0 &amp; 0 &amp; -1 &amp; 0</span>
<span class="sd">                        \end{array}\right]</span>

<span class="sd">        References:</span>
<span class="sd">            J.J. Gil, R. Ossikovsky &quot;Polarized light and the Mueller Matrix approach&quot;, CRC Press (2016), (4.32) - p. 132</span>
<span class="sd">            Handbook of Optics vol 2. 22.16 (Table 1).</span>

<span class="sd">        Parameters:</span>
<span class="sd">            azimuth (float or numpy.ndarray): rotation angle of the high transmission polarizer axis. Default: 0.</span>
<span class="sd">            global_phase (float or numpy.ndarray): Global phase introduced by the optical element. Default: 0.</span>
<span class="sd">            length (int): If final object is of size 1, it is stretched to match this size. Default: 1.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (Mueller): Created object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Calculate the matrix components</span>
        <span class="n">components</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">5</span> <span class="o">+</span> \
            <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Create the object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">from_components</span><span class="p">(</span><span class="n">components</span><span class="p">,</span>
                             <span class="n">global_phase</span><span class="o">=</span><span class="n">global_phase</span><span class="p">,</span>
                             <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">,</span>
                             <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                             <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">azimuth</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="c1"># @_actualize_</span>
<div class="viewcode-block" id="Mueller.half_waveplate"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Mueller.half_waveplate">[docs]</a>    <span class="k">def</span> <span class="nf">half_waveplate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                       <span class="n">azimuth</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                       <span class="n">global_phase</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                       <span class="n">length</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                       <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Mueller matrices of ideal half-wave retarders.</span>

<span class="sd">        .. math:: M\left(\theta=0\right)=\left[\begin{array}{cccc}</span>
<span class="sd">                        1 &amp; 0 &amp; 0 &amp; 0\\</span>
<span class="sd">                        0 &amp; 1 &amp; 0 &amp; 0\\</span>
<span class="sd">                        0 &amp; 0 &amp; -1 &amp; 0\\</span>
<span class="sd">                        0 &amp; 0 &amp; 0 &amp; -1</span>
<span class="sd">                        \end{array}\right]</span>

<span class="sd">        References:</span>
<span class="sd">            J.J. Gil, R. Ossikovsky &quot;Polarized light and the Mueller Matrix approach&quot;, CRC Press (2016), (4.32) - p. 132</span>
<span class="sd">            Handbook of Optics vol 2. 22.16 (Table 1).</span>

<span class="sd">        Parameters:</span>
<span class="sd">            azimuth (float or numpy.ndarray): rotation angle of the high transmission polarizer axis. Default: 0.</span>
<span class="sd">            global_phase (float or numpy.ndarray): Global phase introduced by the optical element. Default: 0.</span>
<span class="sd">            length (int): If final object is of size 1, it is stretched to match this size. Default: 1.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (Mueller): Created object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Calculate the matrix components</span>
        <span class="n">components</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Create the object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">from_components</span><span class="p">(</span><span class="n">components</span><span class="p">,</span>
                             <span class="n">global_phase</span><span class="o">=</span><span class="n">global_phase</span><span class="p">,</span>
                             <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">,</span>
                             <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                             <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">azimuth</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="c1"># @_actualize_</span>
<div class="viewcode-block" id="Mueller.retarder_charac_angles"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Mueller.retarder_charac_angles">[docs]</a>    <span class="k">def</span> <span class="nf">retarder_charac_angles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                               <span class="n">R</span><span class="p">,</span>
                               <span class="n">alpha</span><span class="p">,</span>
                               <span class="n">delay</span><span class="p">,</span>
                               <span class="n">M00</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                               <span class="n">global_phase</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                               <span class="n">length</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                               <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                               <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Method that calculates the most general homogeneous retarder from the characteristic angles of the fast eigenstate. The method calculates first the retardance vector, and uses it to calculate the Mueler matrix.</span>

<span class="sd">        References:</span>
<span class="sd">            &quot;Polarized light and the Mueller Matrix approach&quot;, J. J. Gil, pp 125.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            R (float or numpy.ndarray): [0, pi] Retardance introduced to the slow eigenstate respect to the fast eigenstate.</span>
<span class="sd">            alpha (float or numpy.ndarray): [0, pi]: tan(alpha) is the ratio between amplitudes of the electric field of the fast eigenstate.</span>
<span class="sd">            delay (float or numpy.ndarray): [0, 2*pi]: phase difference between both components of the electric field of the fast eigenstate.</span>
<span class="sd">            M00 (float or numpy.ndarray): Parameter of average intensity. Default: 1</span>
<span class="sd">            global_phase (float or numpy.ndarray): Global phase introduced by the optical element. Default: 0.</span>
<span class="sd">            length (int): If final object is of size 1, it is stretched to match this size. Default: 1.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (Mueller): Created object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Prepare variables</span>
        <span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span>
         <span class="n">delay</span><span class="p">),</span> <span class="n">new_shape</span> <span class="o">=</span> <span class="n">prepare_variables</span><span class="p">(</span><span class="nb">vars</span><span class="o">=</span><span class="p">[</span><span class="n">R</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">delay</span><span class="p">],</span>
                                               <span class="n">expand</span><span class="o">=</span><span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span>
                                               <span class="n">give_shape</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># Restrict parameter values to the correct interval</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">put_in_limits</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="s2">&quot;alpha&quot;</span><span class="p">)</span>
        <span class="n">delay</span> <span class="o">=</span> <span class="n">put_in_limits</span><span class="p">(</span><span class="n">delay</span><span class="p">,</span> <span class="s2">&quot;delay&quot;</span><span class="p">)</span>
        <span class="c1"># Calculate the normalized retardance vector</span>
        <span class="n">Rv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">alpha</span><span class="p">),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">delay</span><span class="p">),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">delay</span><span class="p">)</span>
        <span class="p">])</span>
        <span class="c1"># Create the object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">retarder_vector</span><span class="p">(</span><span class="n">Rv</span><span class="o">=</span><span class="n">Rv</span><span class="p">,</span>
                             <span class="n">R</span><span class="o">=</span><span class="n">R</span><span class="p">,</span>
                             <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;normalized&#39;</span><span class="p">,</span>
                             <span class="n">M00</span><span class="o">=</span><span class="n">M00</span><span class="p">,</span>
                             <span class="n">global_phase</span><span class="o">=</span><span class="n">global_phase</span><span class="p">,</span>
                             <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                             <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">select_shape</span><span class="p">(</span><span class="n">obj</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape_var</span><span class="o">=</span><span class="n">new_shape</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="c1"># @_actualize_</span>
<div class="viewcode-block" id="Mueller.retarder_azimuth_ellipticity"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Mueller.retarder_azimuth_ellipticity">[docs]</a>    <span class="k">def</span> <span class="nf">retarder_azimuth_ellipticity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                     <span class="n">R</span><span class="p">,</span>
                                     <span class="n">azimuth</span><span class="p">,</span>
                                     <span class="n">ellipticity</span><span class="p">,</span>
                                     <span class="n">M00</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                     <span class="n">global_phase</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                     <span class="n">length</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                     <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                     <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Method that calculates the most general homogeneous retarder from azimuth and ellipticity of the fast eigenstate. The method calculates first the retardance vector, and uses it to calculate the Mueler matrix.</span>

<span class="sd">        References:</span>
<span class="sd">            &quot;Polarized light and the Mueller Matrix approach&quot;, J. J. Gil, pp 125.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            R (float or numpy.ndarray): [0, pi] Retardance introduced to the slow eigenstate respect to the fast eigenstate.</span>
<span class="sd">            azimuth (float or numpy.ndarray): [0, pi]: Azimuth.</span>
<span class="sd">            ellipticity (float or numpy.ndarray): [-pi/4, pi/4]: Ellipticity angle.</span>
<span class="sd">            M00 (float or numpy.ndarray): Parameter of average intensity. Default: 1.</span>
<span class="sd">            global_phase (float or numpy.ndarray): Global phase introduced by the optical element. Default: 0.</span>
<span class="sd">            length (int): If final object is of size 1, it is stretched to match this size. Default: 1.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (Mueller): Created object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Prepare variables</span>
        <span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">azimuth</span><span class="p">,</span> <span class="n">ellipticity</span><span class="p">),</span> <span class="n">new_shape</span> <span class="o">=</span> <span class="n">prepare_variables</span><span class="p">(</span>
            <span class="nb">vars</span><span class="o">=</span><span class="p">[</span><span class="n">R</span><span class="p">,</span> <span class="n">azimuth</span><span class="p">,</span> <span class="n">ellipticity</span><span class="p">],</span>
            <span class="n">expand</span><span class="o">=</span><span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span>
            <span class="n">give_shape</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># Restrict parameter values to the correct interval</span>
        <span class="n">azimuth</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">azimuth</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Avoid nan values</span>
        <span class="n">azimuth</span> <span class="o">=</span> <span class="n">put_in_limits</span><span class="p">(</span><span class="n">azimuth</span><span class="p">,</span> <span class="s2">&quot;azimuth&quot;</span><span class="p">)</span>
        <span class="n">ellipticity</span> <span class="o">=</span> <span class="n">put_in_limits</span><span class="p">(</span><span class="n">ellipticity</span><span class="p">,</span> <span class="s2">&quot;ellipticity&quot;</span><span class="p">)</span>

        <span class="c1"># Calculate the normalized retardance vector</span>
        <span class="n">Rv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">azimuth</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">ellipticity</span><span class="p">),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">azimuth</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">ellipticity</span><span class="p">),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">ellipticity</span><span class="p">)</span>
        <span class="p">])</span>
        <span class="c1"># Create the object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">retarder_vector</span><span class="p">(</span><span class="n">Rv</span><span class="o">=</span><span class="n">Rv</span><span class="p">,</span>
                             <span class="n">R</span><span class="o">=</span><span class="n">R</span><span class="p">,</span>
                             <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;normalized&#39;</span><span class="p">,</span>
                             <span class="n">M00</span><span class="o">=</span><span class="n">M00</span><span class="p">,</span>
                             <span class="n">global_phase</span><span class="o">=</span><span class="n">global_phase</span><span class="p">,</span>
                             <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                             <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">select_shape</span><span class="p">(</span><span class="n">obj</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape_var</span><span class="o">=</span><span class="n">new_shape</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="c1"># @_actualize_</span>
<div class="viewcode-block" id="Mueller.retarder_vector"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Mueller.retarder_vector">[docs]</a>    <span class="k">def</span> <span class="nf">retarder_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                        <span class="n">Rv</span><span class="p">,</span>
                        <span class="n">R</span><span class="o">=</span><span class="mi">90</span> <span class="o">*</span> <span class="n">degrees</span><span class="p">,</span>
                        <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;normalized&#39;</span><span class="p">,</span>
                        <span class="n">M00</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                        <span class="n">global_phase</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                        <span class="n">length</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                        <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Method that calculates the most general homogeneous retarder from the retardance vector.</span>

<span class="sd">        References:</span>
<span class="sd">            &quot;Polarized light and the Mueller Matrix approach&quot;, J. J. Gil, pp 125.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            Rv (3xN numpy.ndarray): Retardance vector.</span>
<span class="sd">            R (float or numpy.ndarray): [0, pi] Retardance introduced to the slow eigenstate respect to the fast eigenstate. Default: 90 degrees.</span>
<span class="sd">            kind (string): Identifies the type of retardance vector. There are three possibilities: NORMALIZED (also called Pauli vector), STRAIGHT or COMPLETE. Default: &#39;normalized&#39;.</span>
<span class="sd">            M00 (float or numpy.ndarray): Mean transmission coefficient. If different than 1, the object won&#39;t be a pure retarder. Default: 1.</span>
<span class="sd">            global_phase (float or numpy.ndarray): Global phase introduced by the optical element. Default: 0.</span>
<span class="sd">            length (int): If final object is of size 1, it is stretched to match this size. Default: 1.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (Mueller): Created object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Prepare the variables</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">Rv</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">new_shape</span> <span class="o">=</span> <span class="n">prepare_variables_blocks</span><span class="p">(</span><span class="n">Dv</span><span class="o">=</span><span class="n">Rv</span><span class="p">,</span>
                                                          <span class="n">give_shape</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># Choose the right retardance</span>
        <span class="k">if</span> <span class="n">kind</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;complete&#39;</span><span class="p">,</span> <span class="s1">&#39;COMPLETE&#39;</span><span class="p">,</span> <span class="s1">&#39;Complete&#39;</span><span class="p">):</span>
            <span class="c1"># Complete retardance vectors</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Rv</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">aux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">R</span><span class="p">)</span>
            <span class="n">cond</span> <span class="o">=</span> <span class="n">R</span> <span class="o">!=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">cond</span><span class="p">):</span>
                <span class="n">Rv</span><span class="p">[:,</span> <span class="n">cond</span><span class="p">]</span> <span class="o">=</span> <span class="n">Rv</span><span class="p">[:,</span> <span class="n">cond</span><span class="p">]</span> <span class="o">/</span> <span class="n">aux</span><span class="p">[:,</span> <span class="n">cond</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">kind</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;straight&#39;</span><span class="p">,</span> <span class="s1">&#39;STRAIGHT&#39;</span><span class="p">,</span> <span class="s1">&#39;Straight&#39;</span><span class="p">):</span>
            <span class="c1"># Straight retardance vectors</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Rv</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
            <span class="n">aux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">R</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
            <span class="n">cond</span> <span class="o">=</span> <span class="n">R</span> <span class="o">!=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">cond</span><span class="p">):</span>
                <span class="n">Rv</span><span class="p">[:,</span> <span class="n">cond</span><span class="p">]</span> <span class="o">=</span> <span class="n">Rv</span><span class="p">[:,</span> <span class="n">cond</span><span class="p">]</span> <span class="o">/</span> <span class="n">aux</span><span class="p">[:,</span> <span class="n">cond</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Normalized (Pauli) retardance vector</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">put_in_limits</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="s1">&#39;Retardance&#39;</span><span class="p">)</span>
            <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Rv</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">aux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">norm</span><span class="p">)</span>
            <span class="n">cond</span> <span class="o">=</span> <span class="p">(</span><span class="n">norm</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">norm</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">cond</span><span class="p">):</span>
                <span class="n">Rv</span><span class="p">[:,</span> <span class="n">cond</span><span class="p">]</span> <span class="o">=</span> <span class="n">Rv</span><span class="p">[:,</span> <span class="n">cond</span><span class="p">]</span> <span class="o">/</span> <span class="n">aux</span><span class="p">[:,</span> <span class="n">cond</span><span class="p">]</span>
        <span class="c1"># Reshape R</span>
        <span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">M00</span><span class="p">),</span> <span class="n">new_shape2</span> <span class="o">=</span> <span class="n">prepare_variables</span><span class="p">(</span><span class="nb">vars</span><span class="o">=</span><span class="p">[</span><span class="n">R</span><span class="p">,</span> <span class="n">M00</span><span class="p">],</span>
                                                 <span class="n">expand</span><span class="o">=</span><span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">],</span>
                                                 <span class="n">length</span><span class="o">=</span><span class="n">Rv</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                                 <span class="n">give_shape</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">new_shape</span> <span class="o">=</span> <span class="n">take_shape</span><span class="p">((</span><span class="n">new_shape</span><span class="p">,</span> <span class="n">new_shape2</span><span class="p">))</span>
        <span class="c1"># Calculate small m matrix</span>
        <span class="n">sR</span><span class="p">,</span> <span class="n">cR</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">R</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">R</span><span class="p">))</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">cR</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">indI</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">indJ</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="n">m</span><span class="p">[</span><span class="n">indI</span><span class="p">,</span> <span class="n">indJ</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">Rv</span><span class="p">[</span><span class="n">indI</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">Rv</span><span class="p">[</span><span class="n">indJ</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">cR</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">indK</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                    <span class="n">m</span><span class="p">[</span><span class="n">indI</span><span class="p">,</span> <span class="n">indJ</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="n">indI</span><span class="p">,</span> <span class="n">indJ</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> \
                        <span class="n">Eijk</span><span class="p">(</span><span class="n">indI</span><span class="p">,</span> <span class="n">indJ</span><span class="p">,</span> <span class="n">indK</span><span class="p">)</span> <span class="o">*</span> <span class="n">Rv</span><span class="p">[</span><span class="n">indK</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">sR</span>
        <span class="c1"># Create the object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">from_blocks</span><span class="p">(</span><span class="n">Dv</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span>
                         <span class="n">Pv</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span>
                         <span class="n">m</span><span class="o">=</span><span class="n">m</span><span class="p">,</span>
                         <span class="n">M00</span><span class="o">=</span><span class="n">M00</span><span class="p">,</span>
                         <span class="n">global_phase</span><span class="o">=</span><span class="n">global_phase</span><span class="p">,</span>
                         <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">,</span>
                         <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                         <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">select_shape</span><span class="p">(</span><span class="n">obj</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape_var</span><span class="o">=</span><span class="n">new_shape</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="c1"># @_actualize_</span>
<div class="viewcode-block" id="Mueller.diattenuator_retarder_linear"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Mueller.diattenuator_retarder_linear">[docs]</a>    <span class="k">def</span> <span class="nf">diattenuator_retarder_linear</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                     <span class="n">p1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                     <span class="n">p2</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                     <span class="n">Tmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                     <span class="n">Tmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                     <span class="n">R</span><span class="o">=</span><span class="mi">90</span> <span class="o">*</span> <span class="n">degrees</span><span class="p">,</span>
                                     <span class="n">azimuth</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                     <span class="n">global_phase</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                     <span class="n">length</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                     <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                     <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates the Mueller matrices of linear diattenuator retarders with the same eigenstates for diattenuation and retardance.</span>

<span class="sd">        .. math:: M\left(\theta=0\right)=\frac{1}{2}\left[\begin{array}{cccc}</span>
<span class="sd">            p_{1}^{2}+p_{2}^{2} &amp; p_{1}^{2}-p_{2}^{2} &amp; 0 &amp; 0\\</span>
<span class="sd">            p_{1}^{2}-p_{2}^{2} &amp; p_{1}^{2}+p_{2}^{2} &amp; 0 &amp; 0\\</span>
<span class="sd">            0 &amp; 0 &amp; 2p_{1}p_{2}\cos(\varDelta) &amp; 2p_{1}p_{2}\sin(\varDelta)\\</span>
<span class="sd">            0 &amp; 0 &amp; -2p_{1}p_{2}\sin(\varDelta) &amp; 2p_{1}p_{2}\cos(\varDelta)</span>
<span class="sd">            \end{array}\right]</span>

<span class="sd">        References:</span>
<span class="sd">            Handbook of Optics vol 2. 22.16 (Table 1).</span>

<span class="sd">        Parameters:</span>
<span class="sd">            p1 (float or numpy.ndarray): Field transmission of the transmission axis. Default: 1.</span>
<span class="sd">            p2 (float or numpy.ndarray): Field transmission of the attenuation axis. Default: 0.</span>
<span class="sd">            Tmax (float or numpy.ndarray): Maximum transmission. If not None, overrides p1. Default: None.</span>
<span class="sd">            Tmin (float or numpy.ndarray): Minimum transmission. If not None, overrides p2. Default: None.</span>
<span class="sd">            R (float or numpy.ndarray): [0, pi] Retardance introduced to the slow eigenstate respect to the fast eigenstate. Default: 90 degrees.</span>
<span class="sd">            azimuth (float or numpy.ndarray): rotation angle of the high transmission polarizer axis. Default: 0.</span>
<span class="sd">            global_phase (float or numpy.ndarray): Global phase introduced by the optical element. Default: 0.</span>
<span class="sd">            length (int): If final object is of size 1, it is stretched to match this size. Default: 1.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (Mueller): Created object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Use field transmission coefficients</span>
        <span class="k">if</span> <span class="n">Tmax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Tmax</span> <span class="o">=</span> <span class="n">p1</span><span class="o">**</span><span class="mi">2</span>
        <span class="k">if</span> <span class="n">Tmin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Tmin</span> <span class="o">=</span> <span class="n">p2</span><span class="o">**</span><span class="mi">2</span>
        <span class="c1"># Prepare variables</span>
        <span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span>
         <span class="n">azimuth</span><span class="p">),</span> <span class="n">new_shape</span> <span class="o">=</span> <span class="n">prepare_variables</span><span class="p">(</span><span class="nb">vars</span><span class="o">=</span><span class="p">[</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">azimuth</span><span class="p">],</span>
                                                 <span class="n">expand</span><span class="o">=</span><span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">],</span>
                                                 <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">,</span>
                                                 <span class="n">give_shape</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># Calculate intensity transmission coefficients</span>
        <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">Tmax</span> <span class="o">+</span> <span class="n">Tmin</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">Tmax</span> <span class="o">-</span> <span class="n">Tmin</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Tmax</span> <span class="o">*</span> <span class="n">Tmin</span><span class="p">)</span>
        <span class="c1"># Calculate the matrix</span>
        <span class="n">components</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> \
            <span class="p">[</span><span class="n">c</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">R</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[</span><span class="n">c</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">R</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> \
            <span class="p">[</span><span class="o">-</span><span class="n">c</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">R</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[</span><span class="n">c</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">R</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">from_components</span><span class="p">(</span><span class="n">components</span><span class="o">=</span><span class="n">components</span><span class="p">,</span>
                             <span class="n">global_phase</span><span class="o">=</span><span class="n">global_phase</span><span class="p">,</span>
                             <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                             <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">azimuth</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">select_shape</span><span class="p">(</span><span class="n">obj</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape_var</span><span class="o">=</span><span class="n">new_shape</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Mueller.diattenuator_retarder_azimuth_ellipticity"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Mueller.diattenuator_retarder_azimuth_ellipticity">[docs]</a>    <span class="k">def</span> <span class="nf">diattenuator_retarder_azimuth_ellipticity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                                  <span class="n">p1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                                  <span class="n">p2</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                                  <span class="n">Tmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                                  <span class="n">Tmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                                  <span class="n">R</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                                  <span class="n">azimuth</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                                  <span class="n">ellipticity</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                                  <span class="n">global_phase</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                                  <span class="n">length</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                                  <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                                  <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates the most general homogenous diattenuator retarder from the azimuth and ellipticity of the fast eigenstate.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            p1 (float or numpy.ndarray): Field transmission of the fast axis. Default: 1.</span>
<span class="sd">            p2 (float or numpy.ndarray): Electric field transmission coefficient of the extinction eigenstate. Default: 0.</span>
<span class="sd">            Tmax (float or numpy.ndarray): Maximum transmission. If not None, overrides p1. Default: None.</span>
<span class="sd">            Tmin (float or numpy.ndarray): Minimum transmission. If not None, overrides p2. Default: None.</span>
<span class="sd">            R (float or numpy.ndarray): Retardance. Default: 0.</span>
<span class="sd">            azimuth (float or numpy.ndarray): rotation angle of the high transmission polarizer axis. Default: 0.</span>
<span class="sd">            ellipticity (float): [-pi/4, pi/]: Ellipticity angle.  Default: 0.</span>
<span class="sd">            global_phase (float or numpy.ndarray): Global phase introduced by the optical element. Default: 0.</span>
<span class="sd">            length (int): If final object is of size 1, it is stretched to match this size. Default: 1.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (Mueller): Created object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Use field transmission coefficients</span>
        <span class="k">if</span> <span class="n">Tmax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">p1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Tmax</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">Tmin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">p2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Tmin</span><span class="p">)</span>
        <span class="c1"># Prepare variables</span>
        <span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span>
         <span class="n">azimuth</span><span class="p">,</span> <span class="n">ellipticity</span><span class="p">),</span> <span class="n">new_shape</span> <span class="o">=</span> <span class="n">prepare_variables</span><span class="p">(</span><span class="nb">vars</span><span class="o">=</span><span class="p">[</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">azimuth</span><span class="p">,</span> <span class="n">ellipticity</span><span class="p">],</span>
                                                 <span class="n">expand</span><span class="o">=</span><span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">],</span>
                                                 <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">,</span>
                                                 <span class="n">give_shape</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># Restrict retardance between 0 and 360 degrees</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">put_in_limits</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="s2">&quot;delay&quot;</span><span class="p">,</span> <span class="n">out_number</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># Create the two objects</span>
        <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="n">E1</span> <span class="o">=</span> <span class="n">Mueller</span><span class="p">()</span><span class="o">.</span><span class="n">diattenuator_azimuth_ellipticity</span><span class="p">(</span><span class="n">p1</span><span class="o">=</span><span class="n">p1</span><span class="p">,</span>
                                            <span class="n">p2</span><span class="o">=</span><span class="n">p2</span><span class="p">,</span>
                                            <span class="n">azimuth</span><span class="o">=</span><span class="n">azimuth</span><span class="p">,</span>
                                            <span class="n">ellipticity</span><span class="o">=</span><span class="n">ellipticity</span><span class="p">,</span>
                                            <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                            <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span>
                                            <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">)</span>
        <span class="c1"># Orthogonal state for R &gt; 180ยบ</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">R</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="k">if</span> <span class="n">cond</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">azimuth</span><span class="p">[</span><span class="n">cond</span><span class="p">]</span> <span class="o">=</span> <span class="n">azimuth</span><span class="p">[</span><span class="n">cond</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span>
            <span class="n">ellipticity</span><span class="p">[</span><span class="n">cond</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">ellipticity</span><span class="p">[</span><span class="n">cond</span><span class="p">]</span>
        <span class="n">E2</span> <span class="o">=</span> <span class="n">Mueller</span><span class="p">()</span><span class="o">.</span><span class="n">retarder_azimuth_ellipticity</span><span class="p">(</span><span class="n">R</span><span class="o">=</span><span class="n">R</span><span class="p">,</span>
                                        <span class="n">azimuth</span><span class="o">=</span><span class="n">azimuth</span><span class="p">,</span>
                                        <span class="n">ellipticity</span><span class="o">=</span><span class="n">ellipticity</span><span class="p">,</span>
                                        <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                        <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span>
                                        <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">)</span>
        <span class="bp">self</span> <span class="o">=</span> <span class="n">E1</span> <span class="o">*</span> <span class="n">E2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Mueller.diattenuator_retarder_charac_angles"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Mueller.diattenuator_retarder_charac_angles">[docs]</a>    <span class="k">def</span> <span class="nf">diattenuator_retarder_charac_angles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                            <span class="n">p1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                            <span class="n">p2</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                            <span class="n">Tmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                            <span class="n">Tmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                            <span class="n">R</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                            <span class="n">alpha</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                            <span class="n">delay</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                            <span class="n">global_phase</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                            <span class="n">length</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                            <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                            <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates the most general homogenous diattenuator retarder from the characteristic angles of the fast eigenstate.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            p1 (float or numpy.ndarray): Field transmission of the fast axis. Default: 1.</span>
<span class="sd">            p2 (float or numpy.ndarray): Electric field transmission coefficient of the extinction eigenstate. Default: 0.</span>
<span class="sd">            Tmax (float or numpy.ndarray): Maximum transmission. If not None, overrides p1. Default: None.</span>
<span class="sd">            Tmin (float or numpy.ndarray): Minimum transmission. If not None, overrides p2. Default: None.</span>
<span class="sd">            R (float or numpy.ndarray): Retardance. Default: 0.</span>
<span class="sd">            alpha (float or numpy.ndarray): [0, pi/2]: tan(alpha) is the ratio between field amplitudes of X and Y components. Default: 0.</span>
<span class="sd">            delay (float or numpy.ndarray): [0, 2*pi]: phase difference between X and Y field components. Default: 0.</span>
<span class="sd">            length (int): If final object is of size 1, it is stretched to match this size. Default: 1.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (Mueller): Created object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Use field transmission coefficients</span>
        <span class="k">if</span> <span class="n">Tmax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">p1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Tmax</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">Tmin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">p2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Tmin</span><span class="p">)</span>
        <span class="c1"># Prepare variables</span>
        <span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span>
         <span class="n">alpha</span><span class="p">,</span> <span class="n">delay</span><span class="p">),</span> <span class="n">new_shape</span> <span class="o">=</span> <span class="n">prepare_variables</span><span class="p">(</span><span class="nb">vars</span><span class="o">=</span><span class="p">[</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">delay</span><span class="p">],</span>
                                                 <span class="n">expand</span><span class="o">=</span><span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">],</span>
                                                 <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">,</span>
                                                 <span class="n">give_shape</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># Restrict retardance between 0 and 360 degrees</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">put_in_limits</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="s2">&quot;delay&quot;</span><span class="p">,</span> <span class="n">out_number</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># Create the two objects</span>
        <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="n">E1</span> <span class="o">=</span> <span class="n">Mueller</span><span class="p">()</span><span class="o">.</span><span class="n">diattenuator_charac_angles</span><span class="p">(</span><span class="n">p1</span><span class="o">=</span><span class="n">p1</span><span class="p">,</span>
                                      <span class="n">p2</span><span class="o">=</span><span class="n">p2</span><span class="p">,</span>
                                      <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
                                      <span class="n">delay</span><span class="o">=</span><span class="n">delay</span><span class="p">,</span>
                                      <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                      <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span>
                                      <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">)</span>
        <span class="c1"># Orthogonal state for R &gt; 180ยบ</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">R</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="k">if</span> <span class="n">cond</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">alpha</span><span class="p">[</span><span class="n">cond</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">[</span><span class="n">cond</span><span class="p">]</span>
            <span class="n">delay</span><span class="p">[</span><span class="n">cond</span><span class="p">]</span> <span class="o">=</span> <span class="n">delay</span><span class="p">[</span><span class="n">cond</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="n">E2</span> <span class="o">=</span> <span class="n">Mueller</span><span class="p">()</span><span class="o">.</span><span class="n">retarder_charac_angles</span><span class="p">(</span><span class="n">R</span><span class="o">=</span><span class="n">R</span><span class="p">,</span>
                                  <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
                                  <span class="n">delay</span><span class="o">=</span><span class="n">delay</span><span class="p">,</span>
                                  <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                  <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span>
                                  <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">)</span>
        <span class="bp">self</span> <span class="o">=</span> <span class="n">E1</span> <span class="o">*</span> <span class="n">E2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">return</span> <span class="bp">self</span></div>
    <span class="c1">#</span>
    <span class="c1"># def diattenuator_retarder_azimuth_ellipticity(self,</span>
    <span class="c1">#                                               p1=1,</span>
    <span class="c1">#                                               p2=1,</span>
    <span class="c1">#                                               Tmax=None,</span>
    <span class="c1">#                                               Tmin=None,</span>
    <span class="c1">#                                               R=0,</span>
    <span class="c1">#                                               azimuth=0,</span>
    <span class="c1">#                                               ellipticity=0,</span>
    <span class="c1">#                                               global_phase=0,</span>
    <span class="c1">#                                               length=1,</span>
    <span class="c1">#                                               shape_like=None,</span>
    <span class="c1">#                                               shape=None):</span>
    <span class="c1">#     &quot;&quot;&quot;Creates the most general homogenous diattenuator retarder from the azimuth and ellipticity of the fast eigenstate.</span>
    <span class="c1">#</span>
    <span class="c1">#     Parameters:</span>
    <span class="c1">#         p1 (float or numpy.ndarray): Field transmission of the fast axis. Default: 1.</span>
    <span class="c1">#         p2 (float or numpy.ndarray): Electric field transmission coefficient of the extinction eigenstate. Default: 0.</span>
    <span class="c1">#         Tmax (float or numpy.ndarray): Maximum transmission. If not None, overrides p1. Default: None.</span>
    <span class="c1">#         Tmax (float or numpy.ndarray): Minimum transmission. If not None, overrides p1. Default: None.</span>
    <span class="c1">#         R (float or numpy.ndarray): Retardance. Default: 0.</span>
    <span class="c1">#         azimuth (float or numpy.ndarray): rotation angle of the high transmission polarizer axis. Default: 0.</span>
    <span class="c1">#         ellipticity (float): [-pi/4, pi/]: Ellipticity angle.  Default: 0.</span>
    <span class="c1">#         global_phase (float or numpy.ndarray): Global phase introduced by the optical element. Default: 0.</span>
    <span class="c1">#         length (int): If final object is of size 1, it is stretched to match this size. Default: 1.</span>
    <span class="c1">#         shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
    <span class="c1">#         shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>
    <span class="c1">#</span>
    <span class="c1">#     Returns:</span>
    <span class="c1">#         (Mueller): Created object.</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     # Use field transmission coefficients</span>
    <span class="c1">#     if Tmax is not None:</span>
    <span class="c1">#         p1 = np.sqrt(Tmax)</span>
    <span class="c1">#     if Tmin is not None:</span>
    <span class="c1">#         p2 = np.sqrt(Tmin)</span>
    <span class="c1">#     # Create the two objects</span>
    <span class="c1">#     E1 = Mueller()</span>
    <span class="c1">#     E1.diattenuator_azimuth_ellipticity(p1=p1,</span>
    <span class="c1">#                                         p2=p2,</span>
    <span class="c1">#                                         azimuth=azimuth,</span>
    <span class="c1">#                                         ellipticity=ellipticity,</span>
    <span class="c1">#                                         shape=shape,</span>
    <span class="c1">#                                         shape_like=shape_like,</span>
    <span class="c1">#                                         length=length)</span>
    <span class="c1">#     E2 = Mueller()</span>
    <span class="c1">#     E2.retarder_azimuth_ellipticity(R=R,</span>
    <span class="c1">#                                     azimuth=azimuth,</span>
    <span class="c1">#                                     ellipticity=ellipticity,</span>
    <span class="c1">#                                     shape=shape,</span>
    <span class="c1">#                                     shape_like=shape_like,</span>
    <span class="c1">#                                     length=length)</span>
    <span class="c1">#     # Multiply and extract</span>
    <span class="c1">#     new_obj = E1 * E2</span>
    <span class="c1">#     self.from_matrix(new_obj.M)</span>
    <span class="c1">#     self.shape, _ = new_obj.shape, new_obj.ndim</span>
    <span class="c1">#     # return self</span>
    <span class="c1">#</span>
    <span class="c1"># def diattenuator_retarder_charac_angles(self,</span>
    <span class="c1">#                                        p1=1,</span>
    <span class="c1">#                                        p2=1,</span>
    <span class="c1">#                                        Tmax=None,</span>
    <span class="c1">#                                        Tmin=None,</span>
    <span class="c1">#                                        R=0,</span>
    <span class="c1">#                                        alpha=0,</span>
    <span class="c1">#                                        delay=0,</span>
    <span class="c1">#                                        global_phase=0,</span>
    <span class="c1">#                                        length=1,</span>
    <span class="c1">#                                        shape_like=None,</span>
    <span class="c1">#                                        shape=None):</span>
    <span class="c1">#     &quot;&quot;&quot;Creates the most general homogenous diattenuator retarder from the characteristic angles of the fast eigenstate.</span>
    <span class="c1">#</span>
    <span class="c1">#     Parameters:</span>
    <span class="c1">#         p1 (float or numpy.ndarray): Field transmission of the fast axis. Default: 1.</span>
    <span class="c1">#         p2 (float or numpy.ndarray): Electric field transmission coefficient of the extinction eigenstate. Default: 0.</span>
    <span class="c1">#         Tmax (float or numpy.ndarray): Maximum transmission. If not None, overrides p1. Default: None.</span>
    <span class="c1">#         Tmax (float or numpy.ndarray): Minimum transmission. If not None, overrides p1. Default: None.</span>
    <span class="c1">#         R (float or numpy.ndarray): Retardance. Default: 0.</span>
    <span class="c1">#         alpha (float or numpy.ndarray): [0, pi/2]: tan(alpha) is the ratio between field amplitudes of X and Y components. Default: 0.</span>
    <span class="c1">#         delay (float or numpy.ndarray): [0, 2*pi]: phase difference between X and Y field components. Default: 0.</span>
    <span class="c1">#         length (int): If final object is of size 1, it is stretched to match this size. Default: 1.</span>
    <span class="c1">#         shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
    <span class="c1">#         shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>
    <span class="c1">#</span>
    <span class="c1">#     Returns:</span>
    <span class="c1">#         (Mueller): Created object.</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     # Use field transmission coefficients</span>
    <span class="c1">#     if Tmax is not None:</span>
    <span class="c1">#         p1 = np.sqrt(Tmax)</span>
    <span class="c1">#     if Tmin is not None:</span>
    <span class="c1">#         p2 = np.sqrt(Tmin)</span>
    <span class="c1">#     # Create the two objects</span>
    <span class="c1">#     E1, E2 = create_Mueller(N=2)</span>
    <span class="c1">#     E1.diattenuator_charac_angles(p1=p1,</span>
    <span class="c1">#                                  p2=p2,</span>
    <span class="c1">#                                  alpha=alpha,</span>
    <span class="c1">#                                  delay=delay,</span>
    <span class="c1">#                                  shape=shape,</span>
    <span class="c1">#                                  shape_like=shape_like,</span>
    <span class="c1">#                                  length=length)</span>
    <span class="c1">#     E2.retarder_charac_angles(R=R,</span>
    <span class="c1">#                              alpha=alpha,</span>
    <span class="c1">#                              delay=delay,</span>
    <span class="c1">#                              shape=shape,</span>
    <span class="c1">#                              shape_like=shape_like,</span>
    <span class="c1">#                              length=length)</span>
    <span class="c1">#     # Multiply and extract</span>
    <span class="c1">#     new_obj = E1 * E2</span>
    <span class="c1">#     self.from_matrix(new_obj.M)</span>
    <span class="c1">#     self.shape, _ = new_obj.shape, new_obj.ndim</span>
    <span class="c1">#     return self</span>

<div class="viewcode-block" id="Mueller.general_eigenstates"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Mueller.general_eigenstates">[docs]</a>    <span class="k">def</span> <span class="nf">general_eigenstates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                            <span class="n">E1</span><span class="p">,</span>
                            <span class="n">E2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">p1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                            <span class="n">p2</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                            <span class="n">Tmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">Tmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">R</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                            <span class="n">global_phase</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                            <span class="n">length</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                            <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates the most general pure optical element from its eigenstates.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            E1 (Jones_vector): First eigenstate.</span>
<span class="sd">            E2 (Jones_vector): Second eigenstate. If None, E2 is taken as the perpendicular state to E1, so the optical object is homogenous. Default: None</span>
<span class="sd">            p1 (float or numpy.ndarray): Field transmission of the fast axis. Default: 1.</span>
<span class="sd">            p2 (float or numpy.ndarray): Electric field transmission coefficient of the extinction eigenstate. Default: 0.</span>
<span class="sd">            Tmax (float or numpy.ndarray): Maximum transmission. If not None, overrides p1. Default: None.</span>
<span class="sd">            Tmin (float or numpy.ndarray): Minimum transmission. If not None, overrides p2. Default: None.</span>
<span class="sd">            R (float or numpy.ndarray): Retardance. Default: 0.</span>
<span class="sd">            global_phase (float or numpy.ndarray): Global phase introduced by the optical element. Default: 0.</span>
<span class="sd">            length (int): If final object is of size 1, it is stretched to match this size. Default: 1.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (Jones_matrix): Created object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Use field transmission coefficients</span>
        <span class="k">if</span> <span class="n">Tmax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">p1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Tmax</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">Tmin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">p2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Tmin</span><span class="p">)</span>
        <span class="c1"># Main calculation</span>
        <span class="k">if</span> <span class="n">E2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Simple case: homogenous case</span>
            <span class="n">az</span><span class="p">,</span> <span class="n">el</span> <span class="o">=</span> <span class="n">E1</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">azimuth_ellipticity</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">diattenuator_retarder_azimuth_ellipticity</span><span class="p">(</span>
                <span class="n">p1</span><span class="o">=</span><span class="n">p1</span><span class="p">,</span>
                <span class="n">p2</span><span class="o">=</span><span class="n">p2</span><span class="p">,</span>
                <span class="n">R</span><span class="o">=</span><span class="n">R</span><span class="p">,</span>
                <span class="n">azimuth</span><span class="o">=</span><span class="n">az</span><span class="p">,</span>
                <span class="n">ellipticity</span><span class="o">=</span><span class="n">el</span><span class="p">,</span>
                <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span>
                <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">,</span>
                <span class="n">global_phase</span><span class="o">=</span><span class="n">global_phase</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Complicated case: inhomogeneous case. It must be done from Jones</span>
            <span class="n">E</span> <span class="o">=</span> <span class="n">Jones_vector</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">E</span><span class="o">.</span><span class="n">general_eigenstates</span><span class="p">(</span><span class="n">E1</span><span class="o">=</span><span class="n">E1</span><span class="p">,</span>
                                  <span class="n">E2</span><span class="o">=</span><span class="n">E2</span><span class="p">,</span>
                                  <span class="n">p1</span><span class="o">=</span><span class="n">p1</span><span class="p">,</span>
                                  <span class="n">p2</span><span class="o">=</span><span class="n">p2</span><span class="p">,</span>
                                  <span class="n">R</span><span class="o">=</span><span class="n">R</span><span class="p">,</span>
                                  <span class="n">global_phase</span><span class="o">=</span><span class="n">global_phase</span><span class="p">,</span>
                                  <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">,</span>
                                  <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span>
                                  <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">from_Jones</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div></div>



<span class="c1">########################################################################</span>
<span class="c1"># Parameters</span>
<span class="c1">########################################################################</span>


<div class="viewcode-block" id="Parameters_Mueller"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Parameters_Mueller">[docs]</a><span class="k">class</span> <span class="nc">Parameters_Mueller</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class for Mueller Matrix Parameters.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        self.parent (Mueller_matrix): Parent object.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;print all parameters</span>
<span class="sd">        TODO: print all as mueller_matrix&quot;&quot;&quot;</span>
        <span class="nb">dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_all</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">draw</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="s1">&#39;&#39;</span>

<div class="viewcode-block" id="Parameters_Mueller.get_all"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Parameters_Mueller.get_all">[docs]</a>    <span class="k">def</span> <span class="nf">get_all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">draw</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates a dictionary with all the parameters of Mueller matrix.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            verbose (bool): If True, print all parameters. Default: False.</span>
<span class="sd">            draw (bool): If True, draw all plots/images of the parameters. Default: False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dict_params</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">dict_params</span><span class="p">[</span><span class="s1">&#39;Mean transmission&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mean_transmission</span><span class="p">(</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
        <span class="n">dict_params</span><span class="p">[</span><span class="s1">&#39;Inhomogeneity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inhomogeneity</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                                                               <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
        <span class="n">dict_params</span><span class="p">[</span><span class="s1">&#39;Diattenuation&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">diattenuation</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                                                               <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
        <span class="n">dict_params</span><span class="p">[</span><span class="s1">&#39;Linear diattenuation&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">diattenuation_linear</span><span class="p">(</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
        <span class="n">dict_params</span><span class="p">[</span>
            <span class="s1">&#39;Circular diattenuation&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">diattenuation_circular</span><span class="p">(</span>
                <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
        <span class="n">dict_params</span><span class="p">[</span><span class="s1">&#39;Polarizance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">polarizance</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                                                           <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
        <span class="n">dict_params</span><span class="p">[</span><span class="s1">&#39;Linear polarizance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">polarizance_linear</span><span class="p">(</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
        <span class="n">dict_params</span><span class="p">[</span><span class="s1">&#39;Circular polarizance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">polarizance_circular</span><span class="p">(</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
        <span class="n">dict_params</span><span class="p">[</span><span class="s1">&#39;Spheric purity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spheric_purity</span><span class="p">(</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
        <span class="n">dict_params</span><span class="p">[</span><span class="s1">&#39;Retardance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">retardance</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                                                         <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
        <span class="n">dict_params</span><span class="p">[</span><span class="s1">&#39;Polarimetric purity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">polarimetric_purity</span><span class="p">(</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
        <span class="n">dict_params</span><span class="p">[</span><span class="s1">&#39;Depolarization degree&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">depolarization_index</span><span class="p">(</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
        <span class="n">dict_params</span><span class="p">[</span>
            <span class="s1">&#39;Polarimetric purity indices&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">polarimetric_purity_indices</span><span class="p">(</span>
                <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
        <span class="n">dict_params</span><span class="p">[</span><span class="s1">&#39;Transmissions&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transmissions</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span>
                                                               <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                                                               <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
        <span class="n">dict_params</span><span class="p">[</span><span class="s1">&#39;Retardance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">retardance</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                                                         <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
        <span class="n">dict_params</span><span class="p">[</span><span class="s1">&#39;Eigenstates&#39;</span><span class="p">],</span> <span class="n">dict_params</span><span class="p">[</span>
            <span class="s1">&#39;Eigenvectors&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
        <span class="n">dict_params</span><span class="p">[</span><span class="s1">&#39;Determinant&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
        <span class="n">dict_params</span><span class="p">[</span><span class="s1">&#39;Trace&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
        <span class="n">dict_params</span><span class="p">[</span><span class="s1">&#39;Norm&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dict_params</span></div>

<div class="viewcode-block" id="Parameters_Mueller.matrix"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Parameters_Mueller.matrix">[docs]</a>    <span class="k">def</span> <span class="nf">matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the numpy array of Mueller matrices.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>


<span class="sd">        Returns:</span>
<span class="sd">            (numpy.array) 4x4xN numpy array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">shape</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">select_shape</span><span class="p">(</span><span class="n">obj</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span>
                                <span class="n">shape_fun</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">shape</span><span class="p">))</span>
            <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">M</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">M</span>
        <span class="k">return</span> <span class="n">M</span></div>

<div class="viewcode-block" id="Parameters_Mueller.components"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Parameters_Mueller.components">[docs]</a>    <span class="k">def</span> <span class="nf">components</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                   <span class="n">out_number</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                   <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                   <span class="n">draw</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Extracts the matrix components of the Mueller matrix.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            out_number (bool): If True and the result is a 1x1 array, return a number instead. Default: True.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>
<span class="sd">            verbose (bool): If True prints the parameter. Default: False.</span>
<span class="sd">            draw (bool): If True and the object is a 1D or 2D, plot it. Default: False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            M00 (numpy.ndarray): array of the 0, 0 element of the matrix.</span>
<span class="sd">            M01 (numpy.ndarray): array of the 0, 1 element of the matrix.</span>
<span class="sd">            ...</span>
<span class="sd">            M32 (numpy.ndarray): array of the 3, 2 element of the matrix.</span>
<span class="sd">            M33 (numpy.ndarray): array of the 3, 3 element of the matrix.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Calculate the components</span>
        <span class="n">components</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ind1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">ind2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
                <span class="n">comp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">ind1</span><span class="p">,</span> <span class="n">ind2</span><span class="p">,</span> <span class="p">:]</span>
                <span class="k">if</span> <span class="n">out_number</span> <span class="ow">and</span> <span class="n">comp</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">comp</span> <span class="o">=</span> <span class="n">comp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">components</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">comp</span><span class="p">)</span>
        <span class="c1"># Reshape if required</span>
        <span class="n">components</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">(</span><span class="n">components</span><span class="p">,</span>
                             <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span>
                             <span class="n">shape_fun</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                             <span class="n">obj</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>
        <span class="c1"># Print the result if required</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">draw</span><span class="p">:</span>
            <span class="n">heading</span> <span class="o">=</span> <span class="s1">&#39;The matrix components of </span><span class="si">{}</span><span class="s1"> are:&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">title</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;M00&#39;</span><span class="p">,</span> <span class="s1">&#39;M01&#39;</span><span class="p">,</span> <span class="s1">&#39;M02&#39;</span><span class="p">,</span> <span class="s1">&#39;M03&#39;</span><span class="p">,</span> <span class="s1">&#39;M10&#39;</span><span class="p">,</span> <span class="s1">&#39;M11&#39;</span><span class="p">,</span> <span class="s1">&#39;M12&#39;</span><span class="p">,</span> <span class="s1">&#39;M13&#39;</span><span class="p">,</span>
                     <span class="s1">&#39;M20&#39;</span><span class="p">,</span> <span class="s1">&#39;M21&#39;</span><span class="p">,</span> <span class="s1">&#39;M22&#39;</span><span class="p">,</span> <span class="s1">&#39;M23&#39;</span><span class="p">,</span> <span class="s1">&#39;M30&#39;</span><span class="p">,</span> <span class="s1">&#39;M31&#39;</span><span class="p">,</span> <span class="s1">&#39;M32&#39;</span><span class="p">,</span> <span class="s1">&#39;M33&#39;</span><span class="p">)</span>
            <span class="n">PrintParam</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="n">components</span><span class="p">,</span>
                       <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                       <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span>
                       <span class="n">heading</span><span class="o">=</span><span class="n">heading</span><span class="p">,</span>
                       <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                       <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
        <span class="c1"># Return</span>
        <span class="k">return</span> <span class="n">components</span></div>

<div class="viewcode-block" id="Parameters_Mueller.mean_transmission"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Parameters_Mueller.mean_transmission">[docs]</a>    <span class="k">def</span> <span class="nf">mean_transmission</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                          <span class="n">out_number</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                          <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                          <span class="n">draw</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gives the mean transmission coefficients.</span>

<span class="sd">        References:</span>
<span class="sd">            J.J. Gil, R. Ossikovsky &quot;Polarized light and the Mueller Matrix approach&quot;, CRC Press (2016)</span>

<span class="sd">        Parameters:</span>
<span class="sd">            out_number (bool): If True and the result is a 1x1 array, return a number instead. Default: True.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>
<span class="sd">            verbose (bool): if True prints the parameter. Default: False.</span>
<span class="sd">            draw (bool): If True and the object is a 1D or 2D, plot it. Default: False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (numpy.ndarray or float): Result.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">M00</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
        <span class="c1"># If the result is a number and the user asks for it, return a float</span>
        <span class="k">if</span> <span class="n">out_number</span> <span class="ow">and</span> <span class="n">M00</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">M00</span> <span class="o">=</span> <span class="n">M00</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Reshape if neccessary</span>
        <span class="n">M00</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">([</span><span class="n">M00</span><span class="p">],</span>
                      <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span>
                      <span class="n">shape_fun</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                      <span class="n">obj</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>
        <span class="c1"># Print the result if required</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">draw</span><span class="p">:</span>
            <span class="n">heading</span> <span class="o">=</span> <span class="s1">&#39;The mean transmission of </span><span class="si">{}</span><span class="s1"> is:&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">PrintParam</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="n">M00</span><span class="p">,</span>
                       <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                       <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Mean transmission&#39;</span><span class="p">,</span>
                       <span class="n">heading</span><span class="o">=</span><span class="n">heading</span><span class="p">,</span>
                       <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                       <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">M00</span></div>

<div class="viewcode-block" id="Parameters_Mueller.diattenuation_vector"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Parameters_Mueller.diattenuation_vector">[docs]</a>    <span class="k">def</span> <span class="nf">diattenuation_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                             <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                             <span class="n">as_Stokes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                             <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                             <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                             <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                             <span class="n">draw</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gives the diattenuation vector. The first dimension will always have size 3.</span>

<span class="sd">        References:</span>
<span class="sd">            J.J. Gil, R. Ossikovsky &quot;Polarized light and the Mueller Matrix approach&quot;, CRC Press (2016)</span>

<span class="sd">        Parameters:</span>
<span class="sd">            normalize (bool): If True, normalizes the diattenuation vector to M00. Default: True.</span>
<span class="sd">            as_Stokes (bool): If True, the vectors are inside a normlized Stokes object. Default: False.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>
<span class="sd">            verbose (bool): if True prints the parameter. Default: False.</span>
<span class="sd">            draw (bool): If True and the object is a 1D or 2D, plot it. Default: False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (numpy.ndarray or Stokes): Result.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Extract components</span>
        <span class="c1"># TODO: No idea why deepcopy is required here</span>
        <span class="n">comp</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                            <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span>
                            <span class="n">out_number</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
        <span class="c1"># Normalize (avoiding dividing by 0)</span>
        <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
            <span class="n">cond</span> <span class="o">=</span> <span class="n">comp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">tol_default</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">cond</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">):</span>
                    <span class="n">comp</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span> <span class="o">=</span> <span class="n">comp</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span> <span class="o">/</span> <span class="n">comp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span>
        <span class="c1"># Transform in Stokes if needed</span>
        <span class="k">if</span> <span class="n">as_Stokes</span><span class="p">:</span>
            <span class="n">S0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">comp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">comp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">comp</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">Stokes</span><span class="p">()</span><span class="o">.</span><span class="n">from_components</span><span class="p">([</span><span class="n">S0</span><span class="p">,</span> <span class="n">comp</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">comp</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">comp</span><span class="p">[</span><span class="mi">3</span><span class="p">]])</span>
            <span class="n">D</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">comp</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">comp</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">comp</span><span class="p">[</span><span class="mi">3</span><span class="p">]])</span>
        <span class="c1"># Print the result if required</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">draw</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">as_Stokes</span><span class="p">:</span>
                <span class="n">D</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">components</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">heading</span> <span class="o">=</span> <span class="s1">&#39;The diattenuation vector of </span><span class="si">{}</span><span class="s1"> is:&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="n">title</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;D[0]&#39;</span><span class="p">,</span> <span class="s1">&#39;D[1]&#39;</span><span class="p">,</span> <span class="s1">&#39;D[2]&#39;</span><span class="p">)</span>
                <span class="n">PrintParam</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="p">[</span><span class="n">D</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">D</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">D</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]],</span>
                           <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                           <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span>
                           <span class="n">heading</span><span class="o">=</span><span class="n">heading</span><span class="p">,</span>
                           <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                           <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">D</span></div>

<div class="viewcode-block" id="Parameters_Mueller.polarizance_vector"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Parameters_Mueller.polarizance_vector">[docs]</a>    <span class="k">def</span> <span class="nf">polarizance_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                           <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                           <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                           <span class="n">draw</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gives the polarizance vector. The first dimension will always have size 3.</span>

<span class="sd">        References:</span>
<span class="sd">            J.J. Gil, R. Ossikovsky &quot;Polarized light and the Mueller Matrix approach&quot;, CRC Press (2016)</span>

<span class="sd">        Parameters:</span>
<span class="sd">            normalize (bool): If True, normalizes the diattenuation vector to M00. Default: True.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>
<span class="sd">            verbose (bool): If True prints the parameter. Default: False.</span>
<span class="sd">            draw (bool): If True and the object is a 1D or 2D, plot it. Default: False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (numpy.ndarray): Result.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Extract components</span>
        <span class="c1"># TODO: No idea why deepcopy is required here</span>
        <span class="n">comp</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                            <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span>
                            <span class="n">out_number</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
        <span class="c1"># Normalize (avoiding dividing by 0)</span>
        <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
            <span class="n">cond</span> <span class="o">=</span> <span class="n">comp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">tol_default</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">cond</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">12</span><span class="p">):</span>
                    <span class="n">comp</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span> <span class="o">=</span> <span class="n">comp</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span> <span class="o">/</span> <span class="n">comp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">comp</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">comp</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span> <span class="n">comp</span><span class="p">[</span><span class="mi">12</span><span class="p">]])</span>
        <span class="c1"># Print the result if required</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">draw</span><span class="p">:</span>
            <span class="n">heading</span> <span class="o">=</span> <span class="s1">&#39;The polarizance vector of </span><span class="si">{}</span><span class="s1"> is:&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">title</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;P[0]&#39;</span><span class="p">,</span> <span class="s1">&#39;P[1]&#39;</span><span class="p">,</span> <span class="s1">&#39;P[2]&#39;</span><span class="p">)</span>
            <span class="n">PrintParam</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="p">[</span><span class="n">P</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">P</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">P</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]],</span>
                       <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                       <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span>
                       <span class="n">heading</span><span class="o">=</span><span class="n">heading</span><span class="p">,</span>
                       <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                       <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">P</span></div>

<div class="viewcode-block" id="Parameters_Mueller.small_matrix"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Parameters_Mueller.small_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">small_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                     <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                     <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                     <span class="n">draw</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gives the small matrix m. The first two dimensions will always have size 3.</span>

<span class="sd">        References:</span>
<span class="sd">            J.J. Gil, R. Ossikovsky &quot;Polarized light and the Mueller Matrix approach&quot;, CRC Press (2016)</span>

<span class="sd">        Parameters:</span>
<span class="sd">            normalize (bool): If True, normalizes the diattenuation vector to M00. Default: True.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>
<span class="sd">            verbose (bool): If True prints the parameter. Default: False.</span>
<span class="sd">            draw (bool): If True and the object is a 1D or 2D, plot it. Default: False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (numpy.ndarray): Result.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Extract components</span>
        <span class="c1"># TODO: No idea why deepcopy is required here</span>
        <span class="n">comp</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                            <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span>
                            <span class="n">out_number</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
        <span class="c1"># Normalize (avoiding dividing by 0)</span>
        <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
            <span class="n">cond</span> <span class="o">=</span> <span class="n">comp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">tol_default</span>
            <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">15</span><span class="p">):</span>
                <span class="n">comp</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span> <span class="o">=</span> <span class="n">comp</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span> <span class="o">/</span> <span class="n">comp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">comp</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">comp</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="n">comp</span><span class="p">[</span><span class="mi">7</span><span class="p">]],</span>
                      <span class="p">[</span><span class="n">comp</span><span class="p">[</span><span class="mi">9</span><span class="p">],</span> <span class="n">comp</span><span class="p">[</span><span class="mi">10</span><span class="p">],</span> <span class="n">comp</span><span class="p">[</span><span class="mi">11</span><span class="p">]],</span>
                      <span class="p">[</span><span class="n">comp</span><span class="p">[</span><span class="mi">13</span><span class="p">],</span> <span class="n">comp</span><span class="p">[</span><span class="mi">14</span><span class="p">],</span> <span class="n">comp</span><span class="p">[</span><span class="mi">15</span><span class="p">]]])</span>
        <span class="c1"># Print the result if required</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">draw</span><span class="p">:</span>
            <span class="n">heading</span> <span class="o">=</span> <span class="s1">&#39;The small matrix of </span><span class="si">{}</span><span class="s1"> is:&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">title</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;m[0,0]&#39;</span><span class="p">,</span> <span class="s1">&#39;m[0,1]&#39;</span><span class="p">,</span> <span class="s1">&#39;m[0,2]&#39;</span><span class="p">,</span> <span class="s1">&#39;m[1,0]&#39;</span><span class="p">,</span> <span class="s1">&#39;m[1,1]&#39;</span><span class="p">,</span>
                     <span class="s1">&#39;m[1,2]&#39;</span><span class="p">,</span> <span class="s1">&#39;m[2,0]&#39;</span><span class="p">,</span> <span class="s1">&#39;m[2,1]&#39;</span><span class="p">,</span> <span class="s1">&#39;m[2,2]&#39;</span><span class="p">)</span>
            <span class="n">PrintParam</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="p">[</span>
                <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">:],</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:],</span>
                <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">:],</span> <span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">:]</span>
            <span class="p">],</span>
                       <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                       <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span>
                       <span class="n">heading</span><span class="o">=</span><span class="n">heading</span><span class="p">,</span>
                       <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                       <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">m</span></div>

<div class="viewcode-block" id="Parameters_Mueller.blocks"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Parameters_Mueller.blocks">[docs]</a>    <span class="k">def</span> <span class="nf">blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
               <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
               <span class="n">out_number</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
               <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
               <span class="n">draw</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Method that gives the Mueller matrix block components: $M_{00}$ (mean transmission), $D$ (diattenuation vector), $P$ (polarizance vector) and $m$ (small matrix).</span>

<span class="sd">        References:</span>
<span class="sd">            J.J. Gil, R. Ossikovsky &quot;Polarized light and the Mueller Matrix approach&quot;, CRC Press (2016)</span>

<span class="sd">        Parameters:</span>
<span class="sd">            normalize (bool): If True, normalizes the diattenuation vector to M00. Default: True.</span>
<span class="sd">            out_number (bool): If True and the result is a 1x1 array, return a number instead. Default: True.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>
<span class="sd">            verbose (bool): If True prints the parameter. Default: False.</span>
<span class="sd">            draw (bool): If True and the object is a 1D or 2D, plot it. Default: False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            m00 (float or numpy.ndarray): Average intensity.</span>
<span class="sd">            D (numpy.ndarray): Diattenuation vectors 3xN.</span>
<span class="sd">            P (numpy.ndarray): Diattenuation vector 3xN.</span>
<span class="sd">            m (numpy.ndarray): Small m matrix 3x3xN.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Extract the variables from the parent object</span>
        <span class="n">M00</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mean_transmission</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                     <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span>
                                     <span class="n">out_number</span><span class="o">=</span><span class="n">out_number</span><span class="p">)</span>
        <span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">diattenuation_vector</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>
        <span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">polarizance_vector</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">small_matrix</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>
        <span class="c1"># Print the result if required</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">draw</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The block components of </span><span class="si">{}</span><span class="s1"> are:&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
            <span class="n">heading</span> <span class="o">=</span> <span class="s1">&#39;  - M_00 of </span><span class="si">{}</span><span class="s1"> is:&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">title</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;M00&#39;</span><span class="p">)</span>
            <span class="n">PrintParam</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="p">[</span><span class="n">M00</span><span class="p">],</span>
                       <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                       <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span>
                       <span class="n">heading</span><span class="o">=</span><span class="n">heading</span><span class="p">,</span>
                       <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                       <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
            <span class="n">heading</span> <span class="o">=</span> <span class="s1">&#39;  - Diattenuation vector of </span><span class="si">{}</span><span class="s1"> is:&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">title</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;D[0]&#39;</span><span class="p">,</span> <span class="s1">&#39;D[1]&#39;</span><span class="p">,</span> <span class="s1">&#39;D[2]&#39;</span><span class="p">)</span>
            <span class="n">PrintParam</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="p">[</span><span class="n">D</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">D</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">D</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]],</span>
                       <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                       <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span>
                       <span class="n">heading</span><span class="o">=</span><span class="n">heading</span><span class="p">,</span>
                       <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                       <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
            <span class="n">heading</span> <span class="o">=</span> <span class="s1">&#39;  - Polarizance vector of </span><span class="si">{}</span><span class="s1"> is:&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">title</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;P[0]&#39;</span><span class="p">,</span> <span class="s1">&#39;P[1]&#39;</span><span class="p">,</span> <span class="s1">&#39;P[2]&#39;</span><span class="p">)</span>
            <span class="n">PrintParam</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="p">[</span><span class="n">P</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">P</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">P</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]],</span>
                       <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                       <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span>
                       <span class="n">heading</span><span class="o">=</span><span class="n">heading</span><span class="p">,</span>
                       <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                       <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
            <span class="n">heading</span> <span class="o">=</span> <span class="s1">&#39;  - Small matrix of </span><span class="si">{}</span><span class="s1"> is:&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">title</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;m[0,0]&#39;</span><span class="p">,</span> <span class="s1">&#39;m[0,1]&#39;</span><span class="p">,</span> <span class="s1">&#39;m[0,2]&#39;</span><span class="p">,</span> <span class="s1">&#39;m[1,0]&#39;</span><span class="p">,</span> <span class="s1">&#39;m[1,1]&#39;</span><span class="p">,</span>
                     <span class="s1">&#39;m[1,2]&#39;</span><span class="p">,</span> <span class="s1">&#39;m[2,0]&#39;</span><span class="p">,</span> <span class="s1">&#39;m[2,1]&#39;</span><span class="p">,</span> <span class="s1">&#39;m[2,2]&#39;</span><span class="p">)</span>
            <span class="n">PrintParam</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="p">[</span>
                <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">:],</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:],</span>
                <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">:],</span> <span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">:]</span>
            <span class="p">],</span>
                       <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                       <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span>
                       <span class="n">heading</span><span class="o">=</span><span class="n">heading</span><span class="p">,</span>
                       <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                       <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">M00</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">m</span></div>

<div class="viewcode-block" id="Parameters_Mueller.global_phase"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Parameters_Mueller.global_phase">[docs]</a>    <span class="k">def</span> <span class="nf">global_phase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                     <span class="n">give_nan</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                     <span class="n">out_number</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                     <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                     <span class="n">draw</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the phase of J00 (which is the reference for global phase in py_pol model).</span>

<span class="sd">        Parameters:</span>
<span class="sd">            give_nan(bool): If False, NaN values are transformed into 0. Default: True.</span>
<span class="sd">            out_number (bool): If True and the result is a 1x1 array, return a number instead. Default: True.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>
<span class="sd">            verbose (bool): If True prints the parameter. Default: False.</span>
<span class="sd">            draw (bool): If True and the object is a 1D or 2D, plot it. Default: False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (numpy.ndarray or float): Result.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">gp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">global_phase</span>
        <span class="c1"># If the phase is None (unknown), give nans or zeros</span>
        <span class="k">if</span> <span class="n">gp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">gp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">gp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">give_nan</span><span class="p">:</span>
                <span class="n">gp</span> <span class="o">=</span> <span class="n">gp</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="c1"># If the result is a number and the user asks for it, return a float</span>
        <span class="k">if</span> <span class="n">out_number</span> <span class="ow">and</span> <span class="n">gp</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">gp</span> <span class="o">=</span> <span class="n">gp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Calculate Ez and reshape if required</span>
        <span class="n">gp</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">([</span><span class="n">gp</span><span class="p">],</span>
                     <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span>
                     <span class="n">shape_fun</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                     <span class="n">obj</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>
        <span class="c1"># Print the result if required</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">draw</span><span class="p">:</span>
            <span class="n">heading</span> <span class="o">=</span> <span class="s1">&#39;The global phase of </span><span class="si">{}</span><span class="s1"> is (deg):&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">PrintParam</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="p">(</span><span class="n">gp</span> <span class="o">/</span> <span class="n">degrees</span><span class="p">),</span>
                       <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                       <span class="n">title</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;Global phase (deg)&quot;</span><span class="p">),</span>
                       <span class="n">heading</span><span class="o">=</span><span class="n">heading</span><span class="p">,</span>
                       <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                       <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">gp</span></div>

<div class="viewcode-block" id="Parameters_Mueller.inhomogeneity"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Parameters_Mueller.inhomogeneity">[docs]</a>    <span class="k">def</span> <span class="nf">inhomogeneity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                      <span class="n">out_number</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                      <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                      <span class="n">draw</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the inhomogeneity parameter. This parameter is 0 for homogeneous optical elements and 1 for totally inhomogeneous (degenerate) elements.</span>

<span class="sd">        Note: The equation of the reference shows at least an incorrect result in the diattenuator retarders.</span>

<span class="sd">        References:</span>
<span class="sd">            J.J. Gil, R. Ossikovsky &quot;Polarized light and the Mueller Matrix approach&quot;, CRC Press (2016), pp 119.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            out_number (bool): If True and the result is a 1x1 array, return a number instead. Default: True.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>
<span class="sd">            verbose (bool): if True prints the parameter. Default: False.</span>
<span class="sd">            draw (bool): If True and the object is a 1D or 2D, plot it. Default: False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (numpy.ndarray or float): Result.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Calculate the components</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">out_number</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">det</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">out_number</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">tr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">out_number</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># Calculate the parameter</span>
        <span class="n">cte</span> <span class="o">=</span> <span class="p">(</span><span class="n">tr</span> <span class="o">+</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">c</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">+</span> <span class="n">c</span><span class="p">[</span><span class="mi">14</span><span class="p">]))</span> <span class="o">/</span> \
            <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">c</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">+</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">c</span><span class="p">[</span><span class="mi">4</span><span class="p">]))</span>
        <span class="n">num</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">cte</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">cte</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">det</span><span class="o">**</span><span class="mf">0.25</span><span class="p">)</span>
        <span class="n">den</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">cte</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">cte</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">det</span><span class="o">**</span><span class="mf">0.25</span><span class="p">)</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol_default</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">cond</span><span class="p">):</span>
            <span class="n">num</span><span class="p">[</span><span class="n">cond</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Safety for -0 numeric error</span>
        <span class="n">eta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">num</span> <span class="o">/</span> <span class="n">den</span><span class="p">)</span>
        <span class="c1"># Safety: 0/0 must be changed to 0</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="p">(</span><span class="n">num</span> <span class="o">&lt;</span> <span class="n">tol_default</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">den</span> <span class="o">&lt;</span> <span class="n">tol_default</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">cond</span><span class="p">):</span>
            <span class="n">eta</span><span class="p">[</span><span class="n">cond</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># If the result is a number and the user asks for it, return a float</span>
        <span class="k">if</span> <span class="n">out_number</span> <span class="ow">and</span> <span class="n">eta</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">eta</span> <span class="o">=</span> <span class="n">eta</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Reshape if neccessary</span>
        <span class="n">eta</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">([</span><span class="n">eta</span><span class="p">],</span>
                      <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span>
                      <span class="n">shape_fun</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                      <span class="n">obj</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>
        <span class="c1"># Print the result if required</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">draw</span><span class="p">:</span>
            <span class="n">heading</span> <span class="o">=</span> <span class="s1">&#39;The inhomogeneity parameter of </span><span class="si">{}</span><span class="s1"> is:&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">PrintParam</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="n">eta</span><span class="p">,</span>
                       <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                       <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Inhomogeneity parameter&#39;</span><span class="p">,</span>
                       <span class="n">heading</span><span class="o">=</span><span class="n">heading</span><span class="p">,</span>
                       <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                       <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">eta</span></div>

<div class="viewcode-block" id="Parameters_Mueller.diattenuation"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Parameters_Mueller.diattenuation">[docs]</a>    <span class="k">def</span> <span class="nf">diattenuation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                      <span class="n">out_number</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                      <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                      <span class="n">draw</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the diattenuation of the Mueller matrices.</span>

<span class="sd">        References:</span>
<span class="sd">            J.J. Gil, R. Ossikovsky &quot;Polarized light and the Mueller Matrix approach&quot;, pp. 200, CRC Press (2016)</span>

<span class="sd">        Parameters:</span>
<span class="sd">            out_number (bool): if True and the result is a 1x1 array, return a number instead. Default: True.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>
<span class="sd">            verbose (bool): If True prints the parameter. Default: False.</span>
<span class="sd">            draw (bool): If True and the object is a 1D or 2D, plot it. Default: False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (numpy.ndarray or float): Result.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Calculate the diattenuation</span>
        <span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">diattenuation_vector</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>
        <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># If the result is a number and the user asks for it, return a float</span>
        <span class="k">if</span> <span class="n">out_number</span> <span class="ow">and</span> <span class="n">D</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Print the result if required</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">draw</span><span class="p">:</span>
            <span class="n">heading</span> <span class="o">=</span> <span class="s1">&#39;The diattenuation of </span><span class="si">{}</span><span class="s1"> is:&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">PrintParam</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="n">D</span><span class="p">,</span>
                       <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                       <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Diattenuation&#39;</span><span class="p">,</span>
                       <span class="n">heading</span><span class="o">=</span><span class="n">heading</span><span class="p">,</span>
                       <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                       <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">D</span></div>

<div class="viewcode-block" id="Parameters_Mueller.diattenuation_linear"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Parameters_Mueller.diattenuation_linear">[docs]</a>    <span class="k">def</span> <span class="nf">diattenuation_linear</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                             <span class="n">out_number</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                             <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                             <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                             <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                             <span class="n">draw</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the linear diattenuation of the Mueller matrices.</span>

<span class="sd">        References:</span>
<span class="sd">            J.J. Gil, R. Ossikovsky &quot;Polarized light and the Mueller Matrix approach&quot;, CRC Press (2016)</span>

<span class="sd">        Parameters:</span>
<span class="sd">            out_number (bool): If True and the result is a 1x1 array, return a number instead. Default: True.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>
<span class="sd">            verbose (bool): if True prints the parameter. Default: False.</span>
<span class="sd">            draw (bool): If True and the object is a 1D or 2D, plot it. Default: False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (numpy.ndarray or float): Result.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Calculate the diattenuation</span>
        <span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">diattenuation_vector</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>
        <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">D</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># If the result is a number and the user asks for it, return a float</span>
        <span class="k">if</span> <span class="n">out_number</span> <span class="ow">and</span> <span class="n">D</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Print the result if required</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">draw</span><span class="p">:</span>
            <span class="n">heading</span> <span class="o">=</span> <span class="s1">&#39;The linear diattenuation of </span><span class="si">{}</span><span class="s1"> is:&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">PrintParam</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="n">D</span><span class="p">,</span>
                       <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                       <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Linear diattenuation&#39;</span><span class="p">,</span>
                       <span class="n">heading</span><span class="o">=</span><span class="n">heading</span><span class="p">,</span>
                       <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                       <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">D</span></div>

<div class="viewcode-block" id="Parameters_Mueller.diattenuation_circular"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Parameters_Mueller.diattenuation_circular">[docs]</a>    <span class="k">def</span> <span class="nf">diattenuation_circular</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                               <span class="n">out_number</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                               <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                               <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                               <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                               <span class="n">draw</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the circular diattenuation of the Mueller matrices.</span>

<span class="sd">        References:</span>
<span class="sd">            J.J. Gil, R. Ossikovsky &quot;Polarized light and the Mueller Matrix approach&quot;, CRC Press (2016)</span>

<span class="sd">        Parameters:</span>
<span class="sd">            out_number (bool): If True and the result is a 1x1 array, return a number instead. Default: True.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>
<span class="sd">            verbose (bool): if True prints the parameter. Default: False.</span>
<span class="sd">            draw (bool): If True and the object is a 1D or 2D, plot it. Default: False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (numpy.ndarray or float): Result.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Calculate the diattenuation</span>
        <span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">diattenuation_vector</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>
        <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">D</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:])</span>
        <span class="c1"># If the result is a number and the user asks for it, return a float</span>
        <span class="k">if</span> <span class="n">out_number</span> <span class="ow">and</span> <span class="n">D</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Print the result if required</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">draw</span><span class="p">:</span>
            <span class="n">heading</span> <span class="o">=</span> <span class="s1">&#39;The circular diattenuation of </span><span class="si">{}</span><span class="s1"> is:&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">PrintParam</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="n">D</span><span class="p">,</span>
                       <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                       <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Circular diattenuation&#39;</span><span class="p">,</span>
                       <span class="n">heading</span><span class="o">=</span><span class="n">heading</span><span class="p">,</span>
                       <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                       <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">D</span></div>

<div class="viewcode-block" id="Parameters_Mueller.polarizance"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Parameters_Mueller.polarizance">[docs]</a>    <span class="k">def</span> <span class="nf">polarizance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                    <span class="n">out_number</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">draw</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the polarizance of the Mueller matrices.</span>

<span class="sd">        References:</span>
<span class="sd">            J.J. Gil, R. Ossikovsky &quot;Polarized light and the Mueller Matrix approach&quot;, CRC Press (2016)</span>

<span class="sd">        Parameters:</span>
<span class="sd">            out_number (bool): If True and the result is a 1x1 array, return a number instead. Default: True.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>
<span class="sd">            verbose (bool): If True prints the parameter. Default: False.</span>
<span class="sd">            draw (bool): If True and the object is a 1D or 2D, plot it. Default: False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (numpy.ndarray or float): Result.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Calculate the polarizance</span>
        <span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">polarizance_vector</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># If the result is a number and the user asks for it, return a float</span>
        <span class="k">if</span> <span class="n">out_number</span> <span class="ow">and</span> <span class="n">P</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">P</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Reshape if neccessary</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">([</span><span class="n">P</span><span class="p">],</span>
                    <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span>
                    <span class="n">shape_fun</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                    <span class="n">obj</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>
        <span class="c1"># Print the result if required</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">draw</span><span class="p">:</span>
            <span class="n">heading</span> <span class="o">=</span> <span class="s1">&#39;The polarizance of </span><span class="si">{}</span><span class="s1"> is:&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">PrintParam</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="n">P</span><span class="p">,</span>
                       <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                       <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Polarizance&#39;</span><span class="p">,</span>
                       <span class="n">heading</span><span class="o">=</span><span class="n">heading</span><span class="p">,</span>
                       <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                       <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">P</span></div>

<div class="viewcode-block" id="Parameters_Mueller.polarizance_linear"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Parameters_Mueller.polarizance_linear">[docs]</a>    <span class="k">def</span> <span class="nf">polarizance_linear</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                           <span class="n">out_number</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                           <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                           <span class="n">draw</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the linear polarizance of the Mueller matrices.</span>

<span class="sd">        References:</span>
<span class="sd">            J.J. Gil, R. Ossikovsky &quot;Polarized light and the Mueller Matrix approach&quot;, CRC Press (2016)</span>

<span class="sd">        Parameters:</span>
<span class="sd">            out_number (bool): If True and the result is a 1x1 array, return a number instead. Default: True.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>
<span class="sd">            verbose (bool): If True prints the parameter. Default: False.</span>
<span class="sd">            draw (bool): If True and the object is a 1D or 2D, plot it. Default: False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (numpy.ndarray or float): Result.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Calculate the polarizance</span>
        <span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">polarizance_vector</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># If the result is a number and the user asks for it, return a float</span>
        <span class="k">if</span> <span class="n">out_number</span> <span class="ow">and</span> <span class="n">P</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">P</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Print the result if required</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">draw</span><span class="p">:</span>
            <span class="n">heading</span> <span class="o">=</span> <span class="s1">&#39;The linear polarizance of </span><span class="si">{}</span><span class="s1"> is:&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">PrintParam</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="n">P</span><span class="p">,</span>
                       <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                       <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Linear polarizance&#39;</span><span class="p">,</span>
                       <span class="n">heading</span><span class="o">=</span><span class="n">heading</span><span class="p">,</span>
                       <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                       <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">P</span></div>

<div class="viewcode-block" id="Parameters_Mueller.polarizance_circular"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Parameters_Mueller.polarizance_circular">[docs]</a>    <span class="k">def</span> <span class="nf">polarizance_circular</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                             <span class="n">out_number</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                             <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                             <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                             <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                             <span class="n">draw</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the linear polarizance of the Mueller matrices.</span>

<span class="sd">        References:</span>
<span class="sd">            J.J. Gil, R. Ossikovsky &quot;Polarized light and the Mueller Matrix approach&quot;, CRC Press (2016)</span>

<span class="sd">        Parameters:</span>
<span class="sd">            out_number (bool): if True and the result is a 1x1 array, return a number instead. Default: True.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>
<span class="sd">            verbose (bool): If True prints the parameter. Default: False.</span>
<span class="sd">            draw (bool): If True and the object is a 1D or 2D, plot it. Default: False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (numpy.ndarray or float): Result.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Calculate the polarizance</span>
        <span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">polarizance_vector</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:])</span>
        <span class="c1"># If the result is a number and the user asks for it, return a float</span>
        <span class="k">if</span> <span class="n">out_number</span> <span class="ow">and</span> <span class="n">P</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">P</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Print the result if required</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">draw</span><span class="p">:</span>
            <span class="n">heading</span> <span class="o">=</span> <span class="s1">&#39;The circular polarizance of </span><span class="si">{}</span><span class="s1"> is:&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">PrintParam</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="n">P</span><span class="p">,</span>
                       <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                       <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Circular polarizance&#39;</span><span class="p">,</span>
                       <span class="n">heading</span><span class="o">=</span><span class="n">heading</span><span class="p">,</span>
                       <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                       <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">P</span></div>

<div class="viewcode-block" id="Parameters_Mueller.degree_polarizance"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Parameters_Mueller.degree_polarizance">[docs]</a>    <span class="k">def</span> <span class="nf">degree_polarizance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                           <span class="n">out_number</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                           <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                           <span class="n">draw</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the degree of polarizance of the Mueller matrices.</span>

<span class="sd">        References:</span>
<span class="sd">            J.J. Gil, R. Ossikovsky &quot;Polarized light and the Mueller Matrix approach&quot;, CRC Press (2016)</span>

<span class="sd">        Parameters:</span>
<span class="sd">            out_number (bool): If True and the result is a 1x1 array, return a number instead. Default: True.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>
<span class="sd">            verbose (bool): If True prints the parameter. Default: False.</span>
<span class="sd">            draw (bool): If True and the object is a 1D or 2D, plot it. Default: False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (numpy.ndarray or float): Result.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Calculate the degree</span>
        <span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">polarizance</span><span class="p">(</span><span class="n">out_number</span><span class="o">=</span><span class="n">out_number</span><span class="p">,</span>
                             <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                             <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>
        <span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">diattenuation</span><span class="p">(</span><span class="n">out_number</span><span class="o">=</span><span class="n">out_number</span><span class="p">,</span>
                               <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                               <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>
        <span class="n">Dp</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">((</span><span class="n">P</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">D</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="c1"># Print the result if required</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">draw</span><span class="p">:</span>
            <span class="n">heading</span> <span class="o">=</span> <span class="s1">&#39;The degree of polarizance of </span><span class="si">{}</span><span class="s1"> is:&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">PrintParam</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="n">Dp</span><span class="p">,</span>
                       <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                       <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Degree of polarizance&#39;</span><span class="p">,</span>
                       <span class="n">heading</span><span class="o">=</span><span class="n">heading</span><span class="p">,</span>
                       <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                       <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Dp</span></div>

<div class="viewcode-block" id="Parameters_Mueller.spheric_purity"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Parameters_Mueller.spheric_purity">[docs]</a>    <span class="k">def</span> <span class="nf">spheric_purity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                       <span class="n">out_number</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                       <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                       <span class="n">draw</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the degree of spheric purity of the Mueller matrices.</span>

<span class="sd">        References:</span>
<span class="sd">            J.J. Gil, R. Ossikovsky &quot;Polarized light and the Mueller Matrix approach&quot;, CRC Press (2016) pp 204.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            out_number (bool): If True and the result is a 1x1 array, return a number instead. Default: True.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>
<span class="sd">            verbose (bool): If True prints the parameter. Default: False.</span>
<span class="sd">            draw (bool): If True and the object is a 1D or 2D, plot it. Default: False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (numpy.ndarray or float): Result.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Calculate the degree</span>
        <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">small_matrix</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>
        <span class="n">SP</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="c1"># If the result is a number and the user asks for it, return a float</span>
        <span class="k">if</span> <span class="n">out_number</span> <span class="ow">and</span> <span class="n">SP</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">SP</span> <span class="o">=</span> <span class="n">SP</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Print the result if required</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">draw</span><span class="p">:</span>
            <span class="n">heading</span> <span class="o">=</span> <span class="s1">&#39;The degree of spherical purity of </span><span class="si">{}</span><span class="s1"> is:&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">PrintParam</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="n">SP</span><span class="p">,</span>
                       <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                       <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Spherical purity&#39;</span><span class="p">,</span>
                       <span class="n">heading</span><span class="o">=</span><span class="n">heading</span><span class="p">,</span>
                       <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                       <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">SP</span></div>

    <span class="c1"># Similar to purity grades</span>

<div class="viewcode-block" id="Parameters_Mueller.retardance"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Parameters_Mueller.retardance">[docs]</a>    <span class="k">def</span> <span class="nf">retardance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                   <span class="n">out_number</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                   <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                   <span class="n">draw</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the retardance of the Mueller matrix of a pure retarder.</span>

<span class="sd">        References:</span>
<span class="sd">            J.J. Gil, R. Ossikovsky &quot;Polarized light and the Mueller Matrix approach&quot;, CRC Press (2016) pp 129.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            out_number (bool): If True and the result is a 1x1 array, return a number instead. Default: True.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>
<span class="sd">            verbose (bool): If True prints the parameter. Default: False.</span>
<span class="sd">            draw (bool): If True and the object is a 1D or 2D, plot it. Default: False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (numpy.ndarray or float): Result.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: (Jesus) We have to find a way to know if we are in the 180 -&gt; 360 degrees region. Clue: In that case, opper triangular part is negative (except for ellipticity negative and phi lower than 90 deg).</span>

        <span class="c1"># Calculate the retardance</span>
        <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">small_matrix</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>
        <span class="n">cosR</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">cosR</span><span class="p">)</span>
        <span class="c1"># If the result is a number and the user asks for it, return a float</span>
        <span class="k">if</span> <span class="n">out_number</span> <span class="ow">and</span> <span class="n">R</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Print the result if required</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">draw</span><span class="p">:</span>
            <span class="n">heading</span> <span class="o">=</span> <span class="s1">&#39;The retardance of </span><span class="si">{}</span><span class="s1"> is (deg):&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">PrintParam</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="n">R</span> <span class="o">/</span> <span class="n">degrees</span><span class="p">,</span>
                       <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                       <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Retardance (deg)&#39;</span><span class="p">,</span>
                       <span class="n">heading</span><span class="o">=</span><span class="n">heading</span><span class="p">,</span>
                       <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                       <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">R</span></div>

    <span class="c1"># Polarization or despolarization</span>
<div class="viewcode-block" id="Parameters_Mueller.polarimetric_purity"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Parameters_Mueller.polarimetric_purity">[docs]</a>    <span class="k">def</span> <span class="nf">polarimetric_purity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                            <span class="n">out_number</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                            <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                            <span class="n">draw</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the degree of polarimetric purity of the Mueller matrices.</span>

<span class="sd">        References:</span>
<span class="sd">            J.J. Gil, R. Ossikovsky &quot;Polarized light and the Mueller Matrix approach&quot;, CRC Press (2016)</span>

<span class="sd">        Parameters:</span>
<span class="sd">            out_number (bool): If True and the result is a 1x1 array, return a number instead. Default: True.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>
<span class="sd">            verbose (bool): If True prints the parameter. Default: False.</span>
<span class="sd">            draw (bool): If True and the object is a 1D or 2D, plot it. Default: False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (numpy.ndarray or float): Result.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Calculate the degree</span>
        <span class="n">Pp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree_polarizance</span><span class="p">(</span><span class="n">out_number</span><span class="o">=</span><span class="n">out_number</span><span class="p">,</span>
                                     <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                     <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>
        <span class="n">Ps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spheric_purity</span><span class="p">(</span><span class="n">out_number</span><span class="o">=</span><span class="n">out_number</span><span class="p">,</span>
                                 <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                 <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>
        <span class="n">PP</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="mf">2.</span> <span class="o">/</span> <span class="mf">3.</span> <span class="o">*</span> <span class="n">Pp</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">Ps</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="c1"># Print the result if required</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">draw</span><span class="p">:</span>
            <span class="n">heading</span> <span class="o">=</span> <span class="s1">&#39;The degree of polarimetric purity of </span><span class="si">{}</span><span class="s1"> is:&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">PrintParam</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="n">PP</span><span class="p">,</span>
                       <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                       <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Polarimetric purity&#39;</span><span class="p">,</span>
                       <span class="n">heading</span><span class="o">=</span><span class="n">heading</span><span class="p">,</span>
                       <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                       <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">PP</span></div>

<div class="viewcode-block" id="Parameters_Mueller.depolarization_index"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Parameters_Mueller.depolarization_index">[docs]</a>    <span class="k">def</span> <span class="nf">depolarization_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                             <span class="n">out_number</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                             <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                             <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                             <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                             <span class="n">draw</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the depolarization index of the Mueller matrices.</span>

<span class="sd">        References:</span>
<span class="sd">            J.J. Gil, R. Ossikovsky &quot;Polarized light and the Mueller Matrix approach&quot;, CRC Press (2016)</span>

<span class="sd">        Parameters:</span>
<span class="sd">            out_number (bool): If True and the result is a 1x1 array, return a number instead. Default: True.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>
<span class="sd">            verbose (bool): If True prints the parameter. Default: False.</span>
<span class="sd">            draw (bool): If True and the object is a 1D or 2D, plot it. Default: False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (numpy.ndarray or float): Result.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">PP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">polarimetric_purity</span><span class="p">(</span><span class="n">out_number</span><span class="o">=</span><span class="n">out_number</span><span class="p">,</span>
                                      <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                      <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>
        <span class="n">DI</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">PP</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="c1"># Print the result if required</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">draw</span><span class="p">:</span>
            <span class="n">heading</span> <span class="o">=</span> <span class="s1">&#39;The depolarization index of </span><span class="si">{}</span><span class="s1"> is:&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">PrintParam</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="n">DI</span><span class="p">,</span>
                       <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                       <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Depolarization index&#39;</span><span class="p">,</span>
                       <span class="n">heading</span><span class="o">=</span><span class="n">heading</span><span class="p">,</span>
                       <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                       <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">DI</span></div>

    <span class="c1"># def depolarization_factors(self):</span>
    <span class="c1">#     &quot;&quot;&quot;Calculates the Euclidean distance and depolarization factor</span>
    <span class="c1">#</span>
    <span class="c1">#     References:</span>
    <span class="c1">#         Handbook of Optics vol 2. 22.49 (46 and 47)</span>
    <span class="c1">#</span>
    <span class="c1">#     Parameters:</span>
    <span class="c1">#         M (4x4 numpy.matrix): Mueller matrix</span>
    <span class="c1">#</span>
    <span class="c1">#     Returns:</span>
    <span class="c1">#         (float): Euclidean distance of the normalized Mueller matrix from an ideal depolarizer</span>
    <span class="c1">#         (float): Dep(M) depolarization of the matrix</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     # TODO: (Jesus) Check if Mnorm must be used instead of M</span>
    <span class="c1">#</span>
    <span class="c1">#     M = self.M</span>
    <span class="c1">#     quadratic_sum = (array(M)**2).sum()</span>
    <span class="c1">#     euclidean_distance = sqrt(quadratic_sum - M[0, 0]**2) / M[0, 0]</span>
    <span class="c1">#     depolarization = 1 - euclidean_distance / sqrt(3)</span>
    <span class="c1">#</span>
    <span class="c1">#     return euclidean_distance, depolarization</span>

    <span class="c1"># Polarimetric purity</span>

<div class="viewcode-block" id="Parameters_Mueller.polarimetric_purity_indices"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Parameters_Mueller.polarimetric_purity_indices">[docs]</a>    <span class="k">def</span> <span class="nf">polarimetric_purity_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                    <span class="n">out_number</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                    <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                    <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                    <span class="n">draw</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the polarimetric purity indices of the Mueller matrices.</span>

<span class="sd">        References:</span>
<span class="sd">            J.J. Gil, R. Ossikovsky &quot;Polarized light and the Mueller Matrix approach&quot;, CRC Press (2016), pp 208.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            out_number (bool): If True and the result is a 1x1 array, return a number instead. Default: True.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>
<span class="sd">            verbose (bool): If True prints the parameter. Default: False.</span>
<span class="sd">            draw (bool): If True and the object is a 1D or 2D, plot it. Default: False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            P1, P2, P3 (numpy.ndarray or float): Results.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Calculate the covariance matrix</span>
        <span class="n">H</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">covariance_matrix</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># Calculate parameters of covariance matrix</span>
        <span class="n">th</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">out_number</span><span class="o">=</span><span class="n">out_number</span><span class="p">))</span>
        <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">v3</span><span class="p">,</span> <span class="n">v4</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                  <span class="n">out_number</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># Order the eigenvalues</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">v1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">v2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">v3</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">v4</span><span class="p">)])</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># Calculate indices</span>
        <span class="n">P1</span> <span class="o">=</span> <span class="p">(</span><span class="n">vals</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">vals</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:])</span> <span class="o">/</span> <span class="n">th</span>
        <span class="n">P2</span> <span class="o">=</span> <span class="p">(</span><span class="n">vals</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">vals</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">vals</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span> <span class="o">/</span> <span class="n">th</span>
        <span class="n">P3</span> <span class="o">=</span> <span class="p">(</span><span class="n">vals</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">vals</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">vals</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">vals</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span> <span class="o">/</span> <span class="n">th</span>
        <span class="c1"># Size 1 objects need some care</span>
        <span class="k">if</span> <span class="n">P1</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">P1</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">P1</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">P3</span> <span class="o">=</span> <span class="p">(</span><span class="n">P1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">P2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">P3</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="c1"># Reshape if neccessary</span>
        <span class="n">P1</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">P3</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">([</span><span class="n">P1</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">P3</span><span class="p">],</span>
                             <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span>
                             <span class="n">shape_fun</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                             <span class="n">obj</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>
        <span class="c1"># Print the result if required</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">draw</span><span class="p">:</span>
            <span class="c1"># Eigenvalues</span>
            <span class="n">heading</span> <span class="o">=</span> <span class="s1">&#39;The polarimetric purity indices of </span><span class="si">{}</span><span class="s1"> are:&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">PrintParam</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="p">(</span><span class="n">P1</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">P3</span><span class="p">),</span>
                       <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                       <span class="n">title</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;P1&#39;</span><span class="p">,</span> <span class="s1">&#39;P2&#39;</span><span class="p">,</span> <span class="s1">&#39;P3&#39;</span><span class="p">),</span>
                       <span class="n">heading</span><span class="o">=</span><span class="n">heading</span><span class="p">,</span>
                       <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                       <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">P1</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">P3</span></div>

<div class="viewcode-block" id="Parameters_Mueller.transmissions"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Parameters_Mueller.transmissions">[docs]</a>    <span class="k">def</span> <span class="nf">transmissions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                      <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;Intensity&#39;</span><span class="p">,</span>
                      <span class="n">out_number</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                      <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                      <span class="n">draw</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the maximum and minimum transmitance of an optical element.</span>

<span class="sd">        References:</span>
<span class="sd">            Handbook of Optics vol 2. 22.32 (eq.38)</span>

<span class="sd">        Parameters:</span>
<span class="sd">            kind (str): There are three options, FIELD, INTENSITY or ALL.</span>
<span class="sd">            out_number (bool): If True and the result is a 1x1 array, return a number instead. Default: True.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>
<span class="sd">            verbose (bool): If True prints the parameter. Default: False.</span>
<span class="sd">            draw (bool): If True and the object is a 1D or 2D, plot it. Default: False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            T_max (numpy.ndarray): Maximum intensity transmission.</span>
<span class="sd">            T_min (numpy.ndarray): Minimum intensity transmission.</span>
<span class="sd">            p1 (numpy.ndarray): Maximum field transmission.</span>
<span class="sd">            p2 (numpy.ndarray): Minimum field transmission.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Take the parameters</span>
        <span class="n">M00</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mean_transmission</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                     <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span>
                                     <span class="n">out_number</span><span class="o">=</span><span class="n">out_number</span><span class="p">)</span>
        <span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">diattenuation</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                               <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span>
                               <span class="n">out_number</span><span class="o">=</span><span class="n">out_number</span><span class="p">)</span>
        <span class="c1"># Calculate the transmissions</span>
        <span class="n">T_max</span> <span class="o">=</span> <span class="n">M00</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">D</span><span class="p">)</span>
        <span class="n">T_min</span> <span class="o">=</span> <span class="n">M00</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">D</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">kind</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;FIELD&#39;</span><span class="p">,</span> <span class="s1">&#39;ALL&#39;</span><span class="p">):</span>
            <span class="n">p1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">T_max</span><span class="p">)</span>
            <span class="n">p2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">T_min</span><span class="p">)</span>
        <span class="c1"># Print the result if required</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">draw</span><span class="p">:</span>
            <span class="c1"># Intensity</span>
            <span class="k">if</span> <span class="n">kind</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;INTENSITY&#39;</span><span class="p">,</span> <span class="s1">&#39;ALL&#39;</span><span class="p">):</span>
                <span class="n">heading</span> <span class="o">=</span> <span class="s1">&#39;The intensity transmissions of </span><span class="si">{}</span><span class="s1"> are:&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="n">PrintParam</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="p">(</span><span class="n">T_max</span><span class="p">,</span> <span class="n">T_min</span><span class="p">),</span>
                           <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                           <span class="n">title</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;Maximum (int.)&#39;</span><span class="p">,</span> <span class="s1">&#39;Minimum (int.)&#39;</span><span class="p">),</span>
                           <span class="n">heading</span><span class="o">=</span><span class="n">heading</span><span class="p">,</span>
                           <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                           <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
            <span class="c1"># Field</span>
            <span class="k">if</span> <span class="n">kind</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;FIELD&#39;</span><span class="p">,</span> <span class="s1">&#39;ALL&#39;</span><span class="p">):</span>
                <span class="n">heading</span> <span class="o">=</span> <span class="s1">&#39;The field transmissions of </span><span class="si">{}</span><span class="s1"> are:&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="n">PrintParam</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">),</span>
                           <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                           <span class="n">title</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;Maximum (int.)&#39;</span><span class="p">,</span> <span class="s1">&#39;Minimum (int.)&#39;</span><span class="p">),</span>
                           <span class="n">heading</span><span class="o">=</span><span class="n">heading</span><span class="p">,</span>
                           <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                           <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
        <span class="c1"># Return</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">kind</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;INTENSITY&#39;</span><span class="p">,</span> <span class="s1">&#39;ALL&#39;</span><span class="p">):</span>
            <span class="n">ret</span> <span class="o">+=</span> <span class="p">[</span><span class="n">T_max</span><span class="p">,</span> <span class="n">T_min</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">kind</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;FIELD&#39;</span><span class="p">,</span> <span class="s1">&#39;ALL&#39;</span><span class="p">):</span>
            <span class="n">ret</span> <span class="o">+=</span> <span class="p">[</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="Parameters_Mueller.retardance_vector"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Parameters_Mueller.retardance_vector">[docs]</a>    <span class="k">def</span> <span class="nf">retardance_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                          <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;norm&#39;</span><span class="p">,</span>
                          <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                          <span class="n">draw</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the retardance of a vector.</span>

<span class="sd">        References:</span>
<span class="sd">            J.J. Gil, R. Ossikovsky &quot;Polarized light and the Mueller Matrix approach&quot;, CRC Press (2016), pp 128-130.</span>

<span class="sd">        Args:</span>
<span class="sd">            kind (string): Identifies the type of retardance vector. There are three possibilities: NORM (also called Pauli vector), STRAIGHT or COMPLETE. Default: &#39;norm&#39;.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>
<span class="sd">            verbose (bool): If True prints the parameter. Default: False.</span>
<span class="sd">            draw (bool): If True and the object is a 1D or 2D, plot it. Default: False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (numpy.ndarray): 3xN array of the result.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Extract the necessary parameters</span>
        <span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">retardance</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">out_number</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">small_matrix</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">Rv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
        <span class="c1"># Transform depending on the type of vector</span>
        <span class="k">if</span> <span class="n">kind</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;complete&#39;</span><span class="p">,</span> <span class="s1">&#39;COMPLETE&#39;</span><span class="p">,</span> <span class="s1">&#39;Complete&#39;</span><span class="p">):</span>
            <span class="n">cte</span> <span class="o">=</span> <span class="n">R</span>
        <span class="k">elif</span> <span class="n">kind</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;straight&#39;</span><span class="p">,</span> <span class="s1">&#39;STRAIGHT&#39;</span><span class="p">,</span> <span class="s1">&#39;Straight&#39;</span><span class="p">):</span>
            <span class="n">cte</span> <span class="o">=</span> <span class="n">R</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cte</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
        <span class="c1"># General case: retardance different than 0 or 180ยบ</span>
        <span class="n">cond_G</span> <span class="o">=</span> <span class="p">(</span><span class="n">R</span> <span class="o">&gt;=</span> <span class="n">tol_default</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">R</span> <span class="o">&lt;=</span> <span class="mi">180</span> <span class="o">*</span> <span class="n">degrees</span> <span class="o">-</span> <span class="n">tol_default</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">cond_G</span><span class="p">):</span>
            <span class="n">sR</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="n">cond_G</span><span class="p">])</span> <span class="o">/</span> <span class="n">cte</span><span class="p">[</span><span class="n">cond_G</span><span class="p">]</span>
            <span class="n">Rv</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">cond_G</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">cond_G</span><span class="p">]</span> <span class="o">-</span> <span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cond_G</span><span class="p">])</span> <span class="o">/</span> <span class="n">sR</span>
            <span class="n">Rv</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">cond_G</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cond_G</span><span class="p">]</span> <span class="o">-</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">cond_G</span><span class="p">])</span> <span class="o">/</span> <span class="n">sR</span>
            <span class="n">Rv</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">cond_G</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cond_G</span><span class="p">]</span> <span class="o">-</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cond_G</span><span class="p">])</span> <span class="o">/</span> <span class="n">sR</span>
        <span class="c1"># Particular case: R = 0</span>
        <span class="n">cond_Z</span> <span class="o">=</span> <span class="n">R</span> <span class="o">&lt;</span> <span class="n">tol_default</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">cond_Z</span><span class="p">):</span>
            <span class="c1"># If R = 0, we don&#39;t have a retarder after all, so any vector is valid</span>
            <span class="n">Rv</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">cond_Z</span><span class="p">]</span> <span class="o">=</span> <span class="n">cte</span><span class="p">[</span><span class="n">cond_Z</span><span class="p">]</span>
        <span class="c1"># Particular case: R = 180ยบ</span>
        <span class="n">cond_P</span> <span class="o">=</span> <span class="n">R</span> <span class="o">&gt;</span> <span class="mi">180</span> <span class="o">*</span> <span class="n">degrees</span> <span class="o">-</span> <span class="n">tol_default</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">cond_P</span><span class="p">):</span>
            <span class="c1"># This case is more tricky, we have to calculate Rv from its eigenstates (supposing that it is a pure retarder)</span>
            <span class="n">S1</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigenstates</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">alpha</span><span class="p">,</span> <span class="n">delay</span> <span class="o">=</span> <span class="n">S1</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">charac_angles</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                       <span class="n">out_number</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">Rv</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">cond_P</span><span class="p">]</span> <span class="o">=</span> <span class="n">cte</span><span class="p">[</span><span class="n">cond_P</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">alpha</span><span class="p">[</span><span class="n">cond_P</span><span class="p">])</span>
            <span class="n">Rv</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">cond_P</span><span class="p">]</span> <span class="o">=</span> <span class="n">cte</span><span class="p">[</span><span class="n">cond_P</span><span class="p">]</span> <span class="o">*</span> \
                <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">alpha</span><span class="p">[</span><span class="n">cond_P</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">delay</span><span class="p">[</span><span class="n">cond_P</span><span class="p">])</span>
            <span class="n">Rv</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">cond_P</span><span class="p">]</span> <span class="o">=</span> <span class="n">cte</span><span class="p">[</span><span class="n">cond_P</span><span class="p">]</span> <span class="o">*</span> \
                <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">alpha</span><span class="p">[</span><span class="n">cond_P</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">delay</span><span class="p">[</span><span class="n">cond_P</span><span class="p">])</span>
        <span class="c1"># Print the result if required</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">draw</span><span class="p">:</span>
            <span class="c1"># Extract the components</span>
            <span class="n">r0</span><span class="p">,</span> <span class="n">r1</span><span class="p">,</span> <span class="n">r2</span> <span class="o">=</span> <span class="p">(</span><span class="n">Rv</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">Rv</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">Rv</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:])</span>
            <span class="n">r0</span><span class="p">,</span> <span class="n">r1</span><span class="p">,</span> <span class="n">r2</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">([</span><span class="n">r0</span><span class="p">,</span> <span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">],</span>
                                 <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span>
                                 <span class="n">shape_fun</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                 <span class="n">obj</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>
            <span class="c1"># Print</span>
            <span class="n">heading</span> <span class="o">=</span> <span class="s1">&#39;The retardance vector (</span><span class="si">{}</span><span class="s1">) components components of </span><span class="si">{}</span><span class="s1"> are:&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">kind</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">PrintParam</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="p">[</span><span class="n">r0</span><span class="p">,</span> <span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">],</span>
                       <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                       <span class="n">title</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;r0&#39;</span><span class="p">,</span> <span class="s1">&#39;r1&#39;</span><span class="p">,</span> <span class="s1">&#39;r2&#39;</span><span class="p">),</span>
                       <span class="n">heading</span><span class="o">=</span><span class="n">heading</span><span class="p">,</span>
                       <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                       <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
        <span class="c1"># Reshape the vector if neccessary</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">take_shape</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="n">shape_like</span><span class="p">,</span> <span class="n">shape</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
            <span class="n">Rv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Rv</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Rv</span></div>

<div class="viewcode-block" id="Parameters_Mueller.eig"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Parameters_Mueller.eig">[docs]</a>    <span class="k">def</span> <span class="nf">eig</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">values_as_matrix</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">vectors_as_matrix</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">out_number</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">draw</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the eigenvalues and eigenvectors of the Mueller matrices.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            values_as_matrix (bool): If True, the eigenvalues output is a numpy.ndarray instead of a list of arrays. Default: False.</span>
<span class="sd">            vectors_as_matrix (bool): If True, the eigenvectors output is a numpy.ndarray instead of a list of arrays. Default: False.</span>
<span class="sd">            out_number (bool): If True and the result is a 1x1 array, return a number instead. Default: True.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>
<span class="sd">            verbose (bool): If True prints the parameter. Default: False.</span>
<span class="sd">            draw (bool): If True and the object is a 1D or 2D, plot it. Default: False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            eigenvalues (list or numpy.ndarray): List with the four eigenvalues (if values_as_matrix is False) or 4xN array (if values_as_matrix is True).</span>
<span class="sd">            eigenvectors (list or numpy.ndarray): List with the four eigenvectors (if vectors_as_matrix is False) or 4x4xN array (if vectors_as_matrix is True).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Calculate the eig</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">M</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">val</span><span class="p">,</span> <span class="n">vect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
        <span class="c1"># Order the eigenvalues in the py_pol way</span>
        <span class="k">if</span> <span class="o">~</span><span class="n">values_as_matrix</span> <span class="ow">or</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">draw</span><span class="p">:</span>
            <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">v3</span><span class="p">,</span> <span class="n">v4</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">val</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">val</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">val</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">])</span>
            <span class="c1"># Size 1 objects need some care</span>
            <span class="k">if</span> <span class="n">v1</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">v1</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">v3</span><span class="p">,</span> <span class="n">v4</span> <span class="o">=</span> <span class="p">(</span><span class="n">v1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v3</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v4</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">out_number</span> <span class="ow">and</span> <span class="n">v1</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">v3</span><span class="p">,</span> <span class="n">v4</span> <span class="o">=</span> <span class="p">(</span><span class="n">v1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v3</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v4</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="c1"># Reshape if neccessary</span>
            <span class="n">eigenvalues</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">([</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">v3</span><span class="p">,</span> <span class="n">v4</span><span class="p">],</span>
                                  <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span>
                                  <span class="n">shape_fun</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                  <span class="n">obj</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>
        <span class="c1"># Reshape eigenvalues if output as matrix</span>
        <span class="k">if</span> <span class="n">values_as_matrix</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">new_shape</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">select_shape</span><span class="p">(</span><span class="n">obj</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span>
                                        <span class="n">shape_fun</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                        <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">new_shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">new_shape</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">new_shape</span><span class="p">)</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">new_shape</span><span class="p">)</span>

        <span class="c1"># Reshape eigenvectors in pypol way</span>
        <span class="k">if</span> <span class="o">~</span><span class="n">vectors_as_matrix</span> <span class="ow">or</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">draw</span><span class="p">:</span>
            <span class="n">e1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span><span class="n">vect</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">vect</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">vect</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">vect</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
            <span class="n">e2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span><span class="n">vect</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">vect</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">vect</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">vect</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
            <span class="n">e3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span><span class="n">vect</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">vect</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">vect</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">vect</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
            <span class="n">e4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span><span class="n">vect</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">vect</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">vect</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">vect</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
            <span class="n">eigenvectors</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">,</span> <span class="n">e3</span><span class="p">,</span> <span class="n">e4</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
                    <span class="n">eigenvectors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">elem</span><span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="p">:])</span>
            <span class="n">eigenvectors</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">(</span><span class="n">eigenvectors</span><span class="p">,</span>
                                   <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span>
                                   <span class="n">shape_fun</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                   <span class="n">obj</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>
            <span class="n">new_shape</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">eigenvectors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">e1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">new_shape</span><span class="p">)</span>
                <span class="n">e2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">e2</span><span class="p">,</span> <span class="n">new_shape</span><span class="p">)</span>
                <span class="n">e3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">e3</span><span class="p">,</span> <span class="n">new_shape</span><span class="p">)</span>
                <span class="n">e4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">e4</span><span class="p">,</span> <span class="n">new_shape</span><span class="p">)</span>
        <span class="c1"># Reshape eigenvectors if output as matrix</span>
        <span class="k">if</span> <span class="n">vectors_as_matrix</span><span class="p">:</span>
            <span class="n">vect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">vect</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">vect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">vect</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">new_shape</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">select_shape</span><span class="p">(</span><span class="n">obj</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span>
                                        <span class="n">shape_fun</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                        <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">new_shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">new_shape</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">new_shape</span><span class="p">)</span>
                <span class="n">vect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">vect</span><span class="p">,</span> <span class="n">new_shape</span><span class="p">)</span>

        <span class="c1"># Print the result if required</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">draw</span><span class="p">:</span>
            <span class="c1"># Eigenvalues</span>
            <span class="n">heading</span> <span class="o">=</span> <span class="s1">&#39;The eigenvalues of </span><span class="si">{}</span><span class="s1"> are:&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">PrintParam</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="n">eigenvalues</span><span class="p">,</span>
                       <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                       <span class="n">title</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;v1&#39;</span><span class="p">,</span> <span class="s1">&#39;v2&#39;</span><span class="p">,</span> <span class="s1">&#39;v3&#39;</span><span class="p">,</span> <span class="s1">&#39;v4&#39;</span><span class="p">),</span>
                       <span class="n">heading</span><span class="o">=</span><span class="n">heading</span><span class="p">,</span>
                       <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                       <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
            <span class="c1"># Eigenvectors</span>
            <span class="n">heading</span> <span class="o">=</span> <span class="s1">&#39;The eigenvectors of </span><span class="si">{}</span><span class="s1"> are:&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">PrintParam</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="n">eigenvectors</span><span class="p">,</span>
                       <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                       <span class="n">title</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;e1 I&#39;</span><span class="p">,</span> <span class="s1">&#39;e1 Q&#39;</span><span class="p">,</span> <span class="s1">&#39;e1 U&#39;</span><span class="p">,</span> <span class="s1">&#39;e1 V&#39;</span><span class="p">,</span> <span class="s1">&#39;e2 I&#39;</span><span class="p">,</span> <span class="s1">&#39;e2 Q&#39;</span><span class="p">,</span>
                              <span class="s1">&#39;e2 U&#39;</span><span class="p">,</span> <span class="s1">&#39;e2 V&#39;</span><span class="p">,</span> <span class="s1">&#39;e3 I&#39;</span><span class="p">,</span> <span class="s1">&#39;e3 Q&#39;</span><span class="p">,</span> <span class="s1">&#39;e3 U&#39;</span><span class="p">,</span> <span class="s1">&#39;e3 V&#39;</span><span class="p">,</span>
                              <span class="s1">&#39;e4 I&#39;</span><span class="p">,</span> <span class="s1">&#39;e4 Q&#39;</span><span class="p">,</span> <span class="s1">&#39;e4 U&#39;</span><span class="p">,</span> <span class="s1">&#39;e4 V&#39;</span><span class="p">),</span>
                       <span class="n">heading</span><span class="o">=</span><span class="n">heading</span><span class="p">,</span>
                       <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                       <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>

        <span class="c1"># Return</span>
        <span class="k">if</span> <span class="n">values_as_matrix</span><span class="p">:</span>
            <span class="n">eigenvalues</span> <span class="o">=</span> <span class="n">val</span>
        <span class="k">if</span> <span class="n">vectors_as_matrix</span><span class="p">:</span>
            <span class="n">eigenvectors</span> <span class="o">=</span> <span class="n">vect</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">eigenvectors</span> <span class="o">=</span> <span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">,</span> <span class="n">e3</span><span class="p">,</span> <span class="n">e4</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">eigenvalues</span><span class="p">,</span> <span class="n">eigenvectors</span></div>

<div class="viewcode-block" id="Parameters_Mueller.eigenvectors"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Parameters_Mueller.eigenvectors">[docs]</a>    <span class="k">def</span> <span class="nf">eigenvectors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                     <span class="n">vectors_as_matrix</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                     <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                     <span class="n">draw</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the eigenvectors of the Mueller matrices.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            vectors_as_matrix (bool): If True, the eigenvectors output is a numpy.ndarray instead of a list of arrays. Default: False.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>
<span class="sd">            verbose (bool): If True prints the parameter. Default: False.</span>
<span class="sd">            draw (bool): If True and the object is a 1D or 2D, plot it. Default: False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (numpy.ndarray): 4x4xN eigenvector matrix (if vectors_as_matrix is True).</span>
<span class="sd">            e1, e2, e3, e4 (numpy.ndarray): 4xN eigenvector matrices (if vectors_as_matrix is False).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Calculate</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">M</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">vect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>

        <span class="c1"># Reshape eigenvectors in pypol way</span>
        <span class="k">if</span> <span class="o">~</span><span class="n">vectors_as_matrix</span> <span class="ow">or</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">draw</span><span class="p">:</span>
            <span class="n">e1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span><span class="n">vect</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">vect</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">vect</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">vect</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
            <span class="n">e2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span><span class="n">vect</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">vect</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">vect</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">vect</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
            <span class="n">e3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span><span class="n">vect</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">vect</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">vect</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">vect</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
            <span class="n">e4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span><span class="n">vect</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">vect</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">vect</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">vect</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
            <span class="n">eigenvectors</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">,</span> <span class="n">e3</span><span class="p">,</span> <span class="n">e4</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
                    <span class="n">eigenvectors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">elem</span><span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="p">:])</span>
            <span class="n">eigenvectors</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">(</span><span class="n">eigenvectors</span><span class="p">,</span>
                                   <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span>
                                   <span class="n">shape_fun</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                   <span class="n">obj</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>
            <span class="c1"># new_shape = [4] + list(eigenvectors[0].shape)</span>
            <span class="c1"># if len(new_shape) &gt; 2:</span>
            <span class="c1">#     e1 = np.reshape(e1, new_shape)</span>
            <span class="c1">#     e2 = np.reshape(e2, new_shape)</span>
            <span class="c1">#     e3 = np.reshape(e3, new_shape)</span>
            <span class="c1">#     e4 = np.reshape(e4, new_shape)</span>
        <span class="c1"># Reshape eigenvectors if output as matrix</span>
        <span class="k">if</span> <span class="n">vectors_as_matrix</span><span class="p">:</span>
            <span class="n">vect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">vect</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">vect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">vect</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">new_shape</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">select_shape</span><span class="p">(</span><span class="n">obj</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span>
                                        <span class="n">shape_fun</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                        <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">new_shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">new_shape</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">new_shape</span><span class="p">)</span>
                <span class="n">vect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">vect</span><span class="p">,</span> <span class="n">new_shape</span><span class="p">)</span>

        <span class="c1"># Print the result if required</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">draw</span><span class="p">:</span>
            <span class="c1"># Eigenvectors</span>
            <span class="c1"># print_vect = []</span>
            <span class="n">heading</span> <span class="o">=</span> <span class="s1">&#39;The eigenvectors of </span><span class="si">{}</span><span class="s1"> are:&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="c1"># for elem in eigenvectors:</span>
            <span class="c1">#     for ind in range(4):</span>
            <span class="c1">#         print_vect.append(elem[ind, :])</span>
            <span class="c1"># print_vect = reshape(</span>
            <span class="c1">#     print_vect,</span>
            <span class="c1">#     shape_like=shape_like,</span>
            <span class="c1">#     shape_fun=shape,</span>
            <span class="c1">#     obj=self.parent)</span>
            <span class="n">PrintParam</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="n">eigenvectors</span><span class="p">,</span>
                       <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                       <span class="n">title</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;e1 I&#39;</span><span class="p">,</span> <span class="s1">&#39;e1 Q&#39;</span><span class="p">,</span> <span class="s1">&#39;e1 U&#39;</span><span class="p">,</span> <span class="s1">&#39;e1 V&#39;</span><span class="p">,</span> <span class="s1">&#39;e2 I&#39;</span><span class="p">,</span> <span class="s1">&#39;e2 Q&#39;</span><span class="p">,</span>
                              <span class="s1">&#39;e2 U&#39;</span><span class="p">,</span> <span class="s1">&#39;e2 V&#39;</span><span class="p">,</span> <span class="s1">&#39;e3 I&#39;</span><span class="p">,</span> <span class="s1">&#39;e3 Q&#39;</span><span class="p">,</span> <span class="s1">&#39;e3 U&#39;</span><span class="p">,</span> <span class="s1">&#39;e3 V&#39;</span><span class="p">,</span>
                              <span class="s1">&#39;e4 I&#39;</span><span class="p">,</span> <span class="s1">&#39;e4 Q&#39;</span><span class="p">,</span> <span class="s1">&#39;e4 U&#39;</span><span class="p">,</span> <span class="s1">&#39;e4 V&#39;</span><span class="p">),</span>
                       <span class="n">heading</span><span class="o">=</span><span class="n">heading</span><span class="p">,</span>
                       <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                       <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>

        <span class="c1"># Return</span>
        <span class="k">if</span> <span class="n">vectors_as_matrix</span><span class="p">:</span>
            <span class="n">eigenvectors</span> <span class="o">=</span> <span class="n">vect</span>
        <span class="k">return</span> <span class="n">eigenvectors</span></div>

<div class="viewcode-block" id="Parameters_Mueller.eigenstates"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Parameters_Mueller.eigenstates">[docs]</a>    <span class="k">def</span> <span class="nf">eigenstates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                    <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">draw</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the eigenstates of the optical object. It must be done in Jones formalism, so it is only valid for pure Mueller matrices.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>
<span class="sd">            verbose (bool): If True prints the parameter. Default: False.</span>
<span class="sd">            draw (bool): If True and the object is a 1D or 2D, plot it. Default: False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            S1, S2, S3, S4 (Stokes): eigenstates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Calculate the eigenstates in Jones</span>
        <span class="n">J</span> <span class="o">=</span> <span class="n">Jones_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="n">J</span><span class="o">.</span><span class="n">from_Mueller</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="n">shape_like</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>
        <span class="n">E1</span><span class="p">,</span> <span class="n">E2</span> <span class="o">=</span> <span class="n">J</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">eigenstates</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>
        <span class="c1"># Transfrom to Stokes</span>
        <span class="n">S1</span><span class="p">,</span> <span class="n">S2</span> <span class="o">=</span> <span class="n">create_Stokes</span><span class="p">((</span><span class="s1">&#39;1st eigenstate&#39;</span><span class="p">,</span> <span class="s1">&#39;2nd eigenstate&#39;</span><span class="p">))</span>
        <span class="n">S1</span><span class="o">.</span><span class="n">from_Jones</span><span class="p">(</span><span class="n">E1</span><span class="p">)</span>
        <span class="n">S2</span><span class="o">.</span><span class="n">from_Jones</span><span class="p">(</span><span class="n">E2</span><span class="p">)</span>
        <span class="c1"># Print the result if required</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">draw</span><span class="p">:</span>
            <span class="c1"># Extract the info</span>
            <span class="n">heading</span> <span class="o">=</span> <span class="s1">&#39;The eigenstates of </span><span class="si">{}</span><span class="s1"> are:&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">c1</span> <span class="o">=</span> <span class="n">S1</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">components</span><span class="p">()</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">S2</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">components</span><span class="p">()</span>
            <span class="n">components</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">c1</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">c2</span><span class="p">)</span>
            <span class="c1"># Print</span>
            <span class="n">PrintParam</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="n">components</span><span class="p">,</span>
                       <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                       <span class="n">title</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;S1 I&#39;</span><span class="p">,</span> <span class="s1">&#39;S1 Q&#39;</span><span class="p">,</span> <span class="s1">&#39;S1 U&#39;</span><span class="p">,</span> <span class="s1">&#39;S1 V&#39;</span><span class="p">,</span> <span class="s1">&#39;S2 I&#39;</span><span class="p">,</span> <span class="s1">&#39;S2 Q&#39;</span><span class="p">,</span>
                              <span class="s1">&#39;S2 U&#39;</span><span class="p">,</span> <span class="s1">&#39;S2 V&#39;</span><span class="p">),</span>
                       <span class="n">heading</span><span class="o">=</span><span class="n">heading</span><span class="p">,</span>
                       <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                       <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">S1</span><span class="p">,</span> <span class="n">S2</span></div>

<div class="viewcode-block" id="Parameters_Mueller.eigenvalues"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Parameters_Mueller.eigenvalues">[docs]</a>    <span class="k">def</span> <span class="nf">eigenvalues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                    <span class="n">values_as_matrix</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">out_number</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">draw</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the eigenvalues and eigenstates of the Jones object.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            values_as_matrix (bool): If True, the eigenvalues output is a numpy.ndarray instead of a list of arrays. Default: False.</span>
<span class="sd">            out_number (bool): If True and the result is a 1x1 array, return a number instead. Default: True.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>
<span class="sd">            verbose (bool): If True prints the parameter. Default: False.</span>
<span class="sd">            draw (bool): If True and the object is a 1D or 2D, plot it. Default: False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            v (numpy.ndarray): 4xN eigenvalues matrix (if values_as_matrix is True).</span>
<span class="sd">            v1, v2, v3, v4 (numpy.ndarray or float): Individual eigenvalues (if values_as_matrix is False).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Calculate the eigenvalues</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">M</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigvals</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
        <span class="c1"># Order the eigenvalues in the py_pol way</span>
        <span class="k">if</span> <span class="o">~</span><span class="n">values_as_matrix</span> <span class="ow">or</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">draw</span><span class="p">:</span>
            <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">v3</span><span class="p">,</span> <span class="n">v4</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">val</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">val</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">val</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">])</span>
            <span class="c1"># Size 1 objects need some care</span>
            <span class="k">if</span> <span class="n">v1</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">v1</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">v3</span><span class="p">,</span> <span class="n">v4</span> <span class="o">=</span> <span class="p">(</span><span class="n">v1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v3</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v4</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">out_number</span> <span class="ow">and</span> <span class="n">v1</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">v3</span><span class="p">,</span> <span class="n">v4</span> <span class="o">=</span> <span class="p">(</span><span class="n">v1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v3</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v4</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="c1"># Reshape if neccessary</span>
            <span class="n">eigenvalues</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">([</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">v3</span><span class="p">,</span> <span class="n">v4</span><span class="p">],</span>
                                  <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span>
                                  <span class="n">shape_fun</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                  <span class="n">obj</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>
        <span class="c1"># Reshape eigenvalues if output as matrix</span>
        <span class="k">if</span> <span class="n">values_as_matrix</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">new_shape</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">select_shape</span><span class="p">(</span><span class="n">obj</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span>
                                        <span class="n">shape_fun</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                        <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">new_shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">new_shape</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">new_shape</span><span class="p">)</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">new_shape</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">v3</span><span class="p">,</span> <span class="n">v4</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">([</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">v3</span><span class="p">,</span> <span class="n">v4</span><span class="p">],</span>
                                     <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span>
                                     <span class="n">shape_fun</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                     <span class="n">obj</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>
        <span class="c1"># Print the result if required</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">draw</span><span class="p">:</span>
            <span class="c1"># Eigenvalues</span>
            <span class="n">heading</span> <span class="o">=</span> <span class="s1">&#39;The eigenvalues of </span><span class="si">{}</span><span class="s1"> are:&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">PrintParam</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">v3</span><span class="p">,</span> <span class="n">v4</span><span class="p">),</span>
                       <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                       <span class="n">title</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;v1&#39;</span><span class="p">,</span> <span class="s1">&#39;v2&#39;</span><span class="p">,</span> <span class="s1">&#39;v3&#39;</span><span class="p">,</span> <span class="s1">&#39;v4&#39;</span><span class="p">),</span>
                       <span class="n">heading</span><span class="o">=</span><span class="n">heading</span><span class="p">,</span>
                       <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                       <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>

        <span class="c1"># Return</span>
        <span class="k">if</span> <span class="n">values_as_matrix</span><span class="p">:</span>
            <span class="n">eigenvalues</span> <span class="o">=</span> <span class="n">val</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">eigenvalues</span> <span class="o">=</span> <span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">v3</span><span class="p">,</span> <span class="n">v4</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">eigenvalues</span></div>

<div class="viewcode-block" id="Parameters_Mueller.det"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Parameters_Mueller.det">[docs]</a>    <span class="k">def</span> <span class="nf">det</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">out_number</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">draw</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the determinants of the Mueller matrices.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            out_number (bool): If True and the result is a 1x1 array, return a number instead. Default: True.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>
<span class="sd">            verbose (bool): If True prints the parameter. Default: False.</span>
<span class="sd">            draw (bool): If True and the object is a 1D or 2D, plot it. Default: False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (numpy.ndarray, float or complex): Result.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Calculate the eigenstates</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">M</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">det</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
        <span class="c1"># If the result is a number and the user asks for it, return a float</span>
        <span class="k">if</span> <span class="n">out_number</span> <span class="ow">and</span> <span class="n">det</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">det</span> <span class="o">=</span> <span class="n">det</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Reshape if neccessary</span>
        <span class="n">det</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">([</span><span class="n">det</span><span class="p">],</span>
                      <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span>
                      <span class="n">shape_fun</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                      <span class="n">obj</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>
        <span class="c1"># Print the result if required</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">draw</span><span class="p">:</span>
            <span class="n">heading</span> <span class="o">=</span> <span class="s1">&#39;The determinant of </span><span class="si">{}</span><span class="s1"> is:&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">PrintParam</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="n">det</span><span class="p">,</span>
                       <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                       <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Determinant&#39;</span><span class="p">,</span>
                       <span class="n">heading</span><span class="o">=</span><span class="n">heading</span><span class="p">,</span>
                       <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                       <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">det</span></div>

<div class="viewcode-block" id="Parameters_Mueller.trace"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Parameters_Mueller.trace">[docs]</a>    <span class="k">def</span> <span class="nf">trace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
              <span class="n">out_number</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
              <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
              <span class="n">draw</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the trace of the Mueller matrices.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            out_number (bool): If True and the result is a 1x1 array, return a number instead. Default: True.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>
<span class="sd">            verbose (bool): If True prints the parameter. Default: False.</span>
<span class="sd">            draw (bool): If True and the object is a 1D or 2D, plot it. Default: False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (numpy.ndarray or float): Result.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Calculate the eigenstates</span>
        <span class="n">trace</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">M</span><span class="p">)</span>
        <span class="c1"># If the result is a number and the user asks for it, return a float</span>
        <span class="k">if</span> <span class="n">out_number</span> <span class="ow">and</span> <span class="n">trace</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">trace</span> <span class="o">=</span> <span class="n">trace</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Reshape if neccessary</span>
        <span class="n">trace</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">([</span><span class="n">trace</span><span class="p">],</span>
                        <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span>
                        <span class="n">shape_fun</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                        <span class="n">obj</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>
        <span class="c1"># Print the result if required</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">draw</span><span class="p">:</span>
            <span class="n">heading</span> <span class="o">=</span> <span class="s1">&#39;The trace of </span><span class="si">{}</span><span class="s1"> is:&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">PrintParam</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="n">trace</span><span class="p">,</span>
                       <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                       <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Trace&#39;</span><span class="p">,</span>
                       <span class="n">heading</span><span class="o">=</span><span class="n">heading</span><span class="p">,</span>
                       <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                       <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">trace</span></div>

<div class="viewcode-block" id="Parameters_Mueller.norm"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Parameters_Mueller.norm">[docs]</a>    <span class="k">def</span> <span class="nf">norm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
             <span class="n">out_number</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
             <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
             <span class="n">draw</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the Frobenius norm of the Mueller matrices.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            out_number (bool): If True and the result is a 1x1 array, return a number instead. Default: True.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>
<span class="sd">            verbose (bool): If True prints the parameter. Default: False.</span>
<span class="sd">            draw (bool): If True and the object is a 1D or 2D, plot it. Default: False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (numpy.ndarray, float or complex): Result.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Calculate the eigenstates</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">M</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="c1"># If the result is a number and the user asks for it, return a float</span>
        <span class="k">if</span> <span class="n">out_number</span> <span class="ow">and</span> <span class="n">norm</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">norm</span> <span class="o">=</span> <span class="n">norm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Reshape if neccessary</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">([</span><span class="n">norm</span><span class="p">],</span>
                       <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span>
                       <span class="n">shape_fun</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                       <span class="n">obj</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>
        <span class="c1"># Print the result if required</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">draw</span><span class="p">:</span>
            <span class="n">heading</span> <span class="o">=</span> <span class="s1">&#39;The norm of </span><span class="si">{}</span><span class="s1"> is:&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">PrintParam</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span>
                       <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                       <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Norm&#39;</span><span class="p">,</span>
                       <span class="n">heading</span><span class="o">=</span><span class="n">heading</span><span class="p">,</span>
                       <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                       <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">norm</span></div></div>


<div class="viewcode-block" id="Analysis_Mueller"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Analysis_Mueller">[docs]</a><span class="k">class</span> <span class="nc">Analysis_Mueller</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class for Analysis of Mueller Analysis</span>

<span class="sd">    Parameters:</span>
<span class="sd">        mueller_matrix (Mueller_matrix): Mueller Matrix</span>

<span class="sd">    Attributes:</span>
<span class="sd">        self.marent (Mueller): parent object.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span>

<div class="viewcode-block" id="Analysis_Mueller.depolarizer"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Analysis_Mueller.depolarizer">[docs]</a>    <span class="k">def</span> <span class="nf">depolarizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                    <span class="n">transmissions</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span>
                    <span class="n">angles</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">,</span>
                    <span class="n">depolarization</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span>
                    <span class="n">out_number</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">draw</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates some of the parameters from the Mueller matrix of a diattenuator.</span>

<span class="sd">        References:</span>
<span class="sd">            J.J. Gil, R. Ossikovsky &quot;Polarized light and the Mueller Matrix approach&quot;, CRC Press (2016)</span>

<span class="sd">        Parameters:</span>
<span class="sd">            transmissions (string): Determines the type of transmission output, FIELD, INTENSITY or ALL. Default: All.</span>
<span class="sd">            angles (string): Determines the type of angles output, CHARAC (characteristic angles), AZIMUTH (azimuth and ellipticity) or ALL. Default: All.</span>
<span class="sd">            depolarization (string): Determines the type of depolarization information: INDEX, FACTORS or ALL. Default: All.</span>
<span class="sd">            out_number (bool): If True and the result is a 1x1 array, return a number instead. Default: True.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>
<span class="sd">            verbose (bool): If True prints the parameter. Default: False.</span>
<span class="sd">            draw (bool): If True and the object is a 1D or 2D, plot it. Default: False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            trans_D, transP (list). Transmissions calculated from the diattenuation and polarizance vectors (in that order). Depending on the input parameter transmissions, it can contain the field transmissions, the intensity transmissions or both.</span>
<span class="sd">            angles_D, angles_P (list). Angles of the transmission eigenstate calculated from the diattenuation and polarizance vectors respectively. Depending on the input parameter angles, it can contain the characteristic angles, the azimuth and ellipticity, or all of them.</span>
<span class="sd">            depol (numpy.ndarray or float): Depolarization index.</span>
<span class="sd">            S (list): List with the three principal states.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Extract the information</span>
        <span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">diattenuation</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                                 <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span>
                                                 <span class="n">out_number</span><span class="o">=</span><span class="n">out_number</span><span class="p">)</span>
        <span class="n">Dv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">diattenuation_vector</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                                         <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>
        <span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">polarizance</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                               <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span>
                                               <span class="n">out_number</span><span class="o">=</span><span class="n">out_number</span><span class="p">)</span>
        <span class="n">Pv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">polarizance_vector</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                                       <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>
        <span class="n">M00</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">mean_transmission</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                                       <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span>
                                                       <span class="n">out_number</span><span class="o">=</span><span class="n">out_number</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">small_matrix</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">depol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">depolarization_index</span><span class="p">(</span>
            <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span> <span class="n">out_number</span><span class="o">=</span><span class="n">out_number</span><span class="p">)</span>

        <span class="c1"># Calculate transmissions</span>
        <span class="n">Tmax</span> <span class="o">=</span> <span class="n">M00</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">D</span><span class="p">)</span>
        <span class="n">Tmin</span> <span class="o">=</span> <span class="n">M00</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">D</span><span class="p">)</span>
        <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Tmax</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Tmin</span><span class="p">))</span>
        <span class="n">trans_D</span><span class="p">,</span> <span class="n">title_trans</span> <span class="o">=</span> <span class="p">([],</span> <span class="p">[])</span>
        <span class="k">if</span> <span class="n">transmissions</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;ALL&#39;</span><span class="p">,</span> <span class="s1">&#39;All&#39;</span><span class="p">,</span> <span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="s1">&#39;INTENSITY&#39;</span><span class="p">,</span> <span class="s1">&#39;Intensity&#39;</span><span class="p">,</span>
                             <span class="s1">&#39;intensity&#39;</span><span class="p">):</span>
            <span class="n">trans_D</span> <span class="o">+=</span> <span class="p">[</span><span class="n">Tmax</span><span class="p">,</span> <span class="n">Tmin</span><span class="p">]</span>
            <span class="n">title_trans</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;Max. transmission&#39;</span><span class="p">,</span> <span class="s1">&#39;Min. transmission&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">transmissions</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;ALL&#39;</span><span class="p">,</span> <span class="s1">&#39;All&#39;</span><span class="p">,</span> <span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="s1">&#39;FIELD&#39;</span><span class="p">,</span> <span class="s1">&#39;Field&#39;</span><span class="p">,</span> <span class="s1">&#39;field&#39;</span><span class="p">):</span>
            <span class="n">trans_D</span> <span class="o">+=</span> <span class="p">[</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">]</span>
            <span class="n">title_trans</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;p1&#39;</span><span class="p">,</span> <span class="s1">&#39;p2&#39;</span><span class="p">]</span>

        <span class="n">Tmax</span> <span class="o">=</span> <span class="n">M00</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">P</span><span class="p">)</span>
        <span class="n">Tmin</span> <span class="o">=</span> <span class="n">M00</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">P</span><span class="p">)</span>
        <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Tmax</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Tmin</span><span class="p">))</span>
        <span class="n">trans_P</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">transmissions</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;ALL&#39;</span><span class="p">,</span> <span class="s1">&#39;All&#39;</span><span class="p">,</span> <span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="s1">&#39;INTENSITY&#39;</span><span class="p">,</span> <span class="s1">&#39;Intensity&#39;</span><span class="p">,</span>
                             <span class="s1">&#39;intensity&#39;</span><span class="p">):</span>
            <span class="n">trans_P</span> <span class="o">+=</span> <span class="p">[</span><span class="n">Tmax</span><span class="p">,</span> <span class="n">Tmin</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">transmissions</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;ALL&#39;</span><span class="p">,</span> <span class="s1">&#39;All&#39;</span><span class="p">,</span> <span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="s1">&#39;FIELD&#39;</span><span class="p">,</span> <span class="s1">&#39;Field&#39;</span><span class="p">,</span> <span class="s1">&#39;field&#39;</span><span class="p">):</span>
            <span class="n">trans_P</span> <span class="o">+=</span> <span class="p">[</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">]</span>

        <span class="c1"># Calculate angles</span>
        <span class="n">azimuth</span><span class="p">,</span> <span class="n">ellipticity</span> <span class="o">=</span> <span class="n">extract_azimuth_elipt</span><span class="p">(</span><span class="n">Dv</span><span class="p">,</span> <span class="n">use_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">alpha</span><span class="p">,</span> <span class="n">delay</span> <span class="o">=</span> <span class="n">azimuth_elipt_2_charac_angles</span><span class="p">(</span><span class="n">azimuth</span><span class="p">,</span> <span class="n">ellipticity</span><span class="p">)</span>
        <span class="n">ang_D</span><span class="p">,</span> <span class="n">title_ang</span> <span class="o">=</span> <span class="p">([],</span> <span class="p">[])</span>
        <span class="k">if</span> <span class="n">angles</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;ALL&#39;</span><span class="p">,</span> <span class="s1">&#39;All&#39;</span><span class="p">,</span> <span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="s1">&#39;CHARAC&#39;</span><span class="p">,</span> <span class="s1">&#39;Charac&#39;</span><span class="p">,</span> <span class="s1">&#39;charac&#39;</span><span class="p">):</span>
            <span class="n">ang_D</span> <span class="o">+=</span> <span class="p">[</span><span class="n">alpha</span><span class="p">,</span> <span class="n">delay</span><span class="p">]</span>
            <span class="n">title_ang</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;Alpha&#39;</span><span class="p">,</span> <span class="s1">&#39;Delay&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">angles</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;ALL&#39;</span><span class="p">,</span> <span class="s1">&#39;All&#39;</span><span class="p">,</span> <span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="s1">&#39;AZIMUTH&#39;</span><span class="p">,</span> <span class="s1">&#39;Azimuth&#39;</span><span class="p">,</span> <span class="s1">&#39;azimuth&#39;</span><span class="p">):</span>
            <span class="n">ang_D</span> <span class="o">+=</span> <span class="p">[</span><span class="n">azimuth</span><span class="p">,</span> <span class="n">ellipticity</span><span class="p">]</span>
            <span class="n">title_ang</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;Azimuth&#39;</span><span class="p">,</span> <span class="s1">&#39;Ellipticity angle&#39;</span><span class="p">]</span>

        <span class="n">azimuth</span><span class="p">,</span> <span class="n">ellipticity</span> <span class="o">=</span> <span class="n">extract_azimuth_elipt</span><span class="p">(</span><span class="n">Pv</span><span class="p">,</span> <span class="n">use_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">alpha</span><span class="p">,</span> <span class="n">delay</span> <span class="o">=</span> <span class="n">azimuth_elipt_2_charac_angles</span><span class="p">(</span><span class="n">azimuth</span><span class="p">,</span> <span class="n">ellipticity</span><span class="p">)</span>
        <span class="n">ang_P</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">angles</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;ALL&#39;</span><span class="p">,</span> <span class="s1">&#39;All&#39;</span><span class="p">,</span> <span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="s1">&#39;CHARAC&#39;</span><span class="p">,</span> <span class="s1">&#39;Charac&#39;</span><span class="p">,</span> <span class="s1">&#39;charac&#39;</span><span class="p">):</span>
            <span class="n">ang_P</span> <span class="o">+=</span> <span class="p">[</span><span class="n">alpha</span><span class="p">,</span> <span class="n">delay</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">angles</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;ALL&#39;</span><span class="p">,</span> <span class="s1">&#39;All&#39;</span><span class="p">,</span> <span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="s1">&#39;AZIMUTH&#39;</span><span class="p">,</span> <span class="s1">&#39;Azimuth&#39;</span><span class="p">,</span> <span class="s1">&#39;azimuth&#39;</span><span class="p">):</span>
            <span class="n">ang_P</span> <span class="o">+=</span> <span class="p">[</span><span class="n">azimuth</span><span class="p">,</span> <span class="n">ellipticity</span><span class="p">]</span>

        <span class="c1"># Calculate depolarization factors and eigenstates</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">val</span><span class="p">,</span> <span class="n">vect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
        <span class="c1"># val, vect = order_eig(val, vect, &#39;reverse&#39;)</span>
        <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">,</span> <span class="n">d3</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">val</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">val</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span>
        <span class="n">S1</span><span class="p">,</span> <span class="n">S2</span><span class="p">,</span> <span class="n">S3</span> <span class="o">=</span> <span class="n">create_Stokes</span><span class="p">(</span>
            <span class="p">(</span><span class="s1">&#39;First principal state&#39;</span><span class="p">,</span> <span class="s1">&#39;Second principal state&#39;</span><span class="p">,</span>
             <span class="s1">&#39;Third principal state&#39;</span><span class="p">))</span>
        <span class="n">S1</span><span class="o">.</span><span class="n">from_components</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">vect</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">vect</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">vect</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
        <span class="n">S2</span><span class="o">.</span><span class="n">from_components</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">vect</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">vect</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">vect</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
        <span class="n">S3</span><span class="o">.</span><span class="n">from_components</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">vect</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">vect</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">vect</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
        <span class="c1"># Reshaoe them</span>
        <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">,</span> <span class="n">d3</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">([</span><span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">,</span> <span class="n">d3</span><span class="p">],</span>
                             <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span>
                             <span class="n">shape_fun</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                             <span class="n">obj</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>
        <span class="n">S1</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">select_shape</span><span class="p">(</span><span class="n">obj</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span>
                                         <span class="n">shape_fun</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                         <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>
        <span class="n">S2</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">select_shape</span><span class="p">(</span><span class="n">obj</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span>
                                         <span class="n">shape_fun</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                         <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>
        <span class="n">S3</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">select_shape</span><span class="p">(</span><span class="n">obj</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span>
                                         <span class="n">shape_fun</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                         <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>
        <span class="c1"># Save them</span>
        <span class="n">principal_states</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">depolar</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">depolarization</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;ALL&#39;</span><span class="p">,</span> <span class="s1">&#39;INDEX&#39;</span><span class="p">):</span>
            <span class="n">depolar</span> <span class="o">+=</span> <span class="p">[</span><span class="n">depol</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">depolarization</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;ALL&#39;</span><span class="p">,</span> <span class="s1">&#39;FACTORS&#39;</span><span class="p">):</span>
            <span class="n">depolar</span> <span class="o">=</span> <span class="p">[</span><span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">,</span> <span class="n">d3</span><span class="p">]</span>
            <span class="n">principal_states</span> <span class="o">+=</span> <span class="p">[</span><span class="n">S1</span><span class="p">,</span> <span class="n">S2</span><span class="p">,</span> <span class="n">S3</span><span class="p">]</span>

        <span class="c1"># Print the result if required</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">draw</span><span class="p">:</span>
            <span class="c1"># Transform angles to degrees for representation</span>
            <span class="n">angles_rep_D</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">ang_D</span><span class="p">:</span>
                <span class="n">angles_rep_D</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span> <span class="o">/</span> <span class="n">degrees</span><span class="p">)</span>
            <span class="n">angles_rep_P</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">ang_P</span><span class="p">:</span>
                <span class="n">angles_rep_P</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span> <span class="o">/</span> <span class="n">degrees</span><span class="p">)</span>

            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Analysis of </span><span class="si">{}</span><span class="s1"> as depolarizer:&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

            <span class="c1"># Depolarization index</span>
            <span class="k">if</span> <span class="n">depolarization</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;ALL&#39;</span><span class="p">,</span> <span class="s1">&#39;INDEX&#39;</span><span class="p">):</span>
                <span class="n">heading</span> <span class="o">=</span> <span class="s1">&#39;- Depolarization index of </span><span class="si">{}</span><span class="s1"> is:&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="n">PrintParam</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="p">[</span><span class="n">depol</span><span class="p">],</span>
                           <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                           <span class="n">title</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;Depolarization index&#39;</span><span class="p">),</span>
                           <span class="n">heading</span><span class="o">=</span><span class="n">heading</span><span class="p">,</span>
                           <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                           <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
            <span class="c1"># Depolarization factors and eigenstates</span>
            <span class="k">if</span> <span class="n">depolarization</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;ALL&#39;</span><span class="p">,</span> <span class="s1">&#39;FACTORS&#39;</span><span class="p">):</span>
                <span class="n">heading</span> <span class="o">=</span> <span class="s1">&#39;- First depolarization factor of </span><span class="si">{}</span><span class="s1"> is:&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="n">PrintParam</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="p">[</span><span class="n">d1</span><span class="p">],</span>
                           <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                           <span class="n">title</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;1st depolarization factor&#39;</span><span class="p">),</span>
                           <span class="n">heading</span><span class="o">=</span><span class="n">heading</span><span class="p">,</span>
                           <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                           <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">angles</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;ALL&#39;</span><span class="p">,</span> <span class="s1">&#39;All&#39;</span><span class="p">,</span> <span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="s1">&#39;CHARAC&#39;</span><span class="p">,</span> <span class="s1">&#39;Charac&#39;</span><span class="p">,</span>
                              <span class="s1">&#39;charac&#39;</span><span class="p">):</span>
                    <span class="n">_</span> <span class="o">=</span> <span class="n">S1</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">charac_angles</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">angles</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;ALL&#39;</span><span class="p">,</span> <span class="s1">&#39;All&#39;</span><span class="p">,</span> <span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="s1">&#39;AZIMUTH&#39;</span><span class="p">,</span> <span class="s1">&#39;Azimuth&#39;</span><span class="p">,</span>
                              <span class="s1">&#39;azimuth&#39;</span><span class="p">):</span>
                    <span class="n">_</span> <span class="o">=</span> <span class="n">S1</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">azimuth_ellipticity</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                                                          <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>

                <span class="n">heading</span> <span class="o">=</span> <span class="s1">&#39;- Second depolarization factor of </span><span class="si">{}</span><span class="s1"> is:&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="n">PrintParam</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="p">[</span><span class="n">d2</span><span class="p">],</span>
                           <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                           <span class="n">title</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;2nd depolarization factor&#39;</span><span class="p">),</span>
                           <span class="n">heading</span><span class="o">=</span><span class="n">heading</span><span class="p">,</span>
                           <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                           <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">angles</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;ALL&#39;</span><span class="p">,</span> <span class="s1">&#39;All&#39;</span><span class="p">,</span> <span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="s1">&#39;CHARAC&#39;</span><span class="p">,</span> <span class="s1">&#39;Charac&#39;</span><span class="p">,</span>
                              <span class="s1">&#39;charac&#39;</span><span class="p">):</span>
                    <span class="n">_</span> <span class="o">=</span> <span class="n">S2</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">charac_angles</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">angles</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;ALL&#39;</span><span class="p">,</span> <span class="s1">&#39;All&#39;</span><span class="p">,</span> <span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="s1">&#39;AZIMUTH&#39;</span><span class="p">,</span> <span class="s1">&#39;Azimuth&#39;</span><span class="p">,</span>
                              <span class="s1">&#39;azimuth&#39;</span><span class="p">):</span>
                    <span class="n">_</span> <span class="o">=</span> <span class="n">S2</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">azimuth_ellipticity</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                                                          <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>

                <span class="n">heading</span> <span class="o">=</span> <span class="s1">&#39;- Third depolarization factor of </span><span class="si">{}</span><span class="s1"> is:&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="n">PrintParam</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="p">[</span><span class="n">d3</span><span class="p">],</span>
                           <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                           <span class="n">title</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;3rd depolarization factor&#39;</span><span class="p">),</span>
                           <span class="n">heading</span><span class="o">=</span><span class="n">heading</span><span class="p">,</span>
                           <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                           <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">angles</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;ALL&#39;</span><span class="p">,</span> <span class="s1">&#39;All&#39;</span><span class="p">,</span> <span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="s1">&#39;CHARAC&#39;</span><span class="p">,</span> <span class="s1">&#39;Charac&#39;</span><span class="p">,</span>
                              <span class="s1">&#39;charac&#39;</span><span class="p">):</span>
                    <span class="n">_</span> <span class="o">=</span> <span class="n">S3</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">charac_angles</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">angles</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;ALL&#39;</span><span class="p">,</span> <span class="s1">&#39;All&#39;</span><span class="p">,</span> <span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="s1">&#39;AZIMUTH&#39;</span><span class="p">,</span> <span class="s1">&#39;Azimuth&#39;</span><span class="p">,</span>
                              <span class="s1">&#39;azimuth&#39;</span><span class="p">):</span>
                    <span class="n">_</span> <span class="o">=</span> <span class="n">S3</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">azimuth_ellipticity</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                                                          <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>

            <span class="c1"># Depolarizers usually have only diattenuation or polarizance.</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">D</span> <span class="o">&gt;</span> <span class="n">tol_default</span><span class="p">):</span>
                <span class="n">heading</span> <span class="o">=</span> <span class="s1">&#39;- Transmissions of </span><span class="si">{}</span><span class="s1"> from diattenuation are:&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="n">PrintParam</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="n">trans_D</span><span class="p">,</span>
                           <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                           <span class="n">title</span><span class="o">=</span><span class="n">title_trans</span><span class="p">,</span>
                           <span class="n">heading</span><span class="o">=</span><span class="n">heading</span><span class="p">,</span>
                           <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                           <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
                <span class="n">heading</span> <span class="o">=</span> <span class="s1">&#39;- Angles of </span><span class="si">{}</span><span class="s1"> from polarizance are:&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="n">PrintParam</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="n">angles_rep_P</span><span class="p">,</span>
                           <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                           <span class="n">title</span><span class="o">=</span><span class="n">title_ang</span><span class="p">,</span>
                           <span class="n">heading</span><span class="o">=</span><span class="n">heading</span><span class="p">,</span>
                           <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                           <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;- </span><span class="si">{}</span><span class="s1"> has no diattenuation.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">P</span> <span class="o">&gt;</span> <span class="n">tol_default</span><span class="p">):</span>
                <span class="n">heading</span> <span class="o">=</span> <span class="s1">&#39;- Transmissions of </span><span class="si">{}</span><span class="s1"> from polarizance are:&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="n">PrintParam</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="n">trans_P</span><span class="p">,</span>
                           <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                           <span class="n">title</span><span class="o">=</span><span class="n">title_trans</span><span class="p">,</span>
                           <span class="n">heading</span><span class="o">=</span><span class="n">heading</span><span class="p">,</span>
                           <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                           <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
                <span class="n">heading</span> <span class="o">=</span> <span class="s1">&#39;- Angles of </span><span class="si">{}</span><span class="s1"> from diattenuation are:&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="n">PrintParam</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="n">angles_rep_D</span><span class="p">,</span>
                           <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                           <span class="n">title</span><span class="o">=</span><span class="n">title_ang</span><span class="p">,</span>
                           <span class="n">heading</span><span class="o">=</span><span class="n">heading</span><span class="p">,</span>
                           <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                           <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;- </span><span class="si">{}</span><span class="s1"> has no polarizance.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

        <span class="c1"># Output</span>
        <span class="k">return</span> <span class="n">trans_D</span><span class="p">,</span> <span class="n">trans_P</span><span class="p">,</span> <span class="n">ang_D</span><span class="p">,</span> <span class="n">ang_P</span><span class="p">,</span> <span class="n">depolar</span><span class="p">,</span> <span class="n">principal_states</span></div>

<div class="viewcode-block" id="Analysis_Mueller.diattenuator"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Analysis_Mueller.diattenuator">[docs]</a>    <span class="k">def</span> <span class="nf">diattenuator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                     <span class="n">transmissions</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span>
                     <span class="n">angles</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">,</span>
                     <span class="n">out_number</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                     <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                     <span class="n">draw</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates all the parameters from the Mueller Matrix of a pure homogeneous diattenuator (using the diattenuance vector). If the object is not a pure homogenous diattenuator, some parameters may be wrong.</span>

<span class="sd">        References:</span>
<span class="sd">            J.J. Gil, R. Ossikovsky &quot;Polarized light and the Mueller Matrix approach&quot;, CRC Press (2016)</span>

<span class="sd">        Parameters:</span>
<span class="sd">            transmissions (string): Determines the type of transmission output, FIELD, INTENSITY or ALL. Default: All.</span>
<span class="sd">            angles (string): Determines the type of angles output, CHARAC (characteristic angles), AZIMUTH (azimuth and ellipticity) or ALL. Default: All.</span>
<span class="sd">            out_number (bool): If True and the result is a 1x1 array, return a number instead. Default: True.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>
<span class="sd">            verbose (bool): If True prints the parameter. Default: False.</span>
<span class="sd">            draw (bool): If True and the object is a 1D or 2D, plot it. Default: False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            transmissions (list). Transmissions of the diattenuator. Depending on the input parameter transmissions, it can contain the field transmissions, the intensity transmissions or both.</span>
<span class="sd">            angles (list). Angles of the transmission eigenstate. Depending on the input parameter angles, it can contain the characteristic angles, the azimuth and ellipticity, or all of them.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Extract the diattenuation and diattenuation vector</span>
        <span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">diattenuation</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                                 <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span>
                                                 <span class="n">out_number</span><span class="o">=</span><span class="n">out_number</span><span class="p">)</span>
        <span class="n">Dv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">diattenuation_vector</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                                         <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>
        <span class="n">M00</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">mean_transmission</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                                       <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span>
                                                       <span class="n">out_number</span><span class="o">=</span><span class="n">out_number</span><span class="p">)</span>

        <span class="c1"># Calculate transmissions</span>
        <span class="n">Tmax</span> <span class="o">=</span> <span class="n">M00</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">D</span><span class="p">)</span>
        <span class="n">Tmin</span> <span class="o">=</span> <span class="n">M00</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">D</span><span class="p">)</span>
        <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Tmax</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Tmin</span><span class="p">))</span>
        <span class="n">trans</span><span class="p">,</span> <span class="n">title_trans</span> <span class="o">=</span> <span class="p">([],</span> <span class="p">[])</span>
        <span class="k">if</span> <span class="n">transmissions</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;ALL&#39;</span><span class="p">,</span> <span class="s1">&#39;All&#39;</span><span class="p">,</span> <span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="s1">&#39;INTENSITY&#39;</span><span class="p">,</span> <span class="s1">&#39;Intensity&#39;</span><span class="p">,</span>
                             <span class="s1">&#39;intensity&#39;</span><span class="p">):</span>
            <span class="n">trans</span> <span class="o">+=</span> <span class="p">[</span><span class="n">Tmax</span><span class="p">,</span> <span class="n">Tmin</span><span class="p">]</span>
            <span class="n">title_trans</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;Max. transmission&#39;</span><span class="p">,</span> <span class="s1">&#39;Min. transmission&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">transmissions</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;ALL&#39;</span><span class="p">,</span> <span class="s1">&#39;All&#39;</span><span class="p">,</span> <span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="s1">&#39;FIELD&#39;</span><span class="p">,</span> <span class="s1">&#39;Field&#39;</span><span class="p">,</span> <span class="s1">&#39;field&#39;</span><span class="p">):</span>
            <span class="n">trans</span> <span class="o">+=</span> <span class="p">[</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">]</span>
            <span class="n">title_trans</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;p1&#39;</span><span class="p">,</span> <span class="s1">&#39;p2&#39;</span><span class="p">]</span>

        <span class="c1"># Calculate angles</span>
        <span class="n">azimuth</span><span class="p">,</span> <span class="n">ellipticity</span> <span class="o">=</span> <span class="n">extract_azimuth_elipt</span><span class="p">(</span><span class="n">Dv</span><span class="p">,</span> <span class="n">use_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">alpha</span><span class="p">,</span> <span class="n">delay</span> <span class="o">=</span> <span class="n">azimuth_elipt_2_charac_angles</span><span class="p">(</span><span class="n">azimuth</span><span class="p">,</span> <span class="n">ellipticity</span><span class="p">)</span>
        <span class="n">ang</span><span class="p">,</span> <span class="n">title_ang</span> <span class="o">=</span> <span class="p">([],</span> <span class="p">[])</span>
        <span class="k">if</span> <span class="n">angles</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;ALL&#39;</span><span class="p">,</span> <span class="s1">&#39;All&#39;</span><span class="p">,</span> <span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="s1">&#39;CHARAC&#39;</span><span class="p">,</span> <span class="s1">&#39;Charac&#39;</span><span class="p">,</span> <span class="s1">&#39;charac&#39;</span><span class="p">):</span>
            <span class="n">ang</span> <span class="o">+=</span> <span class="p">[</span><span class="n">alpha</span><span class="p">,</span> <span class="n">delay</span><span class="p">]</span>
            <span class="n">title_ang</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;Alpha&#39;</span><span class="p">,</span> <span class="s1">&#39;Delay&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">angles</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;ALL&#39;</span><span class="p">,</span> <span class="s1">&#39;All&#39;</span><span class="p">,</span> <span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="s1">&#39;AZIMUTH&#39;</span><span class="p">,</span> <span class="s1">&#39;Azimuth&#39;</span><span class="p">,</span> <span class="s1">&#39;azimuth&#39;</span><span class="p">):</span>
            <span class="n">ang</span> <span class="o">+=</span> <span class="p">[</span><span class="n">azimuth</span><span class="p">,</span> <span class="n">ellipticity</span><span class="p">]</span>
            <span class="n">title_ang</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;Azimuth&#39;</span><span class="p">,</span> <span class="s1">&#39;Ellipticity angle&#39;</span><span class="p">]</span>

        <span class="c1"># Print the result if required</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">draw</span><span class="p">:</span>
            <span class="c1"># Transform angles to degrees for representation</span>
            <span class="n">angles_rep</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">ang</span><span class="p">:</span>
                <span class="n">angles_rep</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span> <span class="o">/</span> <span class="n">degrees</span><span class="p">)</span>

            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Analysis of </span><span class="si">{}</span><span class="s1"> as diattenuator:</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
            <span class="n">heading</span> <span class="o">=</span> <span class="s1">&#39;- Transmissions of </span><span class="si">{}</span><span class="s1"> are:&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">PrintParam</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="n">trans</span><span class="p">,</span>
                       <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                       <span class="n">title</span><span class="o">=</span><span class="n">title_trans</span><span class="p">,</span>
                       <span class="n">heading</span><span class="o">=</span><span class="n">heading</span><span class="p">,</span>
                       <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                       <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
            <span class="n">heading</span> <span class="o">=</span> <span class="s1">&#39;- Angles of </span><span class="si">{}</span><span class="s1"> are:&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

            <span class="n">PrintParam</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="n">angles_rep</span><span class="p">,</span>
                       <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                       <span class="n">title</span><span class="o">=</span><span class="n">title_ang</span><span class="p">,</span>
                       <span class="n">heading</span><span class="o">=</span><span class="n">heading</span><span class="p">,</span>
                       <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                       <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>

        <span class="c1"># Output</span>
        <span class="k">return</span> <span class="n">trans</span><span class="p">,</span> <span class="n">ang</span></div>

<div class="viewcode-block" id="Analysis_Mueller.polarizer"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Analysis_Mueller.polarizer">[docs]</a>    <span class="k">def</span> <span class="nf">polarizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                  <span class="n">transmissions</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span>
                  <span class="n">angles</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">,</span>
                  <span class="n">out_number</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                  <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                  <span class="n">draw</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates all the parameters from the Mueller Matrix of a pure homogeneous diattenuator (using the polarizance vector). If the object is not a pure homogenous diattenuator, some parameters may be wrong.</span>

<span class="sd">        References:</span>
<span class="sd">            J.J. Gil, R. Ossikovsky &quot;Polarized light and the Mueller Matrix approach&quot;, CRC Press (2016)</span>

<span class="sd">        Parameters:</span>
<span class="sd">            transmissions (string): Determines the type of transmission output, FIELD, INTENSITY or ALL. Default: All.</span>
<span class="sd">            angles (string): Determines the type of angles output, CHARAC (characteristic angles), AZIMUTH (azimuth and ellipticity) or ALL. Default: All.</span>
<span class="sd">            out_number (bool): If True and the result is a 1x1 array, return a number instead. Default: True.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>
<span class="sd">            verbose (bool): If True prints the parameter. Default: False.</span>
<span class="sd">            draw (bool): If True and the object is a 1D or 2D, plot it. Default: False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            transmissions (list). Transmissions of the diattenuator. Depending on the input parameter transmissions, it can contain the field transmissions, the intensity transmissions or both.</span>
<span class="sd">            angles (list). Angles of the transmission eigenstate. Depending on the input parameter angles, it can contain the characteristic angles, the azimuth and ellipticity, or all of them.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Extract the diattenuation and diattenuation vector</span>
        <span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">polarizance</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                               <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span>
                                               <span class="n">out_number</span><span class="o">=</span><span class="n">out_number</span><span class="p">)</span>
        <span class="n">Pv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">polarizance_vector</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                                       <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>
        <span class="n">M00</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">mean_transmission</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                                       <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span>
                                                       <span class="n">out_number</span><span class="o">=</span><span class="n">out_number</span><span class="p">)</span>

        <span class="c1"># Calculate transmissions</span>
        <span class="n">Tmax</span> <span class="o">=</span> <span class="n">M00</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">P</span><span class="p">)</span>
        <span class="n">Tmin</span> <span class="o">=</span> <span class="n">M00</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">P</span><span class="p">)</span>
        <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Tmax</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Tmin</span><span class="p">))</span>
        <span class="n">trans</span><span class="p">,</span> <span class="n">title_trans</span> <span class="o">=</span> <span class="p">([],</span> <span class="p">[])</span>
        <span class="k">if</span> <span class="n">transmissions</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;ALL&#39;</span><span class="p">,</span> <span class="s1">&#39;All&#39;</span><span class="p">,</span> <span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="s1">&#39;INTENSITY&#39;</span><span class="p">,</span> <span class="s1">&#39;Intensity&#39;</span><span class="p">,</span>
                             <span class="s1">&#39;intensity&#39;</span><span class="p">):</span>
            <span class="n">trans</span> <span class="o">+=</span> <span class="p">[</span><span class="n">Tmax</span><span class="p">,</span> <span class="n">Tmin</span><span class="p">]</span>
            <span class="n">title_trans</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;Max. transmission&#39;</span><span class="p">,</span> <span class="s1">&#39;Min. transmission&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">transmissions</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;ALL&#39;</span><span class="p">,</span> <span class="s1">&#39;All&#39;</span><span class="p">,</span> <span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="s1">&#39;FIELD&#39;</span><span class="p">,</span> <span class="s1">&#39;Field&#39;</span><span class="p">,</span> <span class="s1">&#39;field&#39;</span><span class="p">):</span>
            <span class="n">trans</span> <span class="o">+=</span> <span class="p">[</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">]</span>
            <span class="n">title_trans</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;p1&#39;</span><span class="p">,</span> <span class="s1">&#39;p2&#39;</span><span class="p">]</span>

        <span class="c1"># Calculate angles</span>
        <span class="n">azimuth</span><span class="p">,</span> <span class="n">ellipticity</span> <span class="o">=</span> <span class="n">extract_azimuth_elipt</span><span class="p">(</span><span class="n">Pv</span><span class="p">)</span>
        <span class="n">alpha</span><span class="p">,</span> <span class="n">delay</span> <span class="o">=</span> <span class="n">azimuth_elipt_2_charac_angles</span><span class="p">(</span><span class="n">azimuth</span><span class="p">,</span> <span class="n">ellipticity</span><span class="p">)</span>
        <span class="n">ang</span><span class="p">,</span> <span class="n">title_ang</span> <span class="o">=</span> <span class="p">([],</span> <span class="p">[])</span>
        <span class="k">if</span> <span class="n">angles</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;ALL&#39;</span><span class="p">,</span> <span class="s1">&#39;All&#39;</span><span class="p">,</span> <span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="s1">&#39;CHARAC&#39;</span><span class="p">,</span> <span class="s1">&#39;Charac&#39;</span><span class="p">,</span> <span class="s1">&#39;charac&#39;</span><span class="p">):</span>
            <span class="n">ang</span> <span class="o">+=</span> <span class="p">[</span><span class="n">alpha</span><span class="p">,</span> <span class="n">delay</span><span class="p">]</span>
            <span class="n">title_ang</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;Alpha&#39;</span><span class="p">,</span> <span class="s1">&#39;Delay&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">angles</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;ALL&#39;</span><span class="p">,</span> <span class="s1">&#39;All&#39;</span><span class="p">,</span> <span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="s1">&#39;AZIMUTH&#39;</span><span class="p">,</span> <span class="s1">&#39;Azimuth&#39;</span><span class="p">,</span> <span class="s1">&#39;azimuth&#39;</span><span class="p">):</span>
            <span class="n">ang</span> <span class="o">+=</span> <span class="p">[</span><span class="n">azimuth</span><span class="p">,</span> <span class="n">ellipticity</span><span class="p">]</span>
            <span class="n">title_ang</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;Azimuth&#39;</span><span class="p">,</span> <span class="s1">&#39;Ellipticity angle&#39;</span><span class="p">]</span>

        <span class="c1"># Print the result if required</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">draw</span><span class="p">:</span>
            <span class="c1"># Transform angles to degrees for representation</span>
            <span class="n">angles_rep</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">ang</span><span class="p">:</span>
                <span class="n">angles_rep</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span> <span class="o">/</span> <span class="n">degrees</span><span class="p">)</span>

            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Analysis of </span><span class="si">{}</span><span class="s1"> as polarizer:</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
            <span class="n">heading</span> <span class="o">=</span> <span class="s1">&#39;- Transmissions of </span><span class="si">{}</span><span class="s1"> are:&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">PrintParam</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="n">trans</span><span class="p">,</span>
                       <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                       <span class="n">title</span><span class="o">=</span><span class="n">title_trans</span><span class="p">,</span>
                       <span class="n">heading</span><span class="o">=</span><span class="n">heading</span><span class="p">,</span>
                       <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                       <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
            <span class="n">heading</span> <span class="o">=</span> <span class="s1">&#39;- Angles of </span><span class="si">{}</span><span class="s1"> are:&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

            <span class="n">PrintParam</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="n">angles_rep</span><span class="p">,</span>
                       <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                       <span class="n">title</span><span class="o">=</span><span class="n">title_ang</span><span class="p">,</span>
                       <span class="n">heading</span><span class="o">=</span><span class="n">heading</span><span class="p">,</span>
                       <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                       <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>

        <span class="c1"># Output</span>
        <span class="k">return</span> <span class="n">trans</span><span class="p">,</span> <span class="n">ang</span></div>

<div class="viewcode-block" id="Analysis_Mueller.retarder"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Analysis_Mueller.retarder">[docs]</a>    <span class="k">def</span> <span class="nf">retarder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">angles</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">,</span>
                 <span class="n">out_number</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">draw</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates all the parameters from the Mueller Matrix of a pure homogeneous retarder. If the object is not a pure homogenous retarder, some parameters may be wrong.</span>

<span class="sd">        References:</span>
<span class="sd">            J.J. Gil, R. Ossikovsky &quot;Polarized light and the Mueller Matrix approach&quot;, CRC Press (2016)</span>

<span class="sd">        Parameters:</span>
<span class="sd">            angles (string): Determines the type of angles output, CHARAC (characteristic angles), AZIMUTH (azimuth and ellipticity) or ALL. Default: All.</span>
<span class="sd">            out_number (bool): If True and the result is a 1x1 array, return a number instead. Default: True.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>
<span class="sd">            verbose (bool): If True prints the parameter. Default: False.</span>
<span class="sd">            draw (bool): If True and the object is a 1D or 2D, plot it. Default: False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            R (np.ndarray). Retardance.</span>
<span class="sd">            angles (list). Angles of the transmission eigenstate. Depending on the input parameter angles, it can contain the characteristic angles, the azimuth and ellipticity, or all of them.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Extract the diattenuation and diattenuation vector</span>
        <span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">retardance</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                              <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span>
                                              <span class="n">out_number</span><span class="o">=</span><span class="n">out_number</span><span class="p">)</span>
        <span class="n">Rv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">retardance_vector</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                                      <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>

        <span class="c1"># Calculate angles</span>
        <span class="n">azimuth</span><span class="p">,</span> <span class="n">ellipticity</span> <span class="o">=</span> <span class="n">extract_azimuth_elipt</span><span class="p">(</span><span class="n">Rv</span><span class="p">)</span>
        <span class="n">alpha</span><span class="p">,</span> <span class="n">delay</span> <span class="o">=</span> <span class="n">azimuth_elipt_2_charac_angles</span><span class="p">(</span><span class="n">azimuth</span><span class="p">,</span> <span class="n">ellipticity</span><span class="p">)</span>
        <span class="n">ang</span><span class="p">,</span> <span class="n">title_ang</span> <span class="o">=</span> <span class="p">([],</span> <span class="p">[])</span>
        <span class="k">if</span> <span class="n">angles</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;ALL&#39;</span><span class="p">,</span> <span class="s1">&#39;All&#39;</span><span class="p">,</span> <span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="s1">&#39;CHARAC&#39;</span><span class="p">,</span> <span class="s1">&#39;Charac&#39;</span><span class="p">,</span> <span class="s1">&#39;charac&#39;</span><span class="p">):</span>
            <span class="n">ang</span> <span class="o">+=</span> <span class="p">[</span><span class="n">alpha</span><span class="p">,</span> <span class="n">delay</span><span class="p">]</span>
            <span class="n">title_ang</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;Alpha&#39;</span><span class="p">,</span> <span class="s1">&#39;Delay&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">angles</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;ALL&#39;</span><span class="p">,</span> <span class="s1">&#39;All&#39;</span><span class="p">,</span> <span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="s1">&#39;AZIMUTH&#39;</span><span class="p">,</span> <span class="s1">&#39;Azimuth&#39;</span><span class="p">,</span> <span class="s1">&#39;azimuth&#39;</span><span class="p">):</span>
            <span class="n">ang</span> <span class="o">+=</span> <span class="p">[</span><span class="n">azimuth</span><span class="p">,</span> <span class="n">ellipticity</span><span class="p">]</span>
            <span class="n">title_ang</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;Azimuth&#39;</span><span class="p">,</span> <span class="s1">&#39;Ellipticity angle&#39;</span><span class="p">]</span>

        <span class="c1"># Print the result if required</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">draw</span><span class="p">:</span>
            <span class="c1"># Transform angles to degrees for representation</span>
            <span class="n">angles_rep</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">ang</span><span class="p">:</span>
                <span class="n">angles_rep</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span> <span class="o">/</span> <span class="n">degrees</span><span class="p">)</span>

            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Analysis of </span><span class="si">{}</span><span class="s1"> as retarder:</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
            <span class="n">heading</span> <span class="o">=</span> <span class="s1">&#39;- Retardance of </span><span class="si">{}</span><span class="s1"> is:&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">PrintParam</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="p">(</span><span class="n">R</span> <span class="o">/</span> <span class="n">degrees</span><span class="p">),</span>
                       <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                       <span class="n">title</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;Retardance&#39;</span><span class="p">),</span>
                       <span class="n">heading</span><span class="o">=</span><span class="n">heading</span><span class="p">,</span>
                       <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                       <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>

            <span class="n">heading</span> <span class="o">=</span> <span class="s1">&#39;- Angles of </span><span class="si">{}</span><span class="s1"> are:&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">PrintParam</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="n">angles_rep</span><span class="p">,</span>
                       <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                       <span class="n">title</span><span class="o">=</span><span class="n">title_ang</span><span class="p">,</span>
                       <span class="n">heading</span><span class="o">=</span><span class="n">heading</span><span class="p">,</span>
                       <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                       <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>

        <span class="c1"># Output</span>
        <span class="k">return</span> <span class="n">R</span><span class="p">,</span> <span class="n">ang</span></div>

    <span class="c1"># # Matrix filtering</span>
<div class="viewcode-block" id="Analysis_Mueller.filter_purify_number"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Analysis_Mueller.filter_purify_number">[docs]</a>    <span class="k">def</span> <span class="nf">filter_purify_number</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Neig</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">keep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Method that filters experimental errors by making zero a certain number of eigenvalues of the covariance matrix.</span>

<span class="sd">        References:</span>
<span class="sd">            J.J. Gil, R. Ossikovsky &quot;Polarized light and the Mueller Matrix approach&quot;, CRC Press (2016) pp 226.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            Neig (int): Number of eigenvalues (1-3) of the covariant matrix to be made 0. Default: 3.</span>
<span class="sd">            keep (bool): If True, the original object won&#39;t be altered. Default: False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (Mueller): Result.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Act differently if we want to keep self intact</span>
        <span class="k">if</span> <span class="n">keep</span><span class="p">:</span>
            <span class="n">new_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span>
        <span class="n">old_shape</span> <span class="o">=</span> <span class="n">new_obj</span><span class="o">.</span><span class="n">shape</span>

        <span class="c1"># Calculate covariance matrix eigenvalues</span>
        <span class="n">new_obj</span><span class="o">.</span><span class="n">covariance_matrix</span><span class="p">()</span>
        <span class="n">val</span><span class="p">,</span> <span class="n">vect</span> <span class="o">=</span> <span class="n">new_obj</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">values_as_matrix</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                           <span class="n">vectors_as_matrix</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                           <span class="n">shape</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># Find the order of eigenvalues</span>
        <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># Make 0 the desired eigenvalues</span>
        <span class="n">val</span><span class="p">[</span><span class="n">order</span> <span class="o">&lt;</span> <span class="n">Neig</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Recompose the matrix</span>
        <span class="n">H</span><span class="p">,</span> <span class="n">diag</span><span class="p">,</span> <span class="n">Ht</span> <span class="o">=</span> <span class="n">create_Mueller</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">diag</span><span class="o">.</span><span class="n">from_components</span><span class="p">([</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]]</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">val</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]]</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span>
                             <span class="p">[</span><span class="n">val</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]]</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">val</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">:]])</span>
        <span class="n">H</span><span class="o">.</span><span class="n">from_matrix</span><span class="p">(</span><span class="n">vect</span><span class="p">)</span>
        <span class="n">Ht</span><span class="o">.</span><span class="n">from_matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">vect</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))))</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">H</span> <span class="o">*</span> <span class="n">diag</span> <span class="o">*</span> <span class="n">Ht</span>
        <span class="n">new_obj</span><span class="o">.</span><span class="n">from_covariance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">old_shape</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">new_obj</span></div>

    <span class="c1"># # Matrix filtering</span>

<div class="viewcode-block" id="Analysis_Mueller.filter_purify_threshold"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Analysis_Mueller.filter_purify_threshold">[docs]</a>    <span class="k">def</span> <span class="nf">filter_purify_threshold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">keep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Method that filters experimental errors by making zero a certain number of eigenvalues of the covariance matrix.</span>

<span class="sd">        References:</span>
<span class="sd">            J.J. Gil, R. Ossikovsky &quot;Polarized light and the Mueller Matrix approach&quot;, CRC Press (2016) pp 226.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            threshold (float): If eigenvalues are lower than threshold, they will be make 0. Default: 0.01.</span>
<span class="sd">            keep (bool): If True, the original object won&#39;t be altered. Default: False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (Mueller): Result.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Act differently if we want to keep self intact</span>
        <span class="k">if</span> <span class="n">keep</span><span class="p">:</span>
            <span class="n">new_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span>
        <span class="n">old_shape</span> <span class="o">=</span> <span class="n">new_obj</span><span class="o">.</span><span class="n">shape</span>

        <span class="c1"># Calculate covariance matrix eigenvalues</span>
        <span class="n">new_obj</span><span class="o">.</span><span class="n">covariance_matrix</span><span class="p">()</span>
        <span class="n">val</span><span class="p">,</span> <span class="n">vect</span> <span class="o">=</span> <span class="n">new_obj</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">values_as_matrix</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                           <span class="n">vectors_as_matrix</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                           <span class="n">shape</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># Make 0 the desired eigenvalues</span>
        <span class="n">val</span><span class="p">[</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Recompose the matrix</span>
        <span class="n">H</span><span class="p">,</span> <span class="n">diag</span><span class="p">,</span> <span class="n">Ht</span> <span class="o">=</span> <span class="n">create_Mueller</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">diag</span><span class="o">.</span><span class="n">from_components</span><span class="p">([</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]]</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">val</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]]</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span>
                             <span class="p">[</span><span class="n">val</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]]</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">val</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">:]])</span>
        <span class="n">H</span><span class="o">.</span><span class="n">from_matrix</span><span class="p">(</span><span class="n">vect</span><span class="p">)</span>
        <span class="n">Ht</span><span class="o">.</span><span class="n">from_matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">vect</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))))</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">H</span> <span class="o">*</span> <span class="n">diag</span> <span class="o">*</span> <span class="n">Ht</span>
        <span class="n">new_obj</span><span class="o">.</span><span class="n">from_covariance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">old_shape</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">new_obj</span></div>

<div class="viewcode-block" id="Analysis_Mueller.filter_physical_conditions"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Analysis_Mueller.filter_physical_conditions">[docs]</a>    <span class="k">def</span> <span class="nf">filter_physical_conditions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                   <span class="n">tol</span><span class="o">=</span><span class="n">tol_default</span><span class="p">,</span>
                                   <span class="n">ignore_cond</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                   <span class="n">keep</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                   <span class="n">_counter</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Method that filters experimental errors by forcing the Mueller matrix to fulfill the conditions necessary for a matrix to be a real optical component.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            tol (float): Tolerance in equalities.</span>
<span class="sd">            ignore_cond (list): Conditions to ignore. If False or None, no condition is ignored. Default: None.</span>
<span class="sd">            keep (bool): If True, the object is updated to the filtered result. If false, a new fresh copy is created. Default: True.</span>
<span class="sd">            _counter (int): Auxiliar variable that shouldn&#39;t be used when calling this function from outside.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Mf (4x4 matrix): Filtered Mueller matrix.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Act differently if we want to keep self intact</span>
        <span class="k">if</span> <span class="n">keep</span><span class="p">:</span>
            <span class="n">new_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span>
        <span class="n">old_shape</span> <span class="o">=</span> <span class="n">new_obj</span><span class="o">.</span><span class="n">shape</span>

        <span class="c1"># Start by calculating if the object is physically realizable</span>
        <span class="n">cond</span><span class="p">,</span> <span class="n">partial</span> <span class="o">=</span> <span class="n">new_obj</span><span class="o">.</span><span class="n">checks</span><span class="o">.</span><span class="n">is_physical</span><span class="p">(</span><span class="n">give_all</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                   <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span>
                                                   <span class="n">ignore_cond</span><span class="o">=</span><span class="n">ignore_cond</span><span class="p">,</span>
                                                   <span class="n">shape</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                   <span class="n">out_number</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Act only if there is some violations or max numebr of iter is reached</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">cond</span><span class="p">)</span> <span class="ow">and</span> <span class="n">_counter</span> <span class="o">&lt;=</span> <span class="n">counter_max</span><span class="p">:</span>
            <span class="c1"># Start by calculating the required information</span>
            <span class="n">comp</span> <span class="o">=</span> <span class="n">new_obj</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">components</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">out_number</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">new_obj</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">diattenuation</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">out_number</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">P</span> <span class="o">=</span> <span class="n">new_obj</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">polarizance</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">out_number</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="c1"># Now solve the conditions one by one. However, in order to avoid problems, once we have acted in one matrix of the object, we won&#39;t modify it again until next iterations, except if the conditions are complementary</span>
            <span class="n">used</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">new_obj</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

            <span class="c1"># Condition 1: Elements must be real</span>
            <span class="n">cond</span> <span class="o">=</span> <span class="o">~</span><span class="n">partial</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">cond</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">elem</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">comp</span><span class="p">):</span>
                    <span class="n">comp</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
                <span class="n">used</span> <span class="o">=</span> <span class="n">used</span> <span class="o">+</span> <span class="o">~</span><span class="n">partial</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># Condition 2a: M00 must be greater than 0</span>
            <span class="n">cond</span> <span class="o">=</span> <span class="o">~</span><span class="n">partial</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">cond</span><span class="p">):</span>
                <span class="n">comp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">used</span> <span class="o">=</span> <span class="n">used</span> <span class="o">+</span> <span class="n">cond</span>

            <span class="c1"># Condition 2b: M00 must be lower than 1</span>
            <span class="n">cond</span> <span class="o">=</span> <span class="o">~</span><span class="n">partial</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">cond</span><span class="p">):</span>
                <span class="n">M00</span> <span class="o">=</span> <span class="n">comp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">elem</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">comp</span><span class="p">):</span>
                    <span class="n">comp</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span> <span class="o">=</span> <span class="n">comp</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span> <span class="o">/</span> <span class="n">M00</span>
                <span class="n">used</span> <span class="o">=</span> <span class="n">used</span> <span class="o">+</span> <span class="n">cond</span>

            <span class="c1"># Condition 3: All elements must be lower than M00</span>
            <span class="n">cond</span> <span class="o">=</span> <span class="o">~</span><span class="n">partial</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">cond</span><span class="p">):</span>
                <span class="n">M00</span> <span class="o">=</span> <span class="n">comp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">elem</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">comp</span><span class="p">):</span>
                    <span class="n">cond2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">comp</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">M00</span>
                    <span class="n">comp</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="n">cond</span> <span class="o">*</span> <span class="n">cond2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span>
                        <span class="n">comp</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="n">cond</span> <span class="o">*</span> <span class="n">cond2</span><span class="p">])</span> <span class="o">*</span> <span class="n">M00</span><span class="p">[</span><span class="n">cond2</span><span class="p">]</span>
                <span class="n">used</span> <span class="o">=</span> <span class="n">used</span> <span class="o">+</span> <span class="n">cond</span>

            <span class="c1"># Condition 4a: Diattenuation can&#39;t be greater than 1</span>
            <span class="n">cond</span> <span class="o">=</span> <span class="o">~</span><span class="n">partial</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">*</span> <span class="o">~</span><span class="n">used</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">cond</span><span class="p">):</span>
                <span class="n">comp</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span> <span class="o">=</span> <span class="n">comp</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span> <span class="o">/</span> <span class="n">D</span><span class="p">[</span><span class="n">cond</span><span class="p">]</span>
                <span class="n">comp</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span> <span class="o">=</span> <span class="n">comp</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span> <span class="o">/</span> <span class="n">D</span><span class="p">[</span><span class="n">cond</span><span class="p">]</span>
                <span class="n">comp</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span> <span class="o">=</span> <span class="n">comp</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span> <span class="o">/</span> <span class="n">D</span><span class="p">[</span><span class="n">cond</span><span class="p">]</span>
                <span class="n">used</span> <span class="o">=</span> <span class="n">used</span> <span class="o">+</span> <span class="n">cond</span>

            <span class="c1"># Condition 4b: Polarizance can&#39;t be greater than 1</span>
            <span class="n">cond</span> <span class="o">=</span> <span class="o">~</span><span class="n">partial</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">*</span> <span class="o">~</span><span class="n">used</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">cond</span><span class="p">):</span>
                <span class="n">comp</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span> <span class="o">=</span> <span class="n">comp</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span> <span class="o">/</span> <span class="n">P</span><span class="p">[</span><span class="n">cond</span><span class="p">]</span>
                <span class="n">comp</span><span class="p">[</span><span class="mi">8</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span> <span class="o">=</span> <span class="n">comp</span><span class="p">[</span><span class="mi">8</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span> <span class="o">/</span> <span class="n">P</span><span class="p">[</span><span class="n">cond</span><span class="p">]</span>
                <span class="n">comp</span><span class="p">[</span><span class="mi">12</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span> <span class="o">=</span> <span class="n">comp</span><span class="p">[</span><span class="mi">12</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span> <span class="o">/</span> <span class="n">P</span><span class="p">[</span><span class="n">cond</span><span class="p">]</span>
                <span class="n">used</span> <span class="o">=</span> <span class="n">used</span> <span class="o">+</span> <span class="n">cond</span>

            <span class="c1"># Condition 5a: Total transmission can&#39;t be greater than 1</span>
            <span class="n">cond</span> <span class="o">=</span> <span class="o">~</span><span class="n">partial</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">*</span> <span class="o">~</span><span class="n">used</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">cond</span><span class="p">):</span>
                <span class="n">aux</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">comp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">comp</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span> <span class="o">=</span> <span class="n">comp</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span> <span class="o">*</span> <span class="n">aux</span>
                <span class="n">comp</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span> <span class="o">=</span> <span class="n">comp</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span> <span class="o">*</span> <span class="n">aux</span>
                <span class="n">comp</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span> <span class="o">=</span> <span class="n">comp</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span> <span class="o">*</span> <span class="n">aux</span>
                <span class="n">used</span> <span class="o">=</span> <span class="n">used</span> <span class="o">+</span> <span class="n">cond</span>

            <span class="c1"># Condition 5b: Total reciproc transmission can&#39;t be greater than 1</span>
            <span class="n">cond</span> <span class="o">=</span> <span class="o">~</span><span class="n">partial</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">*</span> <span class="o">~</span><span class="n">used</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">cond</span><span class="p">):</span>
                <span class="n">aux</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">comp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">comp</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span> <span class="o">=</span> <span class="n">comp</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span> <span class="o">*</span> <span class="n">aux</span>
                <span class="n">comp</span><span class="p">[</span><span class="mi">8</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span> <span class="o">=</span> <span class="n">comp</span><span class="p">[</span><span class="mi">8</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span> <span class="o">*</span> <span class="n">aux</span>
                <span class="n">comp</span><span class="p">[</span><span class="mi">12</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span> <span class="o">=</span> <span class="n">comp</span><span class="p">[</span><span class="mi">12</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span> <span class="o">*</span> <span class="n">aux</span>
                <span class="n">used</span> <span class="o">=</span> <span class="n">used</span> <span class="o">+</span> <span class="n">cond</span>

            <span class="c1"># Condition 6: Tr(M*M^T) &lt;= 4*M00. Leave away M00, P and D components, as they should be fixed now</span>
            <span class="n">cond</span> <span class="o">=</span> <span class="o">~</span><span class="n">partial</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">*</span> <span class="o">~</span><span class="n">used</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">cond</span><span class="p">):</span>
                <span class="c1"># Leave away M00, P and D components</span>
                <span class="n">cte1</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">comp</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span> <span class="o">*</span> <span class="n">comp</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span> <span class="o">+</span> <span class="n">comp</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span> <span class="o">*</span>
                            <span class="n">comp</span><span class="p">[</span><span class="mi">8</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span> <span class="o">+</span> <span class="n">comp</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span> <span class="o">*</span> <span class="n">comp</span><span class="p">[</span><span class="mi">12</span><span class="p">][</span><span class="n">cond</span><span class="p">])</span>
                <span class="n">cte2</span> <span class="o">=</span> <span class="n">comp</span><span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">comp</span><span class="p">[</span><span class="mi">10</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">comp</span><span class="p">[</span><span class="mi">15</span><span class="p">][</span>
                    <span class="n">cond</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">comp</span><span class="p">[</span><span class="mi">6</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span> <span class="o">*</span> <span class="n">comp</span><span class="p">[</span><span class="mi">9</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span> <span class="o">+</span>
                                    <span class="n">comp</span><span class="p">[</span><span class="mi">7</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span> <span class="o">*</span> <span class="n">comp</span><span class="p">[</span><span class="mi">13</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span> <span class="o">+</span>
                                    <span class="n">comp</span><span class="p">[</span><span class="mi">11</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span> <span class="o">*</span> <span class="n">comp</span><span class="p">[</span><span class="mi">14</span><span class="p">][</span><span class="n">cond</span><span class="p">])</span>
                <span class="n">aux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="mi">3</span> <span class="o">*</span> <span class="n">comp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">cte1</span><span class="p">)</span> <span class="o">/</span> <span class="n">cte2</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">elem</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">comp</span><span class="p">):</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">ind</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">12</span><span class="p">):</span>
                        <span class="n">comp</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span> <span class="o">=</span> <span class="n">comp</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span> <span class="o">*</span> <span class="n">aux</span>
                <span class="n">used</span> <span class="o">=</span> <span class="n">used</span> <span class="o">+</span> <span class="n">cond</span>

            <span class="c1"># Cond 7a: Condition in m matrix</span>
            <span class="n">cond</span> <span class="o">=</span> <span class="o">~</span><span class="n">partial</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">*</span> <span class="o">~</span><span class="n">used</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">cond</span><span class="p">):</span>
                <span class="n">M00</span> <span class="o">=</span> <span class="n">comp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span>
                <span class="c1"># Calculate the row weights and signs</span>
                <span class="n">k1</span> <span class="o">=</span> <span class="n">comp</span><span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span> <span class="o">+</span> <span class="n">comp</span><span class="p">[</span><span class="mi">6</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span> <span class="o">+</span> <span class="n">comp</span><span class="p">[</span><span class="mi">7</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span>
                <span class="n">k2</span> <span class="o">=</span> <span class="n">comp</span><span class="p">[</span><span class="mi">9</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span> <span class="o">+</span> <span class="n">comp</span><span class="p">[</span><span class="mi">10</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span> <span class="o">+</span> <span class="n">comp</span><span class="p">[</span><span class="mi">11</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span>
                <span class="n">k3</span> <span class="o">=</span> <span class="n">comp</span><span class="p">[</span><span class="mi">13</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span> <span class="o">+</span> <span class="n">comp</span><span class="p">[</span><span class="mi">14</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span> <span class="o">+</span> <span class="n">comp</span><span class="p">[</span><span class="mi">15</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span>
                <span class="n">s1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">k1</span> <span class="o">/</span> <span class="p">(</span><span class="n">M00</span> <span class="o">*</span> <span class="n">D</span><span class="p">[</span><span class="n">cond</span><span class="p">]))</span>
                <span class="n">s2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">k2</span> <span class="o">/</span> <span class="p">(</span><span class="n">M00</span> <span class="o">*</span> <span class="n">D</span><span class="p">[</span><span class="n">cond</span><span class="p">]))</span>
                <span class="n">s3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">k3</span> <span class="o">/</span> <span class="p">(</span><span class="n">M00</span> <span class="o">*</span> <span class="n">D</span><span class="p">[</span><span class="n">cond</span><span class="p">]))</span>
                <span class="n">kT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">k1</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">k2</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">k3</span><span class="p">)</span>
                <span class="c1"># Fix</span>
                <span class="n">cond2</span> <span class="o">=</span> <span class="p">(</span><span class="n">k1</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">comp</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">cond2</span><span class="p">):</span>
                    <span class="n">aux</span> <span class="o">=</span> <span class="p">(</span><span class="n">M00</span><span class="p">[</span><span class="n">cond2</span><span class="p">]</span> <span class="o">*</span> <span class="n">D</span><span class="p">[</span><span class="n">cond</span><span class="p">][</span><span class="n">cond2</span><span class="p">]</span> <span class="o">/</span> <span class="n">k1</span><span class="p">[</span><span class="n">cond2</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span>
                        <span class="mi">1</span> <span class="o">-</span> <span class="n">s1</span><span class="p">[</span><span class="n">cond2</span><span class="p">]</span> <span class="o">*</span> <span class="n">M00</span><span class="p">[</span><span class="n">cond2</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">D</span><span class="p">[</span><span class="n">cond</span><span class="p">][</span><span class="n">cond2</span><span class="p">])</span> <span class="o">/</span>
                        <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">comp</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">cond</span><span class="p">][</span><span class="n">cond2</span><span class="p">]</span> <span class="o">*</span> <span class="n">k1</span><span class="p">[</span><span class="n">cond2</span><span class="p">]</span> <span class="o">/</span> <span class="n">kT</span><span class="p">[</span><span class="n">cond2</span><span class="p">])))</span>
                    <span class="n">comp</span><span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="n">cond</span><span class="p">][</span><span class="n">cond2</span><span class="p">]</span> <span class="o">*=</span> <span class="n">aux</span>
                    <span class="n">comp</span><span class="p">[</span><span class="mi">6</span><span class="p">][</span><span class="n">cond</span><span class="p">][</span><span class="n">cond2</span><span class="p">]</span> <span class="o">*=</span> <span class="n">aux</span>
                    <span class="n">comp</span><span class="p">[</span><span class="mi">7</span><span class="p">][</span><span class="n">cond</span><span class="p">][</span><span class="n">cond2</span><span class="p">]</span> <span class="o">*=</span> <span class="n">aux</span>

                <span class="n">cond2</span> <span class="o">=</span> <span class="p">(</span><span class="n">k2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">comp</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">cond2</span><span class="p">):</span>
                    <span class="n">aux</span> <span class="o">=</span> <span class="p">(</span><span class="n">M00</span><span class="p">[</span><span class="n">cond2</span><span class="p">]</span> <span class="o">*</span> <span class="n">D</span><span class="p">[</span><span class="n">cond</span><span class="p">][</span><span class="n">cond2</span><span class="p">]</span> <span class="o">/</span> <span class="n">k2</span><span class="p">[</span><span class="n">cond2</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span>
                        <span class="mi">1</span> <span class="o">-</span> <span class="n">s2</span><span class="p">[</span><span class="n">cond2</span><span class="p">]</span> <span class="o">*</span> <span class="n">M00</span><span class="p">[</span><span class="n">cond2</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">D</span><span class="p">[</span><span class="n">cond</span><span class="p">][</span><span class="n">cond2</span><span class="p">])</span> <span class="o">/</span>
                        <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">comp</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">cond</span><span class="p">][</span><span class="n">cond2</span><span class="p">]</span> <span class="o">*</span> <span class="n">k2</span><span class="p">[</span><span class="n">cond2</span><span class="p">]</span> <span class="o">/</span> <span class="n">kT</span><span class="p">[</span><span class="n">cond2</span><span class="p">])))</span>
                    <span class="n">comp</span><span class="p">[</span><span class="mi">9</span><span class="p">][</span><span class="n">cond</span><span class="p">][</span><span class="n">cond2</span><span class="p">]</span> <span class="o">*=</span> <span class="n">aux</span>
                    <span class="n">comp</span><span class="p">[</span><span class="mi">10</span><span class="p">][</span><span class="n">cond</span><span class="p">][</span><span class="n">cond2</span><span class="p">]</span> <span class="o">*=</span> <span class="n">aux</span>
                    <span class="n">comp</span><span class="p">[</span><span class="mi">11</span><span class="p">][</span><span class="n">cond</span><span class="p">][</span><span class="n">cond2</span><span class="p">]</span> <span class="o">*=</span> <span class="n">aux</span>

                <span class="n">cond2</span> <span class="o">=</span> <span class="p">(</span><span class="n">k3</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">comp</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">cond2</span><span class="p">):</span>
                    <span class="n">aux</span> <span class="o">=</span> <span class="p">(</span><span class="n">M00</span><span class="p">[</span><span class="n">cond2</span><span class="p">]</span> <span class="o">*</span> <span class="n">D</span><span class="p">[</span><span class="n">cond</span><span class="p">][</span><span class="n">cond2</span><span class="p">]</span> <span class="o">/</span> <span class="n">k3</span><span class="p">[</span><span class="n">cond2</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span>
                        <span class="mi">1</span> <span class="o">-</span> <span class="n">s3</span><span class="p">[</span><span class="n">cond2</span><span class="p">]</span> <span class="o">*</span> <span class="n">M00</span><span class="p">[</span><span class="n">cond2</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">D</span><span class="p">[</span><span class="n">cond</span><span class="p">][</span><span class="n">cond2</span><span class="p">])</span> <span class="o">/</span>
                        <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">comp</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="n">cond</span><span class="p">][</span><span class="n">cond2</span><span class="p">]</span> <span class="o">*</span> <span class="n">k3</span><span class="p">[</span><span class="n">cond2</span><span class="p">]</span> <span class="o">/</span> <span class="n">kT</span><span class="p">[</span><span class="n">cond2</span><span class="p">])))</span>
                    <span class="n">comp</span><span class="p">[</span><span class="mi">13</span><span class="p">][</span><span class="n">cond</span><span class="p">][</span><span class="n">cond2</span><span class="p">]</span> <span class="o">*=</span> <span class="n">aux</span>
                    <span class="n">comp</span><span class="p">[</span><span class="mi">14</span><span class="p">][</span><span class="n">cond</span><span class="p">][</span><span class="n">cond2</span><span class="p">]</span> <span class="o">*=</span> <span class="n">aux</span>
                    <span class="n">comp</span><span class="p">[</span><span class="mi">15</span><span class="p">][</span><span class="n">cond</span><span class="p">][</span><span class="n">cond2</span><span class="p">]</span> <span class="o">*=</span> <span class="n">aux</span>
                <span class="n">used</span> <span class="o">=</span> <span class="n">used</span> <span class="o">+</span> <span class="n">cond</span>

            <span class="c1"># Cond 7b: Condition in reciprocal m matrix</span>
            <span class="n">cond</span> <span class="o">=</span> <span class="o">~</span><span class="n">partial</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">*</span> <span class="o">~</span><span class="n">used</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">cond</span><span class="p">):</span>
                <span class="n">M00</span> <span class="o">=</span> <span class="n">comp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span>
                <span class="c1"># Calculate the row weights and signs</span>
                <span class="n">k1</span> <span class="o">=</span> <span class="n">comp</span><span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span> <span class="o">+</span> <span class="n">comp</span><span class="p">[</span><span class="mi">9</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span> <span class="o">+</span> <span class="n">comp</span><span class="p">[</span><span class="mi">13</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span>
                <span class="n">k2</span> <span class="o">=</span> <span class="n">comp</span><span class="p">[</span><span class="mi">6</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span> <span class="o">+</span> <span class="n">comp</span><span class="p">[</span><span class="mi">10</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span> <span class="o">+</span> <span class="n">comp</span><span class="p">[</span><span class="mi">14</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span>
                <span class="n">k3</span> <span class="o">=</span> <span class="n">comp</span><span class="p">[</span><span class="mi">7</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span> <span class="o">+</span> <span class="n">comp</span><span class="p">[</span><span class="mi">11</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span> <span class="o">+</span> <span class="n">comp</span><span class="p">[</span><span class="mi">15</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span>
                <span class="n">s1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">k1</span> <span class="o">/</span> <span class="p">(</span><span class="n">M00</span> <span class="o">*</span> <span class="n">P</span><span class="p">[</span><span class="n">cond</span><span class="p">]))</span>
                <span class="n">s2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">k2</span> <span class="o">/</span> <span class="p">(</span><span class="n">M00</span> <span class="o">*</span> <span class="n">P</span><span class="p">[</span><span class="n">cond</span><span class="p">]))</span>
                <span class="n">s3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">k3</span> <span class="o">/</span> <span class="p">(</span><span class="n">M00</span> <span class="o">*</span> <span class="n">P</span><span class="p">[</span><span class="n">cond</span><span class="p">]))</span>
                <span class="n">kT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">k1</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">k2</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">k3</span><span class="p">)</span>
                <span class="c1"># Fix</span>
                <span class="n">cond2</span> <span class="o">=</span> <span class="p">(</span><span class="n">k1</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">comp</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">cond2</span><span class="p">):</span>
                    <span class="n">aux</span> <span class="o">=</span> <span class="p">(</span><span class="n">M00</span><span class="p">[</span><span class="n">cond2</span><span class="p">]</span> <span class="o">*</span> <span class="n">D</span><span class="p">[</span><span class="n">cond</span><span class="p">][</span><span class="n">cond2</span><span class="p">]</span> <span class="o">/</span> <span class="n">k1</span><span class="p">[</span><span class="n">cond2</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span>
                        <span class="mi">1</span> <span class="o">-</span> <span class="n">s1</span><span class="p">[</span><span class="n">cond2</span><span class="p">]</span> <span class="o">*</span> <span class="n">M00</span><span class="p">[</span><span class="n">cond2</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">D</span><span class="p">[</span><span class="n">cond</span><span class="p">][</span><span class="n">cond2</span><span class="p">])</span> <span class="o">/</span>
                        <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">comp</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="n">cond</span><span class="p">][</span><span class="n">cond2</span><span class="p">]</span> <span class="o">*</span> <span class="n">k1</span><span class="p">[</span><span class="n">cond2</span><span class="p">]</span> <span class="o">/</span> <span class="n">kT</span><span class="p">[</span><span class="n">cond2</span><span class="p">])))</span>
                    <span class="n">comp</span><span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="n">cond</span><span class="p">][</span><span class="n">cond2</span><span class="p">]</span> <span class="o">*=</span> <span class="n">aux</span>
                    <span class="n">comp</span><span class="p">[</span><span class="mi">9</span><span class="p">][</span><span class="n">cond</span><span class="p">][</span><span class="n">cond2</span><span class="p">]</span> <span class="o">*=</span> <span class="n">aux</span>
                    <span class="n">comp</span><span class="p">[</span><span class="mi">13</span><span class="p">][</span><span class="n">cond</span><span class="p">][</span><span class="n">cond2</span><span class="p">]</span> <span class="o">*=</span> <span class="n">aux</span>

                <span class="n">cond2</span> <span class="o">=</span> <span class="p">(</span><span class="n">k2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">comp</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">cond2</span><span class="p">):</span>
                    <span class="n">aux</span> <span class="o">=</span> <span class="p">(</span><span class="n">M00</span><span class="p">[</span><span class="n">cond2</span><span class="p">]</span> <span class="o">*</span> <span class="n">D</span><span class="p">[</span><span class="n">cond</span><span class="p">][</span><span class="n">cond2</span><span class="p">]</span> <span class="o">/</span> <span class="n">k2</span><span class="p">[</span><span class="n">cond2</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span>
                        <span class="mi">1</span> <span class="o">-</span> <span class="n">s2</span><span class="p">[</span><span class="n">cond2</span><span class="p">]</span> <span class="o">*</span> <span class="n">M00</span><span class="p">[</span><span class="n">cond2</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">D</span><span class="p">[</span><span class="n">cond</span><span class="p">][</span><span class="n">cond2</span><span class="p">])</span> <span class="o">/</span>
                        <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">comp</span><span class="p">[</span><span class="mi">7</span><span class="p">][</span><span class="n">cond</span><span class="p">][</span><span class="n">cond2</span><span class="p">]</span> <span class="o">*</span> <span class="n">k2</span><span class="p">[</span><span class="n">cond2</span><span class="p">]</span> <span class="o">/</span> <span class="n">kT</span><span class="p">[</span><span class="n">cond2</span><span class="p">])))</span>
                    <span class="n">comp</span><span class="p">[</span><span class="mi">6</span><span class="p">][</span><span class="n">cond</span><span class="p">][</span><span class="n">cond2</span><span class="p">]</span> <span class="o">*=</span> <span class="n">aux</span>
                    <span class="n">comp</span><span class="p">[</span><span class="mi">10</span><span class="p">][</span><span class="n">cond</span><span class="p">][</span><span class="n">cond2</span><span class="p">]</span> <span class="o">*=</span> <span class="n">aux</span>
                    <span class="n">comp</span><span class="p">[</span><span class="mi">14</span><span class="p">][</span><span class="n">cond</span><span class="p">][</span><span class="n">cond2</span><span class="p">]</span> <span class="o">*=</span> <span class="n">aux</span>

                <span class="n">cond2</span> <span class="o">=</span> <span class="p">(</span><span class="n">k3</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">comp</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">cond2</span><span class="p">):</span>
                    <span class="n">aux</span> <span class="o">=</span> <span class="p">(</span><span class="n">M00</span><span class="p">[</span><span class="n">cond2</span><span class="p">]</span> <span class="o">*</span> <span class="n">D</span><span class="p">[</span><span class="n">cond</span><span class="p">][</span><span class="n">cond2</span><span class="p">]</span> <span class="o">/</span> <span class="n">k3</span><span class="p">[</span><span class="n">cond2</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span>
                        <span class="mi">1</span> <span class="o">-</span> <span class="n">s3</span><span class="p">[</span><span class="n">cond2</span><span class="p">]</span> <span class="o">*</span> <span class="n">M00</span><span class="p">[</span><span class="n">cond2</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">D</span><span class="p">[</span><span class="n">cond</span><span class="p">][</span><span class="n">cond2</span><span class="p">])</span> <span class="o">/</span>
                        <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">comp</span><span class="p">[</span><span class="mi">10</span><span class="p">][</span><span class="n">cond</span><span class="p">][</span><span class="n">cond2</span><span class="p">]</span> <span class="o">*</span> <span class="n">k3</span><span class="p">[</span><span class="n">cond2</span><span class="p">]</span> <span class="o">/</span> <span class="n">kT</span><span class="p">[</span><span class="n">cond2</span><span class="p">]))</span>
                    <span class="p">)</span>
                    <span class="n">comp</span><span class="p">[</span><span class="mi">7</span><span class="p">][</span><span class="n">cond</span><span class="p">][</span><span class="n">cond2</span><span class="p">]</span> <span class="o">*=</span> <span class="n">aux</span>
                    <span class="n">comp</span><span class="p">[</span><span class="mi">11</span><span class="p">][</span><span class="n">cond</span><span class="p">][</span><span class="n">cond2</span><span class="p">]</span> <span class="o">*=</span> <span class="n">aux</span>
                    <span class="n">comp</span><span class="p">[</span><span class="mi">15</span><span class="p">][</span><span class="n">cond</span><span class="p">][</span><span class="n">cond2</span><span class="p">]</span> <span class="o">*=</span> <span class="n">aux</span>
                <span class="n">used</span> <span class="o">=</span> <span class="n">used</span> <span class="o">+</span> <span class="n">cond</span>

            <span class="c1"># Cond 8: Conditions in the eigenvalues of the covariance matrix</span>
            <span class="n">cond</span> <span class="o">=</span> <span class="p">(</span><span class="o">~</span><span class="n">partial</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">+</span> <span class="o">~</span><span class="n">partial</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">+</span> <span class="o">~</span><span class="n">partial</span><span class="p">[</span><span class="mi">13</span><span class="p">])</span> <span class="o">*</span> <span class="o">~</span><span class="n">used</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">cond</span><span class="p">):</span>
                <span class="c1"># Calculate the covariance matrix and its eigenvalues</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="n">new_obj</span><span class="o">.</span><span class="n">covariance_matrix</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">val</span><span class="p">,</span> <span class="n">vect</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">values_as_matrix</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                               <span class="n">vectors_as_matrix</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                               <span class="n">shape</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

                <span class="c1"># Condition 8a: Eigenvalues must be real</span>
                <span class="n">cond2</span> <span class="o">=</span> <span class="o">~</span><span class="n">partial</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">*</span> <span class="o">~</span><span class="n">used</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">cond2</span><span class="p">):</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
                <span class="n">used</span> <span class="o">=</span> <span class="n">used</span> <span class="o">+</span> <span class="n">cond2</span>

                <span class="c1"># Condition 8a: Eigenvalues must be greater than 0</span>
                <span class="n">cond2</span> <span class="o">=</span> <span class="o">~</span><span class="n">partial</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">*</span> <span class="o">~</span><span class="n">used</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">cond2</span><span class="p">):</span>
                    <span class="n">val</span><span class="p">[</span><span class="n">val</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="c1"># Condition 8a: Eigenvalues must be lower than 1</span>
                <span class="n">cond2</span> <span class="o">=</span> <span class="o">~</span><span class="n">partial</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span> <span class="o">*</span> <span class="o">~</span><span class="n">used</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">cond2</span><span class="p">):</span>
                    <span class="n">val</span><span class="p">[</span><span class="n">val</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

                <span class="c1"># Now, lets merge the fix in the last condition with the rest</span>
                <span class="n">H</span><span class="p">,</span> <span class="n">diag</span><span class="p">,</span> <span class="n">Ht</span> <span class="o">=</span> <span class="n">create_Mueller</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
                <span class="n">diag</span><span class="o">.</span><span class="n">from_components</span><span class="p">([</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]]</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">val</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]]</span> <span class="o">+</span>
                                     <span class="mi">4</span> <span class="o">*</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">val</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]]</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span>
                                     <span class="p">[</span><span class="n">val</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">:]])</span>
                <span class="n">H</span><span class="o">.</span><span class="n">from_matrix</span><span class="p">(</span><span class="n">vect</span><span class="p">)</span>
                <span class="n">Ht</span><span class="o">.</span><span class="n">from_matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">vect</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))))</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">H</span> <span class="o">*</span> <span class="n">diag</span> <span class="o">*</span> <span class="n">Ht</span>
                <span class="n">result</span><span class="o">.</span><span class="n">from_covariance</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
                <span class="n">comp2</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">components</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                     <span class="n">out_number</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">elem</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">comp2</span><span class="p">):</span>
                    <span class="n">comp</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="n">cond</span><span class="p">]</span> <span class="o">=</span> <span class="n">elem</span><span class="p">[</span><span class="n">cond</span><span class="p">]</span>

            <span class="c1"># Finally, use the corrected values</span>
            <span class="n">new_obj</span><span class="o">.</span><span class="n">from_components</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">old_shape</span><span class="p">)</span>

            <span class="c1"># Call again this function to solve all the problems iteratively through recurrence</span>
            <span class="n">new_obj</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">filter_physical_conditions</span><span class="p">(</span>
                <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span>
                <span class="n">ignore_cond</span><span class="o">=</span><span class="n">ignore_cond</span><span class="p">,</span>
                <span class="n">keep</span><span class="o">=</span><span class="n">keep</span><span class="p">,</span>
                <span class="n">_counter</span><span class="o">=</span><span class="n">_counter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">new_obj</span></div>

    <span class="c1">####################################################################</span>
    <span class="c1"># Matrix decomposition</span>
    <span class="c1">####################################################################</span>

<div class="viewcode-block" id="Analysis_Mueller.decompose_pure"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Analysis_Mueller.decompose_pure">[docs]</a>    <span class="k">def</span> <span class="nf">decompose_pure</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">decomposition</span><span class="o">=</span><span class="s1">&#39;RP&#39;</span><span class="p">,</span>
            <span class="n">give_all</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">tol</span><span class="o">=</span><span class="n">tol_default</span><span class="p">,</span>
            <span class="c1"># filter=False,</span>
            <span class="n">out_number</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">draw</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">transmissions</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span>
            <span class="n">angles</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Polar decomposition of a pure Mueller matrix in a retarder and a diattenuator.</span>

<span class="sd">        References:</span>
<span class="sd">            J.J. Gil, R. Ossikovsky &quot;Polarized light and the Mueller Matrix approach&quot;, CRC Press (2016), pp 151.</span>
<span class="sd">            S. Y. Lu, R. A. Chipman; &quot;Interpretation of Mueller matrices based on polar decomposition&quot;; J. Opt. Soc. Am. A/Vol. 13, No. 5 (1996)</span>

<span class="sd">        Parameters:</span>
<span class="sd">            decomposition (string): string with the order of the elements: retarder (R) or diattenuator/polarizer (D or P). Default: RP.</span>
<span class="sd">            give_all (bool): If True, the dictionary of parameters will be given in the returned. Default: False.</span>
<span class="sd">            tol (float): Tolerance in equalities.</span>
<span class="sd">            out_number (bool): If True and the result is a 1x1 array, return a number instead. Default: True.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>
<span class="sd">            verbose (float): If true, the function prints out some information about the matrices.</span>
<span class="sd">            draw (bool): If True and the object is a 1D or 2D, plot it. Default: False.</span>
<span class="sd">            transmissions (string): Determines the type of transmission output, FIELD, INTENSITY or ALL. Default: All.</span>
<span class="sd">            angles (string): Determines the type of angles output, CHARAC (characteristic angles), AZIMUTH (azimuth and ellipticity) or ALL. Default: All.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Mr (Mueller): Mueller matrix of the retarder.</span>
<span class="sd">            Md (Mueller): Mueller matrix of the diattenuator.</span>
<span class="sd">            param (dictionary, optional): Dictionary with all the parameters of the decomposed elements.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># In order to be efficient, start by printing soem things</span>
        <span class="n">Md</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">Md</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Diattenuator of &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">draw</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">decomposition</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;Rr&#39;</span><span class="p">):</span>
                <span class="n">decomposition</span> <span class="o">=</span> <span class="s1">&#39;Mr * Md&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">decomposition</span> <span class="o">=</span> <span class="s1">&#39;Md * Mr&#39;</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">------------------------------------------------------&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Pure decomposition of </span><span class="si">{}</span><span class="s1"> as M = </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">decomposition</span><span class="p">))</span>
        <span class="c1"># Filter the matrix if required TODO</span>

        <span class="c1"># First step, extract the diattenuator parameters</span>
        <span class="k">if</span> <span class="n">decomposition</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;Rr&#39;</span><span class="p">):</span>
            <span class="n">trans</span><span class="p">,</span> <span class="n">ang</span> <span class="o">=</span> <span class="n">Md</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">diattenuator</span><span class="p">(</span><span class="n">transmissions</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span>
                                                  <span class="n">angles</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span>
                                                  <span class="n">out_number</span><span class="o">=</span><span class="n">out_number</span><span class="p">,</span>
                                                  <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                                  <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span>
                                                  <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                                                  <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">trans</span><span class="p">,</span> <span class="n">ang</span> <span class="o">=</span> <span class="n">Md</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">polarizer</span><span class="p">(</span><span class="n">transmissions</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span>
                                               <span class="n">angles</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span>
                                               <span class="n">out_number</span><span class="o">=</span><span class="n">out_number</span><span class="p">,</span>
                                               <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                               <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span>
                                               <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                                               <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>

        <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">trans</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
        <span class="n">azD</span><span class="p">,</span> <span class="n">elD</span> <span class="o">=</span> <span class="n">ang</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>

        <span class="c1"># Now, we can create the diatenuator object</span>
        <span class="n">Md</span><span class="o">.</span><span class="n">diattenuator_azimuth_ellipticity</span><span class="p">(</span><span class="n">p1</span><span class="o">=</span><span class="n">p1</span><span class="p">,</span>
                                            <span class="n">p2</span><span class="o">=</span><span class="n">p2</span><span class="p">,</span>
                                            <span class="n">azimuth</span><span class="o">=</span><span class="n">azD</span><span class="p">,</span>
                                            <span class="n">ellipticity</span><span class="o">=</span><span class="n">elD</span><span class="p">)</span>

        <span class="c1"># Now, the retarder. To do that, we have to invert the diattenuator</span>
        <span class="n">Mdi</span> <span class="o">=</span> <span class="n">Mueller</span><span class="p">()</span>
        <span class="n">Mdi</span><span class="o">.</span><span class="n">diattenuator_azimuth_ellipticity</span><span class="p">(</span><span class="n">p1</span><span class="o">=</span><span class="mi">1</span> <span class="o">/</span> <span class="n">p1</span><span class="p">,</span>
                                             <span class="n">p2</span><span class="o">=</span><span class="mi">1</span> <span class="o">/</span> <span class="n">p2</span><span class="p">,</span>
                                             <span class="n">azimuth</span><span class="o">=</span><span class="n">azD</span><span class="p">,</span>
                                             <span class="n">ellipticity</span><span class="o">=</span><span class="n">elD</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">decomposition</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;Rr&#39;</span><span class="p">):</span>
            <span class="n">Mr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">*</span> <span class="n">Mdi</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Mr</span> <span class="o">=</span> <span class="n">Mdi</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span>

        <span class="c1"># In some cases, the diattenuator is not invertible. Solve those cases</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">p2</span> <span class="o">&lt;</span> <span class="n">tol</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">cond</span><span class="p">):</span>
            <span class="c1"># If p1 was also 0, the original matrix is a total absorbr, so a retarder does not ahve sense</span>
            <span class="n">cond2</span> <span class="o">=</span> <span class="n">p1</span> <span class="o">&lt;</span> <span class="n">tol</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">cond2</span><span class="p">):</span>
                <span class="n">Mr</span><span class="p">[</span><span class="n">cond2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="n">cond2</span><span class="p">]</span>

            <span class="c1"># For the rest of cases, the retarder is not unique. Let&#39;s chose the one with the lowest retardance.</span>
            <span class="n">cond2</span> <span class="o">=</span> <span class="o">~</span><span class="n">cond2</span> <span class="o">*</span> <span class="n">cond</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">cond2</span><span class="p">):</span>
                <span class="c1"># First, the retardance</span>
                <span class="n">Dv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">diattenuation_vector</span><span class="p">(</span>
                    <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>
                <span class="n">Pv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">polarizance_vector</span><span class="p">(</span>
                    <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>
                <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Dv</span> <span class="o">*</span> <span class="n">Pv</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
                <span class="c1"># Now, the retardance vector</span>
                <span class="n">Rv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">Pv</span><span class="p">,</span> <span class="n">Dv</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Rv</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">Rv</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">Rv</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/</span> <span class="n">norm</span>
                <span class="n">Rv</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">Rv</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/</span> <span class="n">norm</span>
                <span class="n">Rv</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">Rv</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/</span> <span class="n">norm</span>
                <span class="c1"># Finally, construct the object</span>
                <span class="n">Mr2</span> <span class="o">=</span> <span class="n">Mueller</span><span class="p">()</span>
                <span class="n">Mr2</span><span class="o">.</span><span class="n">retarder_vector</span><span class="p">(</span><span class="n">Rv</span><span class="o">=</span><span class="n">Rv</span><span class="p">,</span>
                                    <span class="n">R</span><span class="o">=</span><span class="n">R</span><span class="p">,</span>
                                    <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                    <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>
                <span class="n">Mr</span><span class="p">[</span><span class="n">cond2</span><span class="p">]</span> <span class="o">=</span> <span class="n">Mr2</span><span class="p">[</span><span class="n">cond2</span><span class="p">]</span>

        <span class="n">Mr</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Retarder of &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span>

        <span class="c1"># Set the global phases</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">global_phase</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Md</span><span class="o">.</span><span class="n">set_global_phase</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">global_phase</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
                                <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>
            <span class="n">Mr</span><span class="o">.</span><span class="n">set_global_phase</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">global_phase</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
                                <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>

        <span class="c1"># Information dictionary and visualization</span>
        <span class="k">if</span> <span class="n">give_all</span> <span class="ow">or</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">draw</span><span class="p">:</span>
            <span class="c1"># Diattenuator</span>
            <span class="n">trans</span><span class="p">,</span> <span class="n">ang</span> <span class="o">=</span> <span class="n">Md</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">diattenuator</span><span class="p">(</span><span class="n">transmissions</span><span class="o">=</span><span class="n">transmissions</span><span class="p">,</span>
                                                  <span class="n">angles</span><span class="o">=</span><span class="n">angles</span><span class="p">,</span>
                                                  <span class="n">out_number</span><span class="o">=</span><span class="n">out_number</span><span class="p">,</span>
                                                  <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                                                  <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">transmissions</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;FIELD&#39;</span><span class="p">:</span>
                <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;p1&#39;</span><span class="p">],</span> <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;p2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">trans</span>
            <span class="k">elif</span> <span class="n">transmissions</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;INTENSITY&#39;</span><span class="p">:</span>
                <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;Tmax&#39;</span><span class="p">],</span> <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;Tmin&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">trans</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;Tmax&#39;</span><span class="p">],</span> <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;Tmin&#39;</span><span class="p">],</span> <span class="n">parameters</span><span class="p">[</span>
                    <span class="s1">&#39;p1&#39;</span><span class="p">],</span> <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;p2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">trans</span>
            <span class="k">if</span> <span class="n">angles</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;CHARAC&#39;</span><span class="p">:</span>
                <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;alpha D&#39;</span><span class="p">],</span> <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;delay D&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ang</span>
            <span class="k">elif</span> <span class="n">angles</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;ALL&#39;</span><span class="p">:</span>
                <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;alpha D&#39;</span><span class="p">],</span> <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;delay D&#39;</span><span class="p">],</span> <span class="n">parameters</span><span class="p">[</span>
                    <span class="s1">&#39;azimuth D&#39;</span><span class="p">],</span> <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;ellipticity D&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ang</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;azimuth D&#39;</span><span class="p">],</span> <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;ellipticity D&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ang</span>
            <span class="c1"># Retarder</span>
            <span class="n">R</span><span class="p">,</span> <span class="n">ang</span> <span class="o">=</span> <span class="n">Mr</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">retarder</span><span class="p">(</span><span class="n">angles</span><span class="o">=</span><span class="n">angles</span><span class="p">,</span>
                                          <span class="n">out_number</span><span class="o">=</span><span class="n">out_number</span><span class="p">,</span>
                                          <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                          <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span>
                                          <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                                          <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
            <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;R&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">R</span>
            <span class="k">if</span> <span class="n">angles</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;CHARAC&#39;</span><span class="p">:</span>
                <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;alpha R&#39;</span><span class="p">],</span> <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;delay R&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ang</span>
            <span class="k">elif</span> <span class="n">angles</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;ALL&#39;</span><span class="p">:</span>
                <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;alpha R&#39;</span><span class="p">],</span> <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;delay R&#39;</span><span class="p">],</span> <span class="n">parameters</span><span class="p">[</span>
                    <span class="s1">&#39;azimuth R&#39;</span><span class="p">],</span> <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;ellipticity R&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ang</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;azimuth R&#39;</span><span class="p">],</span> <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;ellipticity R&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ang</span>

            <span class="c1"># Error</span>
            <span class="k">if</span> <span class="n">decomposition</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;Rr&#39;</span><span class="p">):</span>
                <span class="n">Mrec</span> <span class="o">=</span> <span class="n">Mr</span> <span class="o">*</span> <span class="n">Md</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Mrec</span> <span class="o">=</span> <span class="n">Md</span> <span class="o">*</span> <span class="n">Mr</span>
            <span class="n">error</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span>
                <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span> <span class="o">-</span> <span class="n">Mrec</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span>
                    <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>
            <span class="n">error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">error</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="mi">16</span>
            <span class="k">if</span> <span class="o">~</span><span class="n">out_number</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">error</span><span class="p">])</span>
            <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;Error&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">error</span>
            <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">draw</span><span class="p">:</span>
                <span class="n">heading</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> decomposition mean square error:&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="n">PrintParam</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="p">[</span><span class="n">error</span><span class="p">],</span>
                           <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                           <span class="n">title</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;MSE&#39;</span><span class="p">],</span>
                           <span class="n">heading</span><span class="o">=</span><span class="n">heading</span><span class="p">,</span>
                           <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                           <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s2">&quot;------------------------------------------------------</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Return</span>
        <span class="k">if</span> <span class="n">give_all</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Mr</span><span class="p">,</span> <span class="n">Md</span><span class="p">,</span> <span class="n">parameters</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Mr</span><span class="p">,</span> <span class="n">Md</span></div>

<div class="viewcode-block" id="Analysis_Mueller.decompose_polar"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Analysis_Mueller.decompose_polar">[docs]</a>    <span class="k">def</span> <span class="nf">decompose_polar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                        <span class="n">decomposition</span><span class="o">=</span><span class="s1">&#39;PRD&#39;</span><span class="p">,</span>
                        <span class="n">give_all</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">tol</span><span class="o">=</span><span class="n">tol_default</span><span class="p">,</span>
                        <span class="n">out_number</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">draw</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">transmissions</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span>
                        <span class="n">angles</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">,</span>
                        <span class="n">depolarization</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Polar decomposition of a physically realizable Mueller matrix in a partial depolarizer, retarder and a diattenuator.</span>

<span class="sd">        TODO: When the depolarizer is singular with 2 or 3 non-zero eigenvalues, the decomposed retarder is often erroneous (60-80% of the time).</span>

<span class="sd">        References:</span>
<span class="sd">            J.J. Gil, R. Ossikovsky &quot;Polarized light and the Mueller Matrix approach&quot;, CRC Press (2016), pp 257.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            decomposition (string): string with the order of the elements: depolarizer (P), retarder (R) or diattenuator (D). There are six possible decompositions: PRD, RDP, PDR, RDP, DRP and DPR. Default: PRD.</span>
<span class="sd">            give_all (bool): If true, the dictionary of parameters will be given in the returned. Default: False.</span>
<span class="sd">            tol (float): Tolerance in equalities.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>
<span class="sd">            verbose (float): If true, the function prints out some information about the matrices.</span>
<span class="sd">            draw (bool): If True and the object is a 1D or 2D, plot it. Default: False.</span>
<span class="sd">            transmissions (string): Determines the type of transmission output, FIELD, INTENSITY or ALL. Default: All.</span>
<span class="sd">            angles (string): Determines the type of angles output, CHARAC (characteristic angles), AZIMUTH (azimuth and ellipticity) or ALL. Default: All.</span>
<span class="sd">            depolarization (string): Determines the type of depolarization information: INDEX, FACTORS or ALL. Default: All.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Mr (Mueller): Mueller matrix of the retarder.</span>
<span class="sd">            Md (Mueller): Mueller matrix of the diattenuator/polarizer.</span>
<span class="sd">            Mp (Mueller): Mueller matrix of the depolarizer.</span>
<span class="sd">            param (dictionary, optional): Dictionary with all the parameters of the decomposed elements.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Some common parameters</span>
        <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">pure</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">checks</span><span class="o">.</span><span class="n">is_pure</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>
        <span class="c1"># # If M is completelly pure, there is no point in continuing in this path, go to the pure decomposition instead</span>
        <span class="c1"># if np.all(pure):</span>
        <span class="c1">#     Mp = Mueller(&#39;Depolarizer of &#39; + self.parent.name)</span>
        <span class="c1">#     # Pure case (no depolarizer).</span>
        <span class="c1">#     new_dec = decomposition.replace(&#39;P&#39;, &#39;&#39;)</span>
        <span class="c1">#     new_dec.replace(&#39;p&#39;, &#39;&#39;)</span>
        <span class="c1">#     Mr, Md = self.decompose_pure(decomposition=new_dec, tol=tol)</span>
        <span class="c1">#     Mp.vacuum(length=M.size, shape=Mr.shape)</span>
        <span class="c1"># else:</span>
        <span class="c1"># Create objects and extract usefull info</span>
        <span class="n">Mp</span><span class="p">,</span> <span class="n">Md</span> <span class="o">=</span> <span class="n">create_Mueller</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">M00</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">mean_transmission</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                             <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>
        <span class="n">singular</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">checks</span><span class="o">.</span><span class="n">is_singular</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>
        <span class="n">det</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Chhoose decomposition</span>
        <span class="k">if</span> <span class="n">decomposition</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;PRD&#39;</span><span class="p">:</span>
            <span class="c1"># Start by calculating the diattenuator</span>
            <span class="n">Dv</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">diattenuation_vector</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                                   <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>
            <span class="n">Md</span><span class="o">.</span><span class="n">diattenuator_vector</span><span class="p">(</span><span class="n">Dv</span><span class="o">=</span><span class="n">Dv</span><span class="p">,</span> <span class="n">M00</span><span class="o">=</span><span class="n">M00</span><span class="p">)</span>
            <span class="c1"># Now, calculate the inverse of the diattenuator and extract it from the total matrix</span>
            <span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">),</span> <span class="p">(</span><span class="n">alpha</span><span class="p">,</span>
                       <span class="n">delay</span><span class="p">)</span> <span class="o">=</span> <span class="n">Md</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">diattenuator</span><span class="p">(</span><span class="n">transmissions</span><span class="o">=</span><span class="s1">&#39;field&#39;</span><span class="p">,</span>
                                                         <span class="n">angles</span><span class="o">=</span><span class="s1">&#39;charac&#39;</span><span class="p">)</span>
            <span class="n">Mdi</span> <span class="o">=</span> <span class="n">Mueller</span><span class="p">()</span>
            <span class="n">Mdi</span><span class="o">.</span><span class="n">diattenuator_charac_angles</span><span class="p">(</span><span class="n">p1</span><span class="o">=</span><span class="mi">1</span> <span class="o">/</span> <span class="n">p1</span><span class="p">,</span>
                                           <span class="n">p2</span><span class="o">=</span><span class="mi">1</span> <span class="o">/</span> <span class="n">p2</span><span class="p">,</span>
                                           <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
                                           <span class="n">delay</span><span class="o">=</span><span class="n">delay</span><span class="p">)</span>
            <span class="n">Mdi</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Mdi</span><span class="o">.</span><span class="n">M</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Allow continuing if p2 = 0</span>
            <span class="n">Mdi</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">Mdi</span><span class="o">.</span><span class="n">M</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Allow continuing if p2 = 0</span>
            <span class="n">Mf</span> <span class="o">=</span> <span class="n">M</span> <span class="o">*</span> <span class="n">Mdi</span>

            <span class="c1"># Now, we have the polarizance vector of Md. Extract it</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">Pvf</span><span class="p">,</span> <span class="n">mf</span> <span class="o">=</span> <span class="n">Mf</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">blocks</span><span class="p">()</span>
            <span class="n">Mf</span><span class="o">.</span><span class="n">from_blocks</span><span class="p">(</span><span class="n">m</span><span class="o">=</span><span class="n">mf</span><span class="p">)</span>
            <span class="c1"># Calculate eigenvalues and eigenvectors of the square matrix</span>
            <span class="n">Mf2</span> <span class="o">=</span> <span class="n">Mf</span> <span class="o">*</span> <span class="n">Mf</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">val</span><span class="p">,</span> <span class="n">vect</span> <span class="o">=</span> <span class="n">Mf2</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">values_as_matrix</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                           <span class="n">vectors_as_matrix</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                           <span class="n">shape</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="c1"># print(val, vect)</span>
            <span class="c1"># Recompose the matrix of depolarizer using the square root of the eigenvalues</span>
            <span class="n">H</span><span class="p">,</span> <span class="n">diag</span><span class="p">,</span> <span class="n">Ht</span> <span class="o">=</span> <span class="n">create_Mueller</span><span class="p">((</span><span class="s1">&#39;R2&#39;</span><span class="p">,</span> <span class="s1">&#39;Diag&#39;</span><span class="p">,</span> <span class="s1">&#39;R2T&#39;</span><span class="p">))</span>
            <span class="n">diag</span><span class="o">.</span><span class="n">from_components</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])]</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span>
                                 <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">val</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])]</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span>
                                 <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">val</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:])]</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span>
                                 <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">det</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">val</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">:])])</span>
            <span class="n">H</span><span class="o">.</span><span class="n">from_matrix</span><span class="p">(</span><span class="n">vect</span><span class="p">)</span>
            <span class="n">Ht</span><span class="o">.</span><span class="n">from_matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">vect</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))))</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">H</span> <span class="o">*</span> <span class="n">diag</span> <span class="o">*</span> <span class="n">Ht</span>
            <span class="c1"># print(H, diag, Ht)</span>
            <span class="c1"># print(&#39;result1&#39;, result)</span>
            <span class="n">mp</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">small_matrix</span><span class="p">()</span>
            <span class="n">Mp</span><span class="o">.</span><span class="n">from_blocks</span><span class="p">(</span><span class="n">Pv</span><span class="o">=</span><span class="n">Pvf</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="n">mp</span><span class="p">)</span>
            <span class="c1"># Finally, the retarder can be calculated by using the inverse matrix of Mp</span>
            <span class="n">diag</span><span class="o">.</span><span class="n">from_components</span><span class="p">([</span><span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])]</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span>
                                 <span class="p">[</span><span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">val</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])]</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span>
                                 <span class="p">[</span><span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">val</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:])]</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span>
                                 <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">det</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">val</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">:])])</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">H</span> <span class="o">*</span> <span class="n">diag</span> <span class="o">*</span> <span class="n">Ht</span>
            <span class="c1"># print(&#39;result2&#39;, result)</span>
            <span class="n">Mr</span> <span class="o">=</span> <span class="n">result</span> <span class="o">*</span> <span class="n">Mf</span>
            <span class="c1"># print(&#39;Mf&#39;, Mf, result, Mr)</span>

            <span class="c1"># Now, let&#39;s see if we have the special cases of singular matrices.</span>
            <span class="c1"># First case: Mp is singular and Md not</span>
            <span class="n">cond</span> <span class="o">=</span> <span class="n">singular</span> <span class="o">*</span> <span class="p">(</span><span class="n">p2</span> <span class="o">&gt;</span> <span class="n">tol</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">cond</span><span class="p">):</span>
                <span class="n">Mp_aux</span><span class="p">,</span> <span class="n">Mr_aux</span> <span class="o">=</span> <span class="n">create_Mueller</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                <span class="c1"># We have to wnow how many eigenvalues of Mf are different from 0</span>
                <span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">tol</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="c1"># print(&#39;N = &#39;, N)</span>
                <span class="k">if</span> <span class="n">Mr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">Mr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="n">condN1</span> <span class="o">=</span> <span class="n">cond</span> <span class="o">*</span> <span class="p">(</span><span class="n">N</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">condN2</span> <span class="o">=</span> <span class="n">cond</span> <span class="o">*</span> <span class="p">(</span><span class="n">N</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
                <span class="n">condN3</span> <span class="o">=</span> <span class="n">cond</span> <span class="o">*</span> <span class="p">(</span><span class="n">N</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
                <span class="n">condN23</span> <span class="o">=</span> <span class="n">condN2</span> <span class="o">+</span> <span class="n">condN3</span>
                <span class="c1"># Only one eigenvalue, No retarder at all. This is very simple</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">condN1</span><span class="p">):</span>
                    <span class="n">Mp_aux</span><span class="o">.</span><span class="n">from_blocks</span><span class="p">(</span><span class="n">Pv</span><span class="o">=</span><span class="n">Pvf</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">Mp</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                    <span class="n">Mr_aux</span><span class="o">.</span><span class="n">vacuum</span><span class="p">(</span><span class="n">length</span><span class="o">=</span><span class="n">Mr</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">Mr</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
                    <span class="n">Mr</span><span class="p">[</span><span class="n">condN1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Mr_aux</span><span class="p">[</span><span class="n">condN1</span><span class="p">]</span>
                    <span class="n">Mp</span><span class="p">[</span><span class="n">condN1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Mp_aux</span><span class="p">[</span><span class="n">condN1</span><span class="p">]</span>
                <span class="c1"># We start to need the right eigenvectors of Mf^2</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">condN23</span><span class="p">):</span>
                    <span class="c1"># Left eigenvectors. Make eigenvale 1 = 0 to remove it</span>
                    <span class="n">val_aux</span> <span class="o">=</span> <span class="n">val</span>
                    <span class="n">val_aux</span><span class="p">[</span><span class="n">val</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">val_ord</span><span class="p">,</span> <span class="n">vect_ord</span> <span class="o">=</span> <span class="n">order_eig</span><span class="p">(</span><span class="n">val_aux</span><span class="p">,</span> <span class="n">vect</span><span class="p">,</span> <span class="s1">&#39;reverse&#39;</span><span class="p">)</span>
                    <span class="n">v1</span> <span class="o">=</span> <span class="n">vect_ord</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
                    <span class="c1"># Left eigenvectors. Make eigenvale 1 = 0 to remove it</span>
                    <span class="n">Mf2_b</span> <span class="o">=</span> <span class="n">Mf</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">*</span> <span class="n">Mf</span>
                    <span class="n">val_b</span><span class="p">,</span> <span class="n">vect_b</span> <span class="o">=</span> <span class="n">Mf2_b</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span>
                        <span class="n">values_as_matrix</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">vectors_as_matrix</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">shape</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="n">val_b</span><span class="p">[</span><span class="n">val_b</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">val_b_ord</span><span class="p">,</span> <span class="n">vect_b_ord</span> <span class="o">=</span> <span class="n">order_eig</span><span class="p">(</span><span class="n">val_b</span><span class="p">,</span> <span class="n">vect_b</span><span class="p">,</span> <span class="s1">&#39;reverse&#39;</span><span class="p">)</span>
                    <span class="n">w1</span> <span class="o">=</span> <span class="n">vect_b_ord</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
                <span class="c1"># Two eigenvalues.</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">condN2</span><span class="p">):</span>
                    <span class="c1"># TODO: Works 30% of the time</span>
                    <span class="c1"># Calculate Mp</span>
                    <span class="n">trace_m2</span> <span class="o">=</span> <span class="n">Mf2</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span>
                    <span class="p">)</span> <span class="o">-</span> <span class="n">Mf2</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">mean_transmission</span><span class="p">()</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">Mf2</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">trace_m2</span><span class="p">)</span>
                    <span class="n">Mp_aux</span><span class="o">.</span><span class="n">from_blocks</span><span class="p">(</span>
                        <span class="n">Pv</span><span class="o">=</span><span class="n">Pvf</span><span class="p">,</span>
                        <span class="n">m</span><span class="o">=</span><span class="n">result</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">small_matrix</span><span class="p">(</span><span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
                        <span class="n">shape</span><span class="o">=</span><span class="n">Mp</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                    <span class="n">Mp</span><span class="p">[</span><span class="n">condN2</span><span class="p">]</span> <span class="o">=</span> <span class="n">Mp_aux</span><span class="p">[</span><span class="n">condN2</span><span class="p">]</span>
                    <span class="c1"># Calculate retardance</span>
                    <span class="n">trace_m</span> <span class="o">=</span> <span class="n">Mf</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span>
                    <span class="p">)</span> <span class="o">-</span> <span class="n">Mf</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">mean_transmission</span><span class="p">()</span>
                    <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">trace_m</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">trace_m2</span><span class="p">))</span>
                    <span class="c1"># Calculate normalized retardance vector</span>
                    <span class="n">Rv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">w1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Rv</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">Rv</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">Rv</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/</span> <span class="n">norm</span>
                    <span class="n">Rv</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">Rv</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/</span> <span class="n">norm</span>
                    <span class="n">Rv</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">Rv</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/</span> <span class="n">norm</span>
                    <span class="c1"># Calculate the retarder</span>
                    <span class="n">Mr_aux</span><span class="o">.</span><span class="n">retarder_vector</span><span class="p">(</span><span class="n">R</span><span class="o">=</span><span class="n">R</span><span class="p">,</span> <span class="n">Rv</span><span class="o">=</span><span class="n">Rv</span><span class="p">)</span>
                    <span class="n">Mr</span><span class="p">[</span><span class="n">condN2</span><span class="p">]</span> <span class="o">=</span> <span class="n">Mr_aux</span><span class="p">[</span><span class="n">condN2</span><span class="p">]</span>
                <span class="c1"># Three eigenvalues</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">condN3</span><span class="p">):</span>
                    <span class="c1"># TODO: Works 15% of the time</span>
                    <span class="c1"># Calculate Mp</span>
                    <span class="n">suma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">val_ord</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">val_ord</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span>
                    <span class="n">producto</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">val_ord</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">val_ord</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">Mf2</span> <span class="o">+</span> <span class="n">producto</span> <span class="o">*</span> <span class="n">result</span><span class="o">.</span><span class="n">vacuum</span><span class="p">(</span><span class="n">length</span><span class="o">=</span><span class="n">M</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">inverse</span><span class="p">()</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">suma</span> <span class="o">*</span> <span class="n">result</span> <span class="o">*</span> <span class="n">Mf2</span>
                    <span class="n">Mp_aux</span><span class="o">.</span><span class="n">from_blocks</span><span class="p">(</span>
                        <span class="n">Pv</span><span class="o">=</span><span class="n">Pvf</span><span class="p">,</span>
                        <span class="n">m</span><span class="o">=</span><span class="n">result</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">small_matrix</span><span class="p">(</span><span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
                        <span class="n">shape</span><span class="o">=</span><span class="n">Mp</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                    <span class="n">Mp</span><span class="p">[</span><span class="n">condN3</span><span class="p">]</span> <span class="o">=</span> <span class="n">Mp_aux</span><span class="p">[</span><span class="n">condN3</span><span class="p">]</span>
                    <span class="c1"># Calculate the second set of vectors</span>
                    <span class="n">v2</span> <span class="o">=</span> <span class="n">vect_ord</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
                    <span class="n">w2</span> <span class="o">=</span> <span class="n">vect_b_ord</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
                    <span class="n">prod_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">prod_v</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">prod_v</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/=</span> <span class="n">norm</span>
                    <span class="n">prod_v</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/=</span> <span class="n">norm</span>
                    <span class="n">prod_v</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/=</span> <span class="n">norm</span>
                    <span class="n">prod_w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">w1</span><span class="p">,</span> <span class="n">w2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">prod_w</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">prod_w</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/=</span> <span class="n">norm</span>
                    <span class="n">prod_w</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/=</span> <span class="n">norm</span>
                    <span class="n">prod_w</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/=</span> <span class="n">norm</span>
                    <span class="c1"># Calculate Mr</span>
                    <span class="n">mr</span> <span class="o">=</span> <span class="n">kron_axis</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">w1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> \
                    <span class="n">kron_axis</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span> <span class="n">w2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">kron_axis</span><span class="p">(</span><span class="n">prod_v</span><span class="p">,</span> <span class="n">prod_w</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">Mr_aux</span><span class="o">.</span><span class="n">from_blocks</span><span class="p">(</span><span class="n">m</span><span class="o">=</span><span class="n">mr</span><span class="p">)</span>
                    <span class="n">Mr</span><span class="p">[</span><span class="n">condN3</span><span class="p">]</span> <span class="o">=</span> <span class="n">Mr_aux</span><span class="p">[</span><span class="n">condN3</span><span class="p">]</span>

            <span class="c1"># Now, the diattenuator is singular</span>
            <span class="n">cond</span> <span class="o">=</span> <span class="n">p2</span> <span class="o">&lt;=</span> <span class="n">tol</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">cond</span><span class="p">):</span>
                <span class="c1"># In this case, both depolarizer and retarder are not unique. We choose a diagonal depolarizer (easy to understand) and the retarder with minimum retardance.</span>
                <span class="n">Mp_aux</span><span class="p">,</span> <span class="n">Mr_aux</span> <span class="o">=</span> <span class="n">create_Mueller</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                <span class="c1"># Start by the depolarizer</span>
                <span class="n">P</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">polarizance</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                             <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>
                <span class="n">Mp_aux</span><span class="o">.</span><span class="n">depolarizer_diagonal</span><span class="p">(</span><span class="n">d</span><span class="o">=</span><span class="n">P</span><span class="p">)</span>
                <span class="n">Mp</span><span class="p">[</span><span class="n">cond</span><span class="p">]</span> <span class="o">=</span> <span class="n">Mp_aux</span><span class="p">[</span><span class="n">cond</span><span class="p">]</span>
                <span class="c1"># Now, the retarder</span>
                <span class="n">Pv</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">polarizance_vector</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                                     <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>
                <span class="n">Dv</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">diattenuation_vector</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                                       <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>
                <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Pv</span> <span class="o">*</span> <span class="n">Dv</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">P</span><span class="p">)</span>
                <span class="n">Rv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">Pv</span><span class="p">,</span> <span class="n">Dv</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Rv</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">Rv</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/=</span> <span class="n">norm</span>
                <span class="n">Rv</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/=</span> <span class="n">norm</span>
                <span class="n">Rv</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/=</span> <span class="n">norm</span>
                <span class="n">Mr_aux</span><span class="o">.</span><span class="n">retarder_vector</span><span class="p">(</span><span class="n">R</span><span class="o">=</span><span class="n">R</span><span class="p">,</span> <span class="n">Rv</span><span class="o">=</span><span class="n">Rv</span><span class="p">)</span>
                <span class="n">Mr</span><span class="p">[</span><span class="n">cond</span><span class="p">]</span> <span class="o">=</span> <span class="n">Mr_aux</span><span class="p">[</span><span class="n">cond</span><span class="p">]</span>

        <span class="k">elif</span> <span class="n">decomposition</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;PDR&#39;</span><span class="p">:</span>
            <span class="n">Mr</span><span class="p">,</span> <span class="n">Md</span><span class="p">,</span> <span class="n">Mp</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">decompose_polar</span><span class="p">(</span><span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span>
                                                    <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span>
                                                    <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">Md</span> <span class="o">=</span> <span class="n">Mr</span> <span class="o">*</span> <span class="n">Md</span> <span class="o">*</span> <span class="n">Mr</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">decomposition</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;RPD&#39;</span><span class="p">:</span>
            <span class="n">Mr</span><span class="p">,</span> <span class="n">Md</span><span class="p">,</span> <span class="n">Mp</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">decompose_polar</span><span class="p">(</span><span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span>
                                                    <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span>
                                                    <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">Mp</span> <span class="o">=</span> <span class="n">Mr</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">*</span> <span class="n">Mp</span> <span class="o">*</span> <span class="n">Mr</span>

        <span class="k">elif</span> <span class="n">decomposition</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;DRP&#39;</span><span class="p">:</span>
            <span class="c1"># Same as above for the transposed matrix</span>
            <span class="n">M2</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">Mr</span><span class="p">,</span> <span class="n">Md</span><span class="p">,</span> <span class="n">Mp</span> <span class="o">=</span> <span class="n">M2</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">decompose_polar</span><span class="p">(</span><span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span>
                                                     <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span>
                                                     <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">Mr</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
            <span class="n">Mp</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>

        <span class="k">elif</span> <span class="n">decomposition</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;RDP&#39;</span><span class="p">:</span>
            <span class="n">Mr</span><span class="p">,</span> <span class="n">Md</span><span class="p">,</span> <span class="n">Mp</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">decompose_polar</span><span class="p">(</span><span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span>
                                                    <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span>
                                                    <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                                    <span class="n">decomposition</span><span class="o">=</span><span class="s1">&#39;DRP&#39;</span><span class="p">)</span>
            <span class="n">Md</span> <span class="o">=</span> <span class="n">Mr</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">*</span> <span class="n">Md</span> <span class="o">*</span> <span class="n">Mr</span>

        <span class="k">elif</span> <span class="n">decomposition</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;DPR&#39;</span><span class="p">:</span>
            <span class="n">Mr</span><span class="p">,</span> <span class="n">Md</span><span class="p">,</span> <span class="n">Mp</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">decompose_polar</span><span class="p">(</span><span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span>
                                                    <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span>
                                                    <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                                    <span class="n">decomposition</span><span class="o">=</span><span class="s1">&#39;DRP&#39;</span><span class="p">)</span>
            <span class="n">Mp</span> <span class="o">=</span> <span class="n">Mr</span> <span class="o">*</span> <span class="n">Mp</span> <span class="o">*</span> <span class="n">Mr</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;Decomposition </span><span class="si">{}</span><span class="s1"> is not valid, must be a combination of R, P and D without repetition&#39;</span>
                <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">decomposition</span><span class="p">))</span>

        <span class="c1"># Correct names</span>
        <span class="n">Mp</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Depolarizer of &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span>
        <span class="n">Md</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Diattenuator of &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span>
        <span class="n">Mr</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Retarder of &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span>

        <span class="c1"># Set glpbal phase</span>
        <span class="k">if</span> <span class="n">M</span><span class="o">.</span><span class="n">global_phase</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">gp</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">global_phase</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>
            <span class="n">Md</span><span class="o">.</span><span class="n">set_global_phase</span><span class="p">(</span><span class="n">gp</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span>
            <span class="n">Mp</span><span class="o">.</span><span class="n">set_global_phase</span><span class="p">(</span><span class="n">gp</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span>
            <span class="n">Mr</span><span class="o">.</span><span class="n">set_global_phase</span><span class="p">(</span><span class="n">gp</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span>

        <span class="c1"># Finally, print options and extract the info</span>
        <span class="c1"># print the heading</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">draw</span> <span class="ow">or</span> <span class="n">give_all</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">draw</span><span class="p">:</span>
                <span class="n">decomposition</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
                <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">decomposition</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">elem</span> <span class="ow">in</span> <span class="s1">&#39;Rr&#39;</span><span class="p">:</span>
                        <span class="n">decomposition</span> <span class="o">+=</span> <span class="s1">&#39;Mr&#39;</span>
                    <span class="k">elif</span> <span class="n">elem</span> <span class="ow">in</span> <span class="s1">&#39;Dd&#39;</span><span class="p">:</span>
                        <span class="n">decomposition</span> <span class="o">+=</span> <span class="s1">&#39;Md&#39;</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">decomposition</span> <span class="o">+=</span> <span class="s1">&#39;Mp&#39;</span>
                    <span class="k">if</span> <span class="n">elem</span> <span class="o">!=</span> <span class="n">decomposition</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="n">decomposition</span> <span class="o">+=</span> <span class="s1">&#39; * &#39;</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">------------------------------------------------------&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Polar decomposition of </span><span class="si">{}</span><span class="s1"> as M = </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">decomposition</span><span class="p">))</span>
            <span class="c1"># Parameters</span>
            <span class="n">parameters</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="c1"># Diattenuator</span>
            <span class="n">trans</span><span class="p">,</span> <span class="n">ang</span> <span class="o">=</span> <span class="n">Md</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">diattenuator</span><span class="p">(</span><span class="n">transmissions</span><span class="o">=</span><span class="n">transmissions</span><span class="p">,</span>
                                                  <span class="n">angles</span><span class="o">=</span><span class="n">angles</span><span class="p">,</span>
                                                  <span class="n">out_number</span><span class="o">=</span><span class="n">out_number</span><span class="p">,</span>
                                                  <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                                                  <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">transmissions</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;FIELD&#39;</span><span class="p">:</span>
                <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;p1&#39;</span><span class="p">],</span> <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;p2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">trans</span>
            <span class="k">elif</span> <span class="n">transmissions</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;INTENSITY&#39;</span><span class="p">:</span>
                <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;Tmax&#39;</span><span class="p">],</span> <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;Tmin&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">trans</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;Tmax&#39;</span><span class="p">],</span> <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;Tmin&#39;</span><span class="p">],</span> <span class="n">parameters</span><span class="p">[</span>
                    <span class="s1">&#39;p1&#39;</span><span class="p">],</span> <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;p2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">trans</span>
            <span class="k">if</span> <span class="n">angles</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;CHARAC&#39;</span><span class="p">:</span>
                <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;alpha D&#39;</span><span class="p">],</span> <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;delay D&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ang</span>
            <span class="k">elif</span> <span class="n">angles</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;ALL&#39;</span><span class="p">:</span>
                <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;alpha D&#39;</span><span class="p">],</span> <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;delay D&#39;</span><span class="p">],</span> <span class="n">parameters</span><span class="p">[</span>
                    <span class="s1">&#39;azimuth D&#39;</span><span class="p">],</span> <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;ellipticity D&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ang</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;azimuth D&#39;</span><span class="p">],</span> <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;ellipticity D&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ang</span>
            <span class="c1"># Retarder</span>
            <span class="n">R</span><span class="p">,</span> <span class="n">ang</span> <span class="o">=</span> <span class="n">Mr</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">retarder</span><span class="p">(</span><span class="n">angles</span><span class="o">=</span><span class="n">angles</span><span class="p">,</span>
                                          <span class="n">out_number</span><span class="o">=</span><span class="n">out_number</span><span class="p">,</span>
                                          <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                          <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span>
                                          <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                                          <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
            <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;R&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">R</span>
            <span class="k">if</span> <span class="n">angles</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;CHARAC&#39;</span><span class="p">:</span>
                <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;alpha R&#39;</span><span class="p">],</span> <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;delay R&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ang</span>
            <span class="k">elif</span> <span class="n">angles</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;ALL&#39;</span><span class="p">:</span>
                <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;alpha R&#39;</span><span class="p">],</span> <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;delay R&#39;</span><span class="p">],</span> <span class="n">parameters</span><span class="p">[</span>
                    <span class="s1">&#39;azimuth R&#39;</span><span class="p">],</span> <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;ellipticity R&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ang</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;azimuth R&#39;</span><span class="p">],</span> <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;ellipticity R&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ang</span>
            <span class="c1"># Depolarizer</span>
            <span class="n">trans_D</span><span class="p">,</span> <span class="n">trans_P</span><span class="p">,</span> <span class="n">angles_D</span><span class="p">,</span> <span class="n">angles_P</span><span class="p">,</span> <span class="n">depol</span><span class="p">,</span> <span class="n">principal_states</span> <span class="o">=</span> <span class="n">Mp</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">depolarizer</span><span class="p">(</span>
                <span class="n">transmissions</span><span class="o">=</span><span class="n">transmissions</span><span class="p">,</span>
                <span class="n">angles</span><span class="o">=</span><span class="n">angles</span><span class="p">,</span>
                <span class="n">depolarization</span><span class="o">=</span><span class="n">depolarization</span><span class="p">,</span>
                <span class="n">out_number</span><span class="o">=</span><span class="n">out_number</span><span class="p">,</span>
                <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">transmissions</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;FIELD&#39;</span><span class="p">:</span>
                <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;p1 Depol D&#39;</span><span class="p">],</span> <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;p2 Depol D&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">trans_D</span>
                <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;p1 Depol P&#39;</span><span class="p">],</span> <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;p2 Depol P&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">trans_P</span>
            <span class="k">elif</span> <span class="n">transmissions</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;INTENSITY&#39;</span><span class="p">:</span>
                <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;Tmax Depol D&#39;</span><span class="p">],</span> <span class="n">parameters</span><span class="p">[</span>
                    <span class="s1">&#39;Tmin Depol D&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">trans_D</span>
                <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;Tmax Depol P&#39;</span><span class="p">],</span> <span class="n">parameters</span><span class="p">[</span>
                    <span class="s1">&#39;Tmin Depol P&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">trans_P</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;Tmax Depol D&#39;</span><span class="p">],</span> <span class="n">parameters</span><span class="p">[</span>
                    <span class="s1">&#39;Tmin Depol D&#39;</span><span class="p">],</span> <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;p1 Depol D&#39;</span><span class="p">],</span> <span class="n">parameters</span><span class="p">[</span>
                        <span class="s1">&#39;p2 Depol D&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">trans_D</span>
                <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;Tmax Depol P&#39;</span><span class="p">],</span> <span class="n">parameters</span><span class="p">[</span>
                    <span class="s1">&#39;Tmin Depol P&#39;</span><span class="p">],</span> <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;p1 Depol P&#39;</span><span class="p">],</span> <span class="n">parameters</span><span class="p">[</span>
                        <span class="s1">&#39;p2 Depol P&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">trans_P</span>
            <span class="k">if</span> <span class="n">angles</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;CHARAC&#39;</span><span class="p">:</span>
                <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;alpha Depol D&#39;</span><span class="p">],</span> <span class="n">parameters</span><span class="p">[</span>
                    <span class="s1">&#39;delay Depol D&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">angles_D</span>
                <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;alpha Depol P&#39;</span><span class="p">],</span> <span class="n">parameters</span><span class="p">[</span>
                    <span class="s1">&#39;delay Depol P&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">angles_P</span>
            <span class="k">elif</span> <span class="n">angles</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;ALL&#39;</span><span class="p">:</span>
                <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;alpha Depol D&#39;</span><span class="p">],</span> <span class="n">parameters</span><span class="p">[</span>
                    <span class="s1">&#39;delay Depol D&#39;</span><span class="p">],</span> <span class="n">parameters</span><span class="p">[</span>
                        <span class="s1">&#39;azimuth Depol D&#39;</span><span class="p">],</span> <span class="n">parameters</span><span class="p">[</span>
                            <span class="s1">&#39;ellipticity Depol D&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">angles_D</span>
                <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;alpha Depol P&#39;</span><span class="p">],</span> <span class="n">parameters</span><span class="p">[</span>
                    <span class="s1">&#39;delay Depol P&#39;</span><span class="p">],</span> <span class="n">parameters</span><span class="p">[</span>
                        <span class="s1">&#39;azimuth Depol P&#39;</span><span class="p">],</span> <span class="n">parameters</span><span class="p">[</span>
                            <span class="s1">&#39;ellipticity Depol P&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">angles_P</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;azimuth Depol D&#39;</span><span class="p">],</span> <span class="n">parameters</span><span class="p">[</span>
                    <span class="s1">&#39;ellipticity Depol D&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">angles_D</span>
                <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;azimuth Depol P&#39;</span><span class="p">],</span> <span class="n">parameters</span><span class="p">[</span>
                    <span class="s1">&#39;ellipticity Depol P&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">angles_P</span>
            <span class="c1"># Error</span>
            <span class="n">Mrec</span> <span class="o">=</span> <span class="n">Mueller</span><span class="p">()</span>
            <span class="n">Mrec</span><span class="o">.</span><span class="n">vacuum</span><span class="p">(</span><span class="n">length</span><span class="o">=</span><span class="n">M</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
            <span class="n">Mrec</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">Md</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">decomposition</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">elem</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;R&#39;</span><span class="p">:</span>
                    <span class="n">Mrec</span> <span class="o">=</span> <span class="n">Mrec</span> <span class="o">*</span> <span class="n">Mr</span>
                <span class="k">elif</span> <span class="n">elem</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;D&#39;</span><span class="p">:</span>
                    <span class="n">Mrec</span> <span class="o">=</span> <span class="n">Mrec</span> <span class="o">*</span> <span class="n">Md</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">Mrec</span> <span class="o">=</span> <span class="n">Mrec</span> <span class="o">*</span> <span class="n">Mp</span>
            <span class="n">error</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span>
                <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span> <span class="o">-</span> <span class="n">Mrec</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span>
                    <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">)</span>
            <span class="n">error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">error</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="mi">16</span>
            <span class="k">if</span> <span class="n">out_number</span> <span class="ow">and</span> <span class="n">M</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">error</span> <span class="o">=</span> <span class="n">error</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;Error&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">error</span>
            <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">draw</span><span class="p">:</span>
                <span class="n">heading</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> decomposition mean square error:&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="n">PrintParam</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="p">[</span><span class="n">error</span><span class="p">],</span>
                           <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                           <span class="n">title</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;MSE&#39;</span><span class="p">],</span>
                           <span class="n">heading</span><span class="o">=</span><span class="n">heading</span><span class="p">,</span>
                           <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                           <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s2">&quot;------------------------------------------------------</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Return</span>
        <span class="k">if</span> <span class="n">give_all</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Mr</span><span class="p">,</span> <span class="n">Md</span><span class="p">,</span> <span class="n">Mp</span><span class="p">,</span> <span class="n">parameters</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Mr</span><span class="p">,</span> <span class="n">Md</span><span class="p">,</span> <span class="n">Mp</span></div></div>

            <span class="c1"># # Calculate the diattenuator/polarizer</span>
            <span class="c1"># p1, p2, alphaP, delayP, fiP, chiP = self.diattenuator()</span>
            <span class="c1"># Mp.diattenuator_charac_angles_from_vector(</span>
            <span class="c1">#     p1, p2, alphaP, delayP)</span>
            <span class="c1"># D = Mp.parameters.diattenuation()</span>
            <span class="c1"># # Sometimes, due to numeric calculation, D may be slightly higher than 1. Fix it.</span>
            <span class="c1"># if D &gt; 1 and D &lt; 1 + eps:</span>
            <span class="c1">#     D = 1</span>
            <span class="c1"># elif D &gt; 1 + eps:</span>
            <span class="c1">#     raise ValueError(</span>
            <span class="c1">#         &quot;Mueller matrix is not real, diattenuation is &gt; 1.&quot;)</span>
            <span class="c1"># # Check if the matrix M is singular or not.</span>
            <span class="c1"># singM = parent.checks.is_singular(tol=tol)</span>
            <span class="c1"># singMp = Mp.checks.is_singular(tol=tol)</span>
            <span class="c1"># nz = 0</span>
            <span class="c1"># if singMp:</span>
            <span class="c1">#     # We have to determine if only Md is singular or not</span>
            <span class="c1">#     P = parent.parameters.polarizance()</span>
            <span class="c1">#     cond3 = np.abs(1 - P) &lt;= tol</span>
            <span class="c1">#     if cond3:</span>
            <span class="c1">#         # Print type of decomposition</span>
            <span class="c1">#         if verbose:</span>
            <span class="c1">#             print(</span>
            <span class="c1">#                 &quot;Both the depolarizer and the polarizer are singular.&quot;</span>
            <span class="c1">#             )</span>
            <span class="c1">#         # Homogeneous case</span>
            <span class="c1">#         Md.from_matrix(np.identity(4))</span>
            <span class="c1">#         Mr, Mp = decompose_pure(M, decomposition=&#39;PR&#39;, tol=tol)</span>
            <span class="c1">#     else:</span>
            <span class="c1">#         # Print type of decomposition</span>
            <span class="c1">#         if verbose:</span>
            <span class="c1">#             print(&quot;The polarizer is singular.&quot;)</span>
            <span class="c1">#         # Calculate the depolarizer polarizance vector</span>
            <span class="c1">#         Pdv = parent.P</span>
            <span class="c1">#         Mr.from_matrix(np.identity(4))</span>
            <span class="c1">#         cero = np.matrix(np.zeros(3))</span>
            <span class="c1">#         ceroM = np.zeros((3, 3))</span>
            <span class="c1">#         Md.from_blocks(cero, Pdv, ceroM)</span>
            <span class="c1"># else:</span>
            <span class="c1">#     # Calculate the depolarizer polarizance vector</span>
            <span class="c1">#     # Dv, Pv, m, m00 = divide_in_blocks(M)</span>
            <span class="c1">#     # Pdv = (Pv - m * Dv.T) / (1 - D**2)</span>
            <span class="c1">#     # For calculating the small matrix m of the depolarizer we need an</span>
            <span class="c1">#     # auxiliary matrix mf</span>
            <span class="c1">#     Gaux = matrix(np.diag([1, -1, -1, -1]))</span>
            <span class="c1">#     if singM:</span>
            <span class="c1">#         Mpinv = Gaux * Mp * Gaux * D**(-2)</span>
            <span class="c1">#     else:</span>
            <span class="c1">#         Mpinv = Gaux * Mp * Gaux * (1 - D**2)**(-1)</span>
            <span class="c1">#     Mf = parent * Mpinv</span>
            <span class="c1">#     _, Pdv, mf, _ = divide_in_blocks(Mf.M)</span>
            <span class="c1">#     md2 = mf * mf.T</span>
            <span class="c1">#     qi2, mr2 = np.linalg.eigh(md2)</span>
            <span class="c1">#     # check_eig(qi2, mr2, md2)</span>
            <span class="c1">#     qi = np.sqrt(qi2)</span>
            <span class="c1">#     cero = np.matrix(np.zeros(3))</span>
            <span class="c1">#     # Calculation method depends on Md being singular or not</span>
            <span class="c1">#     if singM:  # If M is singular and Mp is not =&gt; Md is singular</span>
            <span class="c1">#         # Calculate the number of eigenvalues that are zero and order them</span>
            <span class="c1">#         qi2, mr2 = order_eig(qi2, mr2)</span>
            <span class="c1">#         qi = np.sqrt(qi2)</span>
            <span class="c1">#         nz = sum(qi &lt; tol)</span>
            <span class="c1">#         # Calculate other auxiliary matrices and vectors</span>
            <span class="c1">#         md1 = mf.T * mf</span>
            <span class="c1">#         qi12, mr1 = np.linalg.eigh(md1)</span>
            <span class="c1">#         qi12, mr1 = order_eig(qi12, mr1)</span>
            <span class="c1">#         v1, v2, w1, w2 = (mr2[:, 0], mr2[:, 1], mr1[:, 0],</span>
            <span class="c1">#                           mr1[:, 1])</span>
            <span class="c1">#         if nz == 3:</span>
            <span class="c1">#             # Print type of decomposition</span>
            <span class="c1">#             if verbose:</span>
            <span class="c1">#                 print(</span>
            <span class="c1">#                     &quot;Depolarized matrix singular case with three null eigenvalues.&quot;</span>
            <span class="c1">#                 )</span>
            <span class="c1">#             # Trivial case</span>
            <span class="c1">#             md = np.zeros([3, 3])</span>
            <span class="c1">#             Md.from_blocks(cero, Pdv, md)</span>
            <span class="c1">#             Mr.from_matrix(np.eye(4))</span>
            <span class="c1">#         elif nz == 2:</span>
            <span class="c1">#             # Print type of decomposition</span>
            <span class="c1">#             if verbose:</span>
            <span class="c1">#                 print(</span>
            <span class="c1">#                     &quot;Depolarized matrix singular case with two null eigenvalues.&quot;</span>
            <span class="c1">#                 )</span>
            <span class="c1">#             # Depolarizer</span>
            <span class="c1">#             md = mf * mf.T / sqrt(np.trace(mf * mf.T))</span>
            <span class="c1">#             Md.from_blocks(cero, Pdv, md)</span>
            <span class="c1">#             # Retarder. Note that it is not unique.</span>
            <span class="c1">#             # TODO: inexacto</span>
            <span class="c1">#             cR = np.trace(mf) / sqrt(np.trace(mf * mf.T))</span>
            <span class="c1">#             R = np.arccos(cR)</span>
            <span class="c1">#             x1 = np.cross(v1.T, w1.T)</span>
            <span class="c1">#             Mr.retarder_from_vector(R,</span>
            <span class="c1">#                                     x1[0] / np.linalg.norm(x1))</span>
            <span class="c1">#         else:</span>
            <span class="c1">#             # Print type of decomposition</span>
            <span class="c1">#             if verbose:</span>
            <span class="c1">#                 print(</span>
            <span class="c1">#                     &quot;Depolarized matrix singular case with one null eigenvalue.&quot;</span>
            <span class="c1">#                 )</span>
            <span class="c1">#             # Depolarizer</span>
            <span class="c1">#             mat_aux = mf * mf.T + qi[0] * qi[1] * np.eye(3)</span>
            <span class="c1">#             md = (qi[0] + qi[1]) * (mat_aux).I * mf * mf.T</span>
            <span class="c1">#             Md.from_blocks(cero, Pdv, md)</span>
            <span class="c1">#             # Retarder. Note that it is not unique.</span>
            <span class="c1">#             # TODO: No funciona de momento</span>
            <span class="c1">#             # mr1 = np.matrix(mr1)</span>
            <span class="c1">#             # mr2 = np.matrix(mr2)</span>
            <span class="c1">#             # print([qi, qi2])</span>
            <span class="c1">#             # print(mf - mr2 * np.matrix(np.diag(qi)) * mr1.T)</span>
            <span class="c1">#             # print(mf.T * mf - mr1 * np.diag(qi2) * mr1.T)</span>
            <span class="c1">#             # print(mf * mf.T - mr2 * np.diag(qi2) * mr2.T)</span>
            <span class="c1">#             # print(&quot;&quot;)</span>
            <span class="c1">#             # print(mr1 * mr1.T)</span>
            <span class="c1">#             (y1, y2) = (np.cross(v1.T, v2.T),</span>
            <span class="c1">#                         np.cross(w1.T, w2.T))</span>
            <span class="c1">#             mr = v1 * w1.T + v2 * w2.T + y1 * y2.T / (</span>
            <span class="c1">#                 np.linalg.norm(y1) * np.linalg.norm(y2))</span>
            <span class="c1">#             # mr = np.matrix(mr)</span>
            <span class="c1">#             # print(mr * mr.T)</span>
            <span class="c1">#             Mr.from_blocks(cero, cero.T, mr)</span>
            <span class="c1">#     else:</span>
            <span class="c1">#         # Print type of decomposition</span>
            <span class="c1">#         if verbose:</span>
            <span class="c1">#             print(&quot;General case.&quot;)</span>
            <span class="c1">#         # General case</span>
            <span class="c1">#         s = np.sign(np.linalg.det(M))</span>
            <span class="c1">#         md = np.diag([qi[0], qi[1], s * qi[2]])</span>
            <span class="c1">#         md = mr2 * md * mr2.T</span>
            <span class="c1">#         Md.from_blocks(cero, Pdv, md)</span>
            <span class="c1">#         # Calculate the retarder</span>
            <span class="c1">#         mdinv = mr2 * np.diag(</span>
            <span class="c1">#             [1 / qi[0], 1 / qi[1], s / qi[2]]) * mr2.T</span>
            <span class="c1">#         mr = mdinv * mf</span>
            <span class="c1">#         Mr.from_blocks(cero, cero.T, mr)</span>
            <span class="c1"># if decomposition in (&#39;DPR&#39;, &#39;dpr&#39;):</span>
            <span class="c1">#     Mpure = Mr * Mp</span>
            <span class="c1">#     Mr, Mp = Mpure.analysis.decompose_pure(</span>
            <span class="c1">#         decomposition=&#39;PR&#39;, tol=tol)</span>
        <span class="c1">#</span>
        <span class="c1">#     elif decomposition in (&#39;PRD&#39;, &#39;prd&#39;, &#39;RPD&#39;, &#39;rpd&#39;):</span>
        <span class="c1">#         # This procedure is simple, we just have to traspose</span>
        <span class="c1">#         Mtras = Mueller(parent.name)</span>
        <span class="c1">#         Mtras.from_matrix(M.T)</span>
        <span class="c1">#         Md, Mr, Mp = Mtras.analysis.decompose_polar(tol=tol)</span>
        <span class="c1">#         Mr.from_matrix(Mr.M.T)</span>
        <span class="c1">#         Md.from_matrix(Md.M.T)</span>
        <span class="c1">#         # Reverse order of polarizer and retarder if required</span>
        <span class="c1">#         if decomposition in (&#39;RPD&#39;, &#39;rpd&#39;):</span>
        <span class="c1">#             Mpure = Mp * Mr</span>
        <span class="c1">#             Mr, Mp = Mpure.analysis.decompose_pure(</span>
        <span class="c1">#                 decomposition=&#39;RP&#39;, tol=tol)</span>
        <span class="c1">#     elif decomposition in (&#39;PDR&#39;, &#39;pdr&#39;):</span>
        <span class="c1">#         # We can calculate this one slightly differently</span>
        <span class="c1">#         Mp, Mr, Md = parent.analysis.decompose_polar(</span>
        <span class="c1">#             decomposition=&#39;PRD&#39;, tol=tol)</span>
        <span class="c1">#         Md_matrix = Mr.M * Md.M * Mr.M.I</span>
        <span class="c1">#         Md.from_matrix(Md_matrix)</span>
        <span class="c1">#     elif decomposition in (&#39;RDP&#39;, &#39;rdp&#39;):</span>
        <span class="c1">#         # We can calculate this one as the traspose of the previous one</span>
        <span class="c1">#         Mtras = Mueller(parent.name)</span>
        <span class="c1">#         Mtras.from_matrix(M.T)</span>
        <span class="c1">#         Mp, Md, Mr = Mtras.analysis.decompose_polar(</span>
        <span class="c1">#             decomposition=&#39;PDR&#39;, tol=tol)</span>
        <span class="c1">#         Mr.from_matrix(Mr.M.T)</span>
        <span class="c1">#         Md.from_matrix(Md.M.T)</span>
        <span class="c1">#     else:</span>
        <span class="c1">#         raise ValueError(&quot;Decomposition not yet implemented.&quot;)</span>
        <span class="c1"># # Order the output matrices</span>
        <span class="c1"># Mout = [0, 0, 0]</span>
        <span class="c1"># for ind in range(3):</span>
        <span class="c1">#     if decomposition[ind] == &#39;D&#39;:</span>
        <span class="c1">#         Mout[ind] = Md</span>
        <span class="c1">#     elif decomposition[ind] == &#39;P&#39;:</span>
        <span class="c1">#         Mout[ind] = Mp</span>
        <span class="c1">#     else:</span>
        <span class="c1">#         Mout[ind] = Mr</span>
        <span class="c1"># # Calculate parameters</span>
        <span class="c1"># if verbose or give_all:</span>
        <span class="c1">#     R, alphaR, delayR, fiR, chiR = Mr.analysis.retarder()</span>
        <span class="c1">#     Pd = Md.parameters.polarizance()</span>
        <span class="c1">#     Desp = Md.parameters.depolarization_index()</span>
        <span class="c1"># # Calculate error</span>
        <span class="c1"># if give_all or verbose:</span>
        <span class="c1">#     if decomposition == &#39;DRP&#39;:</span>
        <span class="c1">#         Mt = Md * Mr * Mp</span>
        <span class="c1">#         D = np.abs(Mt.M - M)</span>
        <span class="c1">#     MeanErr = np.linalg.norm(D)</span>
        <span class="c1">#     MaxErr = D.max()</span>
        <span class="c1"># # Print results</span>
        <span class="c1"># if verbose:</span>
        <span class="c1">#     if decomposition == &#39;DRP&#39;:</span>
        <span class="c1">#         print(&quot;Polar decomposition of the matrix M = Mdesp * Mr * Mp:&quot;)</span>
        <span class="c1">#     for ind in range(3):</span>
        <span class="c1">#         print(&quot;&quot;)</span>
        <span class="c1">#         if decomposition[ind] == &#39;D&#39;:</span>
        <span class="c1">#             print(&quot;The depolarizer Mueller matrix is:&quot;)</span>
        <span class="c1">#             print(Md)</span>
        <span class="c1">#             print(&quot;Parameters:&quot;)</span>
        <span class="c1">#             print((&quot;  - Polarizance = {}.&quot;.format(Pd)))</span>
        <span class="c1">#             print((&quot;  - Depolarization degree = {}.&quot;.format(Desp)))</span>
        <span class="c1">#         elif decomposition[ind] == &#39;P&#39;:</span>
        <span class="c1">#             print(&quot;The diatenuator/polarizer Mueller matrix is:&quot;)</span>
        <span class="c1">#             if singM and nz &lt; 3:</span>
        <span class="c1">#                 print(</span>
        <span class="c1">#                     &quot;Warning: Retarder matrix may be slightly inaccurate&quot;</span>
        <span class="c1">#                 )</span>
        <span class="c1">#             print(Mp)</span>
        <span class="c1">#             print(&quot;Parameters:&quot;)</span>
        <span class="c1">#             print((&quot;  - p1 = {}; p2 = {}.&quot;.format(p1, p2)))</span>
        <span class="c1">#             print((</span>
        <span class="c1">#                 &quot;  - Angle = {} deg; Delay between components = {} deg.&quot;</span>
        <span class="c1">#                 .format((alphaP / degrees), (delayP / degrees))))</span>
        <span class="c1">#             print(</span>
        <span class="c1">#                 (&quot;  - Azimuth = {} deg; Ellipticity = {} deg.&quot;.format(</span>
        <span class="c1">#                     (fiP / degrees), (chiP / degrees))))</span>
        <span class="c1">#             Tmax, Tmin = Mp.parameters.transmissions()</span>
        <span class="c1">#             print((</span>
        <span class="c1">#                 &quot;  - Max. transmission = {} %; Min. transmission = {} %.&quot;</span>
        <span class="c1">#                 .format((Tmax * 100), (Tmin * 100))))</span>
        <span class="c1">#         else:</span>
        <span class="c1">#             print(&quot;The retarder Mueller matrix is:&quot;)</span>
        <span class="c1">#             print(Mr)</span>
        <span class="c1">#             print(&quot;Parameters:&quot;)</span>
        <span class="c1">#             print((&quot;  - Delay = {} deg.&quot;.format((R / degrees))))</span>
        <span class="c1">#             print((</span>
        <span class="c1">#                 &quot;  - Angle = {} deg; Delay between components = {} deg.&quot;</span>
        <span class="c1">#                 .format((alphaR / degrees), (delayR / degrees))))</span>
        <span class="c1">#             print(</span>
        <span class="c1">#                 (&quot;  - Azimuth = {} deg; Ellipticity = {} deg.&quot;.format(</span>
        <span class="c1">#                     (fiR / degrees), (chiR / degrees))))</span>
        <span class="c1">#     print(&quot;&quot;)</span>
        <span class="c1">#     print((&quot;The mean square error in the decomposition is: {}&quot;.format(</span>
        <span class="c1">#         MeanErr)))</span>
        <span class="c1">#     print(</span>
        <span class="c1">#         (&quot;The maximum error in the decomposition is: {}&quot;.format(MaxErr)</span>
        <span class="c1">#          ))</span>
        <span class="c1">#     print(&quot;------------------------------------------------------&quot;)</span>
        <span class="c1"># # Dictionary of parameters</span>
        <span class="c1"># if give_all:</span>
        <span class="c1">#     param = dict(</span>
        <span class="c1">#         Delay=R,</span>
        <span class="c1">#         AngleR=alphaR,</span>
        <span class="c1">#         AxisDelayR=delayR,</span>
        <span class="c1">#         AzimuthR=chiR,</span>
        <span class="c1">#         EllipticityR=fiR,</span>
        <span class="c1">#         p1=p1,</span>
        <span class="c1">#         p2=p2,</span>
        <span class="c1">#         AngleP=alphaP,</span>
        <span class="c1">#         AxisDelayP=delayP,</span>
        <span class="c1">#         AzimuthP=fiP,</span>
        <span class="c1">#         EllipticityP=chiP,</span>
        <span class="c1">#         DespPolarizance=Pd,</span>
        <span class="c1">#         DespDegree=Desp,</span>
        <span class="c1">#         MeanError=MeanErr,</span>
        <span class="c1">#         MaxError=MaxErr)</span>
        <span class="c1"># # Output</span>
        <span class="c1"># if give_all:</span>
        <span class="c1">#     return Mout[0], Mout[1], Mout[2], param</span>
        <span class="c1"># else:</span>
        <span class="c1">#     return Mout[0], Mout[1], Mout[2]</span>


<div class="viewcode-block" id="Check_Mueller"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Check_Mueller">[docs]</a><span class="k">class</span> <span class="nc">Check_Mueller</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class for Check of Mueller Matrices</span>

<span class="sd">    Parameters:</span>
<span class="sd">        parent (Mueller_matrix): Mueller Matrix</span>

<span class="sd">    Attributes:</span>
<span class="sd">        self.parent (Mueller): parent object.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Print all parameters.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">get_all</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">draw</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="s1">&#39;&#39;</span>

<div class="viewcode-block" id="Check_Mueller.get_all"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Check_Mueller.get_all">[docs]</a>    <span class="k">def</span> <span class="nf">get_all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">draw</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates a dictionary with all the checks of Mueller matrix.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            verbose (bool): If True, print all parameters. Default: False.</span>
<span class="sd">            draw (bool): If True, draw all plots/images of the parameters. Default: False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dict_params</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">dict_params</span><span class="p">[</span><span class="s1">&#39;Physical&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_physical</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                                                        <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
        <span class="n">dict_params</span><span class="p">[</span><span class="s1">&#39;Pure&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_pure</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
        <span class="n">dict_params</span><span class="p">[</span><span class="s1">&#39;Homogenous&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_homogeneous</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                                                             <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
        <span class="n">dict_params</span><span class="p">[</span><span class="s1">&#39;Retarder&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_retarder</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                                                        <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
        <span class="n">dict_params</span><span class="p">[</span><span class="s1">&#39;Diattenuator&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_diattenuator</span><span class="p">(</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
        <span class="n">dict_params</span><span class="p">[</span><span class="s1">&#39;Depolarizer&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_depolarizer</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                                                              <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
        <span class="n">dict_params</span><span class="p">[</span><span class="s1">&#39;Singular&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_singular</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                                                        <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
        <span class="n">dict_params</span><span class="p">[</span><span class="s1">&#39;Symmetric&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_symmetric</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                                                          <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dict_params</span></div>

<div class="viewcode-block" id="Check_Mueller.is_physical"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Check_Mueller.is_physical">[docs]</a>    <span class="k">def</span> <span class="nf">is_physical</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                    <span class="n">tol</span><span class="o">=</span><span class="n">tol_default</span><span class="p">,</span>
                    <span class="n">give_all</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">ignore_cond</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">out_number</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">draw</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A Mueller matrix must fulfill several conditions in order to be physically realizable:</span>

<span class="sd">        1. $M_{ij}\in\mathbb{R}$ for i, j = 0, 1, 2 and 3.</span>
<span class="sd">        2a. $M_{00} \geq 0$.</span>
<span class="sd">        2b. $M_{00} \leq 1$ (except in active media).</span>
<span class="sd">        3. $M_{00}\geq abs(M_{ij})$ for i, j = 0, 1, 2 and 3.</span>
<span class="sd">        4a. $D \leq 1$</span>
<span class="sd">        4a. $P \leq 1$.</span>
<span class="sd">        5a. $M_{00} (1 + D) \leq 1$ (except in active media).</span>
<span class="sd">        5b. $M_{00} (1 + P) \leq 1$ (except in active media).</span>
<span class="sd">        6. $Tr(M*M^T)\leq 4(M_{00})^2$.</span>
<span class="sd">        7a. $M_{00}^{2}\left(1-D\right)^{2}\geq\mathop{\sum_{i=1}^{3}M_{0i}^{2}\left(1-\sum_{j=1}^{3}\frac{M_{ij}}{M_{00}D}\right)}^{2}$.</span>
<span class="sd">        7b. $M_{00}^{2}\left(1-P\right)^{2}\geq\mathop{\sum_{i=1}^{3}M_{i0}^{2}\left(1-\sum_{j=1}^{3}\frac{M_{ji}}{M_{00}P}\right)}^{2}$.</span>
<span class="sd">        8a. $\lambda_{i}\in\mathbb{R}$</span>
<span class="sd">        8b. $\lambda_{i}  \geq  0$.</span>
<span class="sd">        8c. $\lambda_{i}  \leq  1$ (except in active media).</span>

<span class="sd">        Being D the diattenuation, P the polarizance and $\lambda_{i}$ the eigenvalues of the covariance matrix.</span>

<span class="sd">        References:</span>
<span class="sd">            Handbook of Optics vol 2. 22.34 (There is an errata in the equation equivalent to condition 7).</span>
<span class="sd">            &quot;Polarized light and the Mueller Matrix approach&quot;, J. J. Gil, pp 187.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            tol (float): Tolerance in conditions. Default: tol_default.</span>
<span class="sd">            give_all (bool): If True, the method also gives a list with the individual conditions. Default: False.</span>
<span class="sd">            ignore_cond (list): Conditions to ignore. If False or None, no condition is ignored. Default: None.</span>
<span class="sd">            out_number (bool): If True and the result is a 1x1 array, return a number instead. Default: True.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>
<span class="sd">            verbose (bool): If True prints the parameter. Default: False.</span>
<span class="sd">            draw (bool): If True and the object is a 1D or 2D, plot it. Default: False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            cond (numpy.ndarray or bool): Result.</span>
<span class="sd">            partial_conditions (list): List with the partial conditions.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Prepare to ignore conditions</span>
        <span class="k">if</span> <span class="n">ignore_cond</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">ignore_cond</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">use_cond</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">]</span> <span class="o">*</span> <span class="mi">8</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">use_cond</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">]</span> <span class="o">*</span> <span class="mi">8</span>
            <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">ignore_cond</span><span class="p">:</span>
                    <span class="n">use_cond</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Calculate the parameters</span>
        <span class="n">M00</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">mean_transmission</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                                       <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span>
                                                       <span class="n">out_number</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">diattenuation</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                                 <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span>
                                                 <span class="n">out_number</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">polarizance</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                               <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span>
                                               <span class="n">out_number</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">comp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">components</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                                 <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span>
                                                 <span class="n">out_number</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">H</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">covariance_matrix</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                        <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span>
                                        <span class="n">out_number</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Calculate the conditions</span>
        <span class="k">if</span> <span class="n">use_cond</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">cond_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isreal</span><span class="p">(</span><span class="n">comp</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">16</span><span class="p">):</span>
                <span class="n">cond_1</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">isreal</span><span class="p">(</span><span class="n">comp</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cond_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">use_cond</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">cond_2a</span> <span class="o">=</span> <span class="n">M00</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="n">tol</span>
            <span class="n">cond_2b</span> <span class="o">=</span> <span class="n">M00</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">tol</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cond_2a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="n">cond_2b</span> <span class="o">=</span> <span class="n">cond_2a</span>

        <span class="k">if</span> <span class="n">use_cond</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
            <span class="n">cond_3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">16</span><span class="p">):</span>
                <span class="n">cond_3</span> <span class="o">*=</span> <span class="n">comp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">comp</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cond_3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">use_cond</span><span class="p">[</span><span class="mi">3</span><span class="p">]:</span>
            <span class="n">cond_4a</span> <span class="o">=</span> <span class="n">D</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">tol</span>
            <span class="n">cond_4b</span> <span class="o">=</span> <span class="n">P</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">tol</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cond_4a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="n">cond_4b</span> <span class="o">=</span> <span class="n">cond_4a</span>

        <span class="k">if</span> <span class="n">use_cond</span><span class="p">[</span><span class="mi">4</span><span class="p">]:</span>
            <span class="n">cond_5a</span> <span class="o">=</span> <span class="n">M00</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">D</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">tol</span>
            <span class="n">cond_5b</span> <span class="o">=</span> <span class="n">M00</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">P</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">tol</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cond_5a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="n">cond_5b</span> <span class="o">=</span> <span class="n">cond_5a</span>

        <span class="k">if</span> <span class="n">use_cond</span><span class="p">[</span><span class="mi">5</span><span class="p">]:</span>
            <span class="nb">sum</span> <span class="o">=</span> <span class="n">comp</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">comp</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">comp</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span>
                <span class="n">comp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">comp</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="n">comp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">comp</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">+</span> <span class="n">comp</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="n">comp</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">+</span>
                <span class="n">comp</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">*</span> <span class="n">comp</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">+</span> <span class="n">comp</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">*</span> <span class="n">comp</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span> <span class="o">+</span> <span class="n">comp</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">*</span> <span class="n">comp</span><span class="p">[</span><span class="mi">14</span><span class="p">])</span>
            <span class="n">cond_6</span> <span class="o">=</span> <span class="nb">sum</span> <span class="o">&lt;=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">M00</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">tol</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cond_6</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">use_cond</span><span class="p">[</span><span class="mi">6</span><span class="p">]:</span>
            <span class="n">aux1</span> <span class="o">=</span> <span class="n">M00</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">D</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">aux2</span> <span class="o">=</span> <span class="p">(</span><span class="n">comp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">comp</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">+</span> <span class="n">comp</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">+</span> <span class="n">comp</span><span class="p">[</span><span class="mi">7</span><span class="p">])</span> <span class="o">/</span>
                                  <span class="p">(</span><span class="n">M00</span> <span class="o">*</span> <span class="n">D</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">comp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span>
                    <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">comp</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">+</span> <span class="n">comp</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">+</span> <span class="n">comp</span><span class="p">[</span><span class="mi">11</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">M00</span> <span class="o">*</span> <span class="n">D</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span>
                    <span class="n">comp</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">comp</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span> <span class="o">+</span> <span class="n">comp</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span> <span class="o">+</span> <span class="n">comp</span><span class="p">[</span><span class="mi">15</span><span class="p">])</span> <span class="o">/</span>
                                  <span class="p">(</span><span class="n">M00</span> <span class="o">*</span> <span class="n">D</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">cond_7a</span> <span class="o">=</span> <span class="n">aux1</span> <span class="o">&gt;=</span> <span class="n">aux2</span>
            <span class="n">aux1</span> <span class="o">=</span> <span class="n">M00</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">P</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">aux2</span> <span class="o">=</span> <span class="p">(</span><span class="n">comp</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">comp</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">+</span> <span class="n">comp</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">+</span> <span class="n">comp</span><span class="p">[</span><span class="mi">13</span><span class="p">])</span> <span class="o">/</span>
                                  <span class="p">(</span><span class="n">M00</span> <span class="o">*</span> <span class="n">P</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">comp</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span>
                    <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">comp</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">+</span> <span class="n">comp</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">+</span> <span class="n">comp</span><span class="p">[</span><span class="mi">14</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">M00</span> <span class="o">*</span> <span class="n">P</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span>
                    <span class="n">comp</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">comp</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">+</span> <span class="n">comp</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">+</span> <span class="n">comp</span><span class="p">[</span><span class="mi">15</span><span class="p">])</span> <span class="o">/</span>
                                   <span class="p">(</span><span class="n">M00</span> <span class="o">*</span> <span class="n">P</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">cond_7b</span> <span class="o">=</span> <span class="n">aux1</span> <span class="o">&gt;=</span> <span class="n">aux2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cond_7a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="n">cond_7b</span> <span class="o">=</span> <span class="n">cond_5a</span>

        <span class="k">if</span> <span class="n">use_cond</span><span class="p">[</span><span class="mi">7</span><span class="p">]:</span>
            <span class="n">cond_8a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="n">cond_8b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="n">cond_8c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">vals</span><span class="p">:</span>
                <span class="c1"># print(&#39;elements&#39;, elem)</span>
                <span class="n">cond_8a</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">elem</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">tol</span>
                <span class="c1"># print(&#39;result&#39;, cond_8a)</span>
                <span class="n">cond_8b</span> <span class="o">*=</span> <span class="n">elem</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="n">tol</span>
                <span class="n">cond_8c</span> <span class="o">*=</span> <span class="n">elem</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">tol</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cond_8a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="n">cond_8b</span> <span class="o">=</span> <span class="n">cond_8a</span>
            <span class="n">cond_8c</span> <span class="o">=</span> <span class="n">cond_8a</span>

        <span class="c1"># Merge de conditions and multiply</span>
        <span class="n">cond_partial</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">cond_1</span><span class="p">,</span> <span class="n">cond_2a</span><span class="p">,</span> <span class="n">cond_2b</span><span class="p">,</span> <span class="n">cond_3</span><span class="p">,</span> <span class="n">cond_4a</span><span class="p">,</span> <span class="n">cond_4b</span><span class="p">,</span> <span class="n">cond_5a</span><span class="p">,</span>
            <span class="n">cond_5b</span><span class="p">,</span> <span class="n">cond_6</span><span class="p">,</span> <span class="n">cond_7a</span><span class="p">,</span> <span class="n">cond_7b</span><span class="p">,</span> <span class="n">cond_8a</span><span class="p">,</span> <span class="n">cond_8b</span><span class="p">,</span> <span class="n">cond_8c</span>
        <span class="p">]</span>

        <span class="n">cond</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">cond_partial</span><span class="p">:</span>
            <span class="n">cond</span> <span class="o">*=</span> <span class="n">elem</span>
            <span class="c1"># If the result is a number and the user asks for it, return a float</span>
            <span class="k">if</span> <span class="n">out_number</span> <span class="ow">and</span> <span class="n">elem</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">elem</span> <span class="o">=</span> <span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">out_number</span> <span class="ow">and</span> <span class="n">cond</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">cond</span> <span class="o">=</span> <span class="n">cond</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Print the result if required</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">draw</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">give_all</span><span class="p">:</span>
                <span class="n">cond_plot</span> <span class="o">=</span> <span class="p">[</span><span class="n">cond</span><span class="p">]</span> <span class="o">+</span> <span class="n">cond_partial</span>
                <span class="n">titles</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="s1">&#39;Physical&#39;</span><span class="p">,</span> <span class="s1">&#39;Real elements&#39;</span><span class="p">,</span> <span class="s1">&#39;M00 &gt;= 0&#39;</span><span class="p">,</span> <span class="s1">&#39;M00 &lt;= 1&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;abs(Mij) &lt;= M00&#39;</span><span class="p">,</span> <span class="s1">&#39;D &lt;= 1&#39;</span><span class="p">,</span> <span class="s1">&#39;P &lt;= 1&#39;</span><span class="p">,</span> <span class="s1">&#39;Tmax &lt;= 1&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;Recip Tmax &lt;= 1&#39;</span><span class="p">,</span> <span class="s1">&#39;Tr(M*M^T) &lt;= 4*M00^2&#39;</span><span class="p">,</span> <span class="s1">&#39;m cond (D)&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;m cond (P)&#39;</span><span class="p">,</span> <span class="s1">&#39;Real eigenvalues&#39;</span><span class="p">,</span> <span class="s1">&#39;Eigenvalues &gt;= 0&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;Eigenvalues &lt;= 1&#39;</span>
                <span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cond_plot</span> <span class="o">=</span> <span class="p">[</span><span class="n">cond</span><span class="p">]</span>
                <span class="n">titles</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Physical&#39;</span><span class="p">]</span>
            <span class="n">heading</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> is physically realizable:&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">PrintParam</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="n">cond_plot</span><span class="p">,</span>
                       <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                       <span class="n">title</span><span class="o">=</span><span class="n">titles</span><span class="p">,</span>
                       <span class="n">heading</span><span class="o">=</span><span class="n">heading</span><span class="p">,</span>
                       <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                       <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
        <span class="c1"># Return</span>
        <span class="k">if</span> <span class="n">give_all</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cond</span><span class="p">,</span> <span class="n">cond_partial</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cond</span></div>

<div class="viewcode-block" id="Check_Mueller.is_non_depolarizing"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Check_Mueller.is_non_depolarizing">[docs]</a>    <span class="k">def</span> <span class="nf">is_non_depolarizing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                            <span class="n">out_number</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                            <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                            <span class="n">draw</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Checks if matrix is pure, i.e., is non-depolarizing (the degree of polarimetric purity must be 1).</span>

<span class="sd">        Parameters:</span>
<span class="sd">            out_number (bool): If True and the result is a 1x1 array, return a number instead. Default: True.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>
<span class="sd">            verbose (bool): If True prints the parameter. Default: False.</span>
<span class="sd">            draw (bool): If True and the object is a 1D or 2D, plot it. Default: False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (numpy.ndarray or bool): Result.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Calculate the parameters</span>
        <span class="n">PP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">polarimetric_purity</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                                        <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span>
                                                        <span class="n">out_number</span><span class="o">=</span><span class="n">out_number</span><span class="p">)</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">PP</span> <span class="o">&lt;=</span> <span class="n">tol_default</span>
        <span class="c1"># Print the result if required</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">draw</span><span class="p">:</span>
            <span class="n">heading</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> is pure (non-depolarizing):&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">PrintParam</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="n">cond</span><span class="p">,</span>
                       <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                       <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Pure&#39;</span><span class="p">,</span>
                       <span class="n">heading</span><span class="o">=</span><span class="n">heading</span><span class="p">,</span>
                       <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                       <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cond</span></div>

<div class="viewcode-block" id="Check_Mueller.is_pure"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Check_Mueller.is_pure">[docs]</a>    <span class="k">def</span> <span class="nf">is_pure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                <span class="n">out_number</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">draw</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Checks if matrix is pure, i.e., is non-depolarizing (the degree of polarimetric purity must be 1).</span>

<span class="sd">        Parameters:</span>
<span class="sd">            out_number (bool): If True and the result is a 1x1 array, return a number instead. Default: True.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>
<span class="sd">            verbose (bool): If True prints the parameter. Default: False.</span>
<span class="sd">            draw (bool): If True and the object is a 1D or 2D, plot it. Default: False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (numpy.ndarray or bool): Result.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Calculate the parameters</span>
        <span class="n">PP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">polarimetric_purity</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                                        <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span>
                                                        <span class="n">out_number</span><span class="o">=</span><span class="n">out_number</span><span class="p">)</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">PP</span> <span class="o">&lt;=</span> <span class="n">tol_default</span>
        <span class="c1"># Print the result if required</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">draw</span><span class="p">:</span>
            <span class="n">heading</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> is pure (non-depolarizing):&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">PrintParam</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="n">cond</span><span class="p">,</span>
                       <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                       <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Pure&#39;</span><span class="p">,</span>
                       <span class="n">heading</span><span class="o">=</span><span class="n">heading</span><span class="p">,</span>
                       <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                       <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cond</span></div>

<div class="viewcode-block" id="Check_Mueller.is_homogeneous"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Check_Mueller.is_homogeneous">[docs]</a>    <span class="k">def</span> <span class="nf">is_homogeneous</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                       <span class="n">out_number</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                       <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                       <span class="n">draw</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Checks if the matrix is homogeneous, i.e., its two eigenstates are perpendicular. If true, the inhomogeneity parameter must be 0.</span>

<span class="sd">        References:</span>
<span class="sd">            J.J. Gil, R. Ossikovsky &quot;Polarized light and the Mueller Matrix approach&quot;, CRC Press (2016), pp 119.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            out_number (bool): If True and the result is a 1x1 array, return a number instead. Default: True.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>
<span class="sd">            verbose (bool): If True prints the parameter. Default: False.</span>
<span class="sd">            draw (bool): If True and the object is a 1D or 2D, plot it. Default: False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (numpy.ndarray or bool): Result.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Calculate the parameters</span>
        <span class="n">par</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">inhomogeneity</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                                   <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span>
                                                   <span class="n">out_number</span><span class="o">=</span><span class="n">out_number</span><span class="p">)</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">par</span> <span class="o">&lt;=</span> <span class="n">tol_default</span>
        <span class="c1"># Print the result if required</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">draw</span><span class="p">:</span>
            <span class="n">heading</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> is homogeneous:&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">PrintParam</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="n">cond</span><span class="p">,</span>
                       <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                       <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Homogeneous&#39;</span><span class="p">,</span>
                       <span class="n">heading</span><span class="o">=</span><span class="n">heading</span><span class="p">,</span>
                       <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                       <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cond</span></div>

<div class="viewcode-block" id="Check_Mueller.is_retarder"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Check_Mueller.is_retarder">[docs]</a>    <span class="k">def</span> <span class="nf">is_retarder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                    <span class="n">give_all</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">out_number</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">draw</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Checks if the matrix M corresponds to a pure retarder.There are three</span>
<span class="sd">        conditions:</span>

<span class="sd">        1. Is physical</span>
<span class="sd">        2. Is pure</span>
<span class="sd">        3. Diatteunation = 0.</span>
<span class="sd">        4. Polarizance = 0.</span>
<span class="sd">        5. M must be unitary ($M^{T}=M^{-1}$).</span>

<span class="sd">        References:</span>
<span class="sd">            J.J. Gil, R. Ossikovsky &quot;Polarized light and the Mueller Matrix approach&quot;, CRC Press (2016), pp 129.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            give_all (bool): If True, the method also gives a list with the individual conditions. Default: False.</span>
<span class="sd">            out_number (bool): If True and the result is a 1x1 array, return a number instead. Default: True.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>
<span class="sd">            verbose (bool): If True prints the parameter. Default: False.</span>
<span class="sd">            draw (bool): If True and the object is a 1D or 2D, plot it. Default: False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            cond (numpy.ndarray or bool): Result.</span>
<span class="sd">            partial_conditions (list): List with the partial conditions (if give_all is True).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Reality and purity</span>
        <span class="n">cond1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_physical</span><span class="p">()</span>
        <span class="n">cond2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_pure</span><span class="p">()</span>

        <span class="c1"># Diattenuation and polarizance</span>
        <span class="n">par</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">diattenuation</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                                   <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span>
                                                   <span class="n">out_number</span><span class="o">=</span><span class="n">out_number</span><span class="p">)</span>
        <span class="n">cond3</span> <span class="o">=</span> <span class="n">par</span> <span class="o">&lt;=</span> <span class="n">tol_default</span>

        <span class="n">par</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">polarizance</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                                 <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span>
                                                 <span class="n">out_number</span><span class="o">=</span><span class="n">out_number</span><span class="p">)</span>
        <span class="n">cond4</span> <span class="o">=</span> <span class="n">par</span> <span class="o">&lt;=</span> <span class="n">tol_default</span>

        <span class="c1"># Unitary</span>
        <span class="n">obj_T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">obj_inv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">inverse</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">obj_T</span> <span class="o">-</span> <span class="n">obj_inv</span>
        <span class="n">cond5</span> <span class="o">=</span> <span class="n">norm_1a</span> <span class="o">=</span> <span class="n">obj_error</span><span class="p">(</span><span class="n">obj_T</span><span class="p">,</span>
                                    <span class="n">obj_inv</span><span class="p">,</span>
                                    <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                    <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span>
                                    <span class="n">out_number</span><span class="o">=</span><span class="n">out_number</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol_default</span>

        <span class="c1"># Reshape</span>
        <span class="n">cond1</span><span class="p">,</span> <span class="n">cond2</span><span class="p">,</span> <span class="n">cond3</span><span class="p">,</span> <span class="n">cond4</span><span class="p">,</span> <span class="n">cond5</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">([</span><span class="n">cond1</span><span class="p">,</span> <span class="n">cond2</span><span class="p">,</span> <span class="n">cond3</span><span class="p">,</span> <span class="n">cond4</span><span class="p">,</span> <span class="n">cond5</span><span class="p">],</span>
                                      <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span>
                                      <span class="n">shape_fun</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                      <span class="n">obj</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">cond1</span> <span class="o">*</span> <span class="n">cond2</span> <span class="o">*</span> <span class="n">cond3</span> <span class="o">*</span> <span class="n">cond4</span> <span class="o">*</span> <span class="n">cond5</span>

        <span class="c1"># Print the result if required</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">draw</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">give_all</span><span class="p">:</span>
                <span class="n">cond_plot</span> <span class="o">=</span> <span class="p">[</span><span class="n">cond</span><span class="p">,</span> <span class="n">cond1</span><span class="p">,</span> <span class="n">cond2</span><span class="p">,</span> <span class="n">cond3</span><span class="p">,</span> <span class="n">cond4</span><span class="p">,</span> <span class="n">cond5</span><span class="p">]</span>
                <span class="n">titles</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Retarder&#39;</span><span class="p">,</span> <span class="s2">&quot;Physical&quot;</span><span class="p">,</span> <span class="s2">&quot;Pure&quot;</span><span class="p">,</span> <span class="s1">&#39;D = 0&#39;</span><span class="p">,</span> <span class="s1">&#39;P = 0&#39;</span><span class="p">,</span> <span class="s1">&#39;Unitary&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cond_plot</span> <span class="o">=</span> <span class="p">[</span><span class="n">cond</span><span class="p">]</span>
                <span class="n">titles</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Retarder&#39;</span><span class="p">]</span>
            <span class="n">heading</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> is a retarder:&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">PrintParam</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="n">cond_plot</span><span class="p">,</span>
                       <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                       <span class="n">title</span><span class="o">=</span><span class="n">titles</span><span class="p">,</span>
                       <span class="n">heading</span><span class="o">=</span><span class="n">heading</span><span class="p">,</span>
                       <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                       <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
        <span class="c1"># Return</span>
        <span class="k">if</span> <span class="n">give_all</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cond</span><span class="p">,</span> <span class="p">[</span><span class="n">cond1</span><span class="p">,</span> <span class="n">cond2</span><span class="p">,</span> <span class="n">cond3</span><span class="p">,</span> <span class="n">cond4</span><span class="p">,</span> <span class="n">cond5</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cond</span></div>

<div class="viewcode-block" id="Check_Mueller.is_diattenuator"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Check_Mueller.is_diattenuator">[docs]</a>    <span class="k">def</span> <span class="nf">is_diattenuator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                        <span class="n">give_all</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">out_number</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">draw</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Checks if the matrix M corresponds to a pure homogeneous diattenuator. It must fullfill several conditions:</span>

<span class="sd">        1. Is physical</span>
<span class="sd">        2. Is pure</span>
<span class="sd">        3. Diattenuation &gt; 0.</span>
<span class="sd">        4. $M = M^T$.</span>
<span class="sd">        5. The eigenstates of M are the Stokes vectors (1, D) and (1, -D).</span>

<span class="sd">        References:</span>
<span class="sd">            J.J. Gil, R. Ossikovsky &quot;Polarized light and the Mueller Matrix approach&quot;, CRC Press (2016), pp 142.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            give_all (bool): If True, the method also gives a list with the individual conditions. Default: False.</span>
<span class="sd">            out_number (bool): If True and the result is a 1x1 array, return a number instead. Default: True.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>
<span class="sd">            verbose (bool): If True prints the parameter. Default: False.</span>
<span class="sd">            draw (bool): If True and the object is a 1D or 2D, plot it. Default: False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            cond (numpy.ndarray or bool): Result.</span>
<span class="sd">            partial_conditions (list): List with the partial conditions (if give_all is True).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Reality and purity</span>
        <span class="n">cond1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_physical</span><span class="p">()</span>
        <span class="n">cond2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_pure</span><span class="p">()</span>

        <span class="c1"># Calculate the first two conditions</span>
        <span class="n">par</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">diattenuation</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                   <span class="n">out_number</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">cond3</span> <span class="o">=</span> <span class="n">par</span> <span class="o">&gt;</span> <span class="n">tol_default</span>
        <span class="n">Dv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">diattenuation_vector</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">obj_T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">cond4</span> <span class="o">=</span> <span class="n">obj_error</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span>
                          <span class="n">obj_T</span><span class="p">,</span>
                          <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                          <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span>
                          <span class="n">out_number</span><span class="o">=</span><span class="n">out_number</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol_default</span>

        <span class="c1"># The third one is more complicated. Start by calculating the diattenuation vector</span>
        <span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">diattenuation_vector</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">as_Stokes</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># Check if it is eigenstate</span>
        <span class="n">condA</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_eigenstate</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
        <span class="n">D</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:]</span> <span class="o">=</span> <span class="o">-</span><span class="n">D</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:]</span>
        <span class="n">condB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_eigenstate</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
        <span class="n">cond5</span> <span class="o">=</span> <span class="n">condA</span> <span class="o">*</span> <span class="n">condB</span>

        <span class="c1"># Reshape</span>
        <span class="n">cond1</span><span class="p">,</span> <span class="n">cond2</span><span class="p">,</span> <span class="n">cond3</span><span class="p">,</span> <span class="n">cond4</span><span class="p">,</span> <span class="n">cond5</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">([</span><span class="n">cond1</span><span class="p">,</span> <span class="n">cond2</span><span class="p">,</span> <span class="n">cond3</span><span class="p">,</span> <span class="n">cond4</span><span class="p">,</span> <span class="n">cond5</span><span class="p">],</span>
                                      <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span>
                                      <span class="n">shape_fun</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                      <span class="n">obj</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>
        <span class="c1"># Total condition</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">cond1</span> <span class="o">*</span> <span class="n">cond2</span> <span class="o">*</span> <span class="n">cond3</span> <span class="o">*</span> <span class="n">cond4</span> <span class="o">*</span> <span class="n">cond5</span>

        <span class="c1"># Print the result if required</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">draw</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">give_all</span><span class="p">:</span>
                <span class="n">cond_plot</span> <span class="o">=</span> <span class="p">[</span><span class="n">cond</span><span class="p">,</span> <span class="n">cond1</span><span class="p">,</span> <span class="n">cond2</span><span class="p">,</span> <span class="n">cond3</span><span class="p">,</span> <span class="n">cond4</span><span class="p">,</span> <span class="n">cond5</span><span class="p">]</span>
                <span class="n">titles</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="s1">&#39;Diattenuator&#39;</span><span class="p">,</span> <span class="s2">&quot;Physical&quot;</span><span class="p">,</span> <span class="s2">&quot;Pure&quot;</span><span class="p">,</span> <span class="s1">&#39;D &gt; 0&#39;</span><span class="p">,</span> <span class="s1">&#39;Symetric&#39;</span><span class="p">,</span> <span class="s1">&#39;Correct eigenstates&#39;</span>
                <span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cond_plot</span> <span class="o">=</span> <span class="p">[</span><span class="n">cond</span><span class="p">]</span>
                <span class="n">titles</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Diattenuator&#39;</span><span class="p">]</span>
            <span class="n">heading</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> is a diattenuator:&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">PrintParam</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="n">cond_plot</span><span class="p">,</span>
                       <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                       <span class="n">title</span><span class="o">=</span><span class="n">titles</span><span class="p">,</span>
                       <span class="n">heading</span><span class="o">=</span><span class="n">heading</span><span class="p">,</span>
                       <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                       <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
        <span class="c1"># Return</span>
        <span class="k">if</span> <span class="n">give_all</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cond</span><span class="p">,</span> <span class="p">[</span><span class="n">cond1</span><span class="p">,</span> <span class="n">cond2</span><span class="p">,</span> <span class="n">cond3</span><span class="p">,</span> <span class="n">cond4</span><span class="p">,</span> <span class="n">cond5</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cond</span></div>

<div class="viewcode-block" id="Check_Mueller.is_polarizer"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Check_Mueller.is_polarizer">[docs]</a>    <span class="k">def</span> <span class="nf">is_polarizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                     <span class="n">give_all</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                     <span class="n">out_number</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                     <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                     <span class="n">draw</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Checks if the matrix M corresponds to a pure homogeneous polarizer (diattenuator). It must fullfill several conditions:</span>

<span class="sd">        1. Is physical</span>
<span class="sd">        2. Is pure</span>
<span class="sd">        3. Polarizance &gt; 0.</span>
<span class="sd">        4. $M = M^T$.</span>
<span class="sd">        5. The eigenstates of M are the Stokes vectors (1, P) and (1, -P).</span>

<span class="sd">        Note: This method is the same as is_diattenuator.</span>

<span class="sd">        References:</span>
<span class="sd">            J.J. Gil, R. Ossikovsky &quot;Polarized light and the Mueller Matrix approach&quot;, CRC Press (2016), pp 142.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            give_all (bool): If True, the method also gives a list with the individual conditions. Default: False.</span>
<span class="sd">            out_number (bool): If True and the result is a 1x1 array, return a number instead. Default: True.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>
<span class="sd">            verbose (bool): If True prints the parameter. Default: False.</span>
<span class="sd">            draw (bool): If True and the object is a 1D or 2D, plot it. Default: False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            cond (numpy.ndarray or bool): Result.</span>
<span class="sd">            partial_conditions (list): List with the partial conditions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">is_diattenuator</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Check_Mueller.is_depolarizer"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Check_Mueller.is_depolarizer">[docs]</a>    <span class="k">def</span> <span class="nf">is_depolarizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                       <span class="n">give_all</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                       <span class="n">out_number</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                       <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                       <span class="n">draw</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Checks if the matrix M corresponds to a depolarizer. It must fullfill several conditions:</span>

<span class="sd">        1. Is physical</span>
<span class="sd">        2. Depolarization index &gt; 0.</span>
<span class="sd">        3. $m = m^T$ (m being the small m matrix).</span>

<span class="sd">        References:</span>
<span class="sd">            S. Y. Lu, R. A. Chipman; &quot;Interpretation of Mueller matrices based on polar decomposition&quot;; J. Opt. Soc. Am. A/Vol. 13, No. 5 (1996)</span>

<span class="sd">        Parameters:</span>
<span class="sd">            give_all (bool): If True, the method also gives a list with the individual conditions. Default: False.</span>
<span class="sd">            out_number (bool): If True and the result is a 1x1 array, return a number instead. Default: True.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>
<span class="sd">            verbose (bool): If True prints the parameter. Default: False.</span>
<span class="sd">            draw (bool): If True and the object is a 1D or 2D, plot it. Default: False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            cond (numpy.ndarray or bool): Result.</span>
<span class="sd">            partial_conditions (list): List with the partial conditions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Reality</span>
        <span class="n">cond1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_physical</span><span class="p">()</span>
        <span class="c1"># Calculate the parameters</span>
        <span class="n">inhom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">depolarization_index</span><span class="p">(</span>
            <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span> <span class="n">out_number</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">small_matrix</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># First condition</span>
        <span class="n">cond2</span> <span class="o">=</span> <span class="n">inhom</span> <span class="o">&gt;</span> <span class="n">tol_default</span>
        <span class="c1"># Second condition</span>
        <span class="n">mT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">cond3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="n">mT</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">tol_default</span>
        <span class="c1"># Reshape</span>
        <span class="n">cond1</span><span class="p">,</span> <span class="n">cond2</span><span class="p">,</span> <span class="n">cond3</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">([</span><span class="n">cond1</span><span class="p">,</span> <span class="n">cond2</span><span class="p">,</span> <span class="n">cond3</span><span class="p">],</span>
                                      <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span>
                                      <span class="n">shape_fun</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                      <span class="n">obj</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>
        <span class="c1"># Total condition</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">cond1</span> <span class="o">*</span> <span class="n">cond2</span> <span class="o">*</span> <span class="n">cond3</span>
        <span class="c1"># Draw</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">draw</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">give_all</span><span class="p">:</span>
                <span class="n">cond_plot</span> <span class="o">=</span> <span class="p">[</span><span class="n">cond</span><span class="p">,</span> <span class="n">cond1</span><span class="p">,</span> <span class="n">cond2</span><span class="p">,</span> <span class="n">cond3</span><span class="p">]</span>
                <span class="n">titles</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Depolarizer&#39;</span><span class="p">,</span> <span class="s2">&quot;Physical&quot;</span><span class="p">,</span> <span class="s1">&#39;Depol. index &gt; 0&#39;</span><span class="p">,</span> <span class="s1">&#39;m is symetric&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cond_plot</span> <span class="o">=</span> <span class="p">[</span><span class="n">cond</span><span class="p">]</span>
                <span class="n">titles</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Depolarizer&#39;</span><span class="p">]</span>
            <span class="n">heading</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> is a depolarizer:&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">PrintParam</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="n">cond_plot</span><span class="p">,</span>
                       <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                       <span class="n">title</span><span class="o">=</span><span class="n">titles</span><span class="p">,</span>
                       <span class="n">heading</span><span class="o">=</span><span class="n">heading</span><span class="p">,</span>
                       <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                       <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
        <span class="c1"># Return</span>
        <span class="k">if</span> <span class="n">give_all</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cond</span><span class="p">,</span> <span class="p">[</span><span class="n">cond1</span><span class="p">,</span> <span class="n">cond2</span><span class="p">,</span> <span class="n">cond3</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cond</span></div>

<div class="viewcode-block" id="Check_Mueller.is_singular"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Check_Mueller.is_singular">[docs]</a>    <span class="k">def</span> <span class="nf">is_singular</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                    <span class="n">out_number</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">draw</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Checks if the matrix is singular (det(M) = 0).</span>

<span class="sd">        References:</span>
<span class="sd">            J.J. Gil, R. Ossikovsky &quot;Polarized light and the Mueller Matrix approach&quot;, CRC Press (2016), pp 282.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            out_number (bool): If True and the result is a 1x1 array, return a number instead. Default: True.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>
<span class="sd">            verbose (bool): If True prints the parameter. Default: False.</span>
<span class="sd">            draw (bool): If True and the object is a 1D or 2D, plot it. Default: False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (numpy.ndarray or bool): Result.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Calculate the parameters</span>
        <span class="n">par</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                         <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span>
                                         <span class="n">out_number</span><span class="o">=</span><span class="n">out_number</span><span class="p">)</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">par</span> <span class="o">&lt;=</span> <span class="n">tol_default</span>
        <span class="c1"># Print the result if required</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">draw</span><span class="p">:</span>
            <span class="n">heading</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> is singular:&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">PrintParam</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="n">cond</span><span class="p">,</span>
                       <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                       <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Singular&#39;</span><span class="p">,</span>
                       <span class="n">heading</span><span class="o">=</span><span class="n">heading</span><span class="p">,</span>
                       <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                       <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cond</span></div>

<div class="viewcode-block" id="Check_Mueller.is_symmetric"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Check_Mueller.is_symmetric">[docs]</a>    <span class="k">def</span> <span class="nf">is_symmetric</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                     <span class="n">out_number</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                     <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                     <span class="n">draw</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines if the object matrix is symmetric (i.e. $$M = M^T$$).</span>

<span class="sd">        Parameters:</span>
<span class="sd">            out_number (bool): If True and the result is a 1x1 array, return a number instead. Default: True.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>
<span class="sd">            verbose (bool): If True prints the parameter. Default: False.</span>
<span class="sd">            draw (bool): If True and the object is a 1D or 2D, plot it. Default: False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (numpy.ndarray or bool): Result.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Calculate the condition</span>
        <span class="n">obj_T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">obj_error</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span>
                         <span class="n">obj_T</span><span class="p">,</span>
                         <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                         <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span>
                         <span class="n">out_number</span><span class="o">=</span><span class="n">out_number</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol_default</span>
        <span class="c1"># Reshape if neccessary</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">([</span><span class="n">cond</span><span class="p">],</span>
                       <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span>
                       <span class="n">shape_fun</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                       <span class="n">obj</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>
        <span class="c1"># Print the result if required</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">draw</span><span class="p">:</span>
            <span class="n">heading</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> is symmetric:&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">PrintParam</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="n">cond</span><span class="p">,</span>
                       <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                       <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Symmetric&#39;</span><span class="p">,</span>
                       <span class="n">heading</span><span class="o">=</span><span class="n">heading</span><span class="p">,</span>
                       <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                       <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">cond</span></div>

<div class="viewcode-block" id="Check_Mueller.is_eigenstate"><a class="viewcode-back" href="../../source/py_pol/mueller.html#py_pol.mueller.Check_Mueller.is_eigenstate">[docs]</a>    <span class="k">def</span> <span class="nf">is_eigenstate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">out_number</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">shape_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">draw</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines if the vector S is an eigenstate of the object.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            S (Stokes or Jones_vector): State to test.</span>
<span class="sd">            out_number (bool): if True and the result is a 1x1 array, return a number instead. Default: True.</span>
<span class="sd">            shape_like (numpy.ndarray or py_pol object): Use the shape of this object. Default: None.</span>
<span class="sd">            shape (tuple or list): If no shape_like array is given, use this shape instead. Default: None.</span>
<span class="sd">            verbose (bool): if True prints the parameter. Default: False.</span>
<span class="sd">            draw (bool): If True and the object is a 1D or 2D, plot it. Default: False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (numpy.ndarray or bool): Result.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Multiply</span>
        <span class="n">Sout</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">*</span> <span class="n">S</span>
        <span class="c1"># Check if S and Sout are proportional</span>
        <span class="n">prop</span> <span class="o">=</span> <span class="n">Sout</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">/</span> <span class="n">S</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span>
        <span class="n">cond1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Sout</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">/</span> <span class="n">S</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">-</span> <span class="n">prop</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol_default</span>
        <span class="n">cond2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Sout</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="mi">2</span><span class="p">,:]</span> <span class="o">/</span> <span class="n">S</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="mi">2</span><span class="p">,:]</span> <span class="o">-</span> <span class="n">prop</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol_default</span>
        <span class="n">cond3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Sout</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="mi">3</span><span class="p">,:]</span> <span class="o">/</span> <span class="n">S</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="mi">3</span><span class="p">,:]</span> <span class="o">-</span> <span class="n">prop</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol_default</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">cond1</span> <span class="o">*</span> <span class="n">cond2</span> <span class="o">*</span> <span class="n">cond3</span>
        <span class="c1"># Reshape if neccessary</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">([</span><span class="n">cond</span><span class="p">],</span>
              <span class="n">shape_like</span><span class="o">=</span><span class="n">shape_like</span><span class="p">,</span>
              <span class="n">shape_fun</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
              <span class="n">obj</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>
        <span class="c1"># Print the result if required</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">draw</span><span class="p">:</span>
           <span class="n">heading</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> is an eigenstate of </span><span class="si">{}</span><span class="s1">:&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
           <span class="n">PrintParam</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="n">cond</span><span class="p">,</span>
                      <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                      <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Eigenstate&#39;</span><span class="p">,</span>
                      <span class="n">heading</span><span class="o">=</span><span class="n">heading</span><span class="p">,</span>
                      <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                      <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">cond</span></div></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019, Jesus del Hoyo Muรฑoz / Luis Miguel Sanchez Brea.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>